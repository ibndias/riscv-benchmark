
Temporary breakpoint 1, start_trigger () at ../config/riscv64/boards/generic/boardsupport.c:37
37	}
=> 0x102d4 <start_trigger+16>:	sd	ra,8(sp)
0x00000000000102d8	37	}
=> 0x102d8 <start_trigger+20>:	sd	s0,0(sp)
0x00000000000102dc	37	}
=> 0x102dc <start_trigger+24>:	addi	s0,sp,16
0x00000000000102e0	37	}
=> 0x102e0 <start_trigger+28>:	ld	s0,0(sp)
0x00000000000102e4 in start_trigger () at ../config/riscv64/boards/generic/boardsupport.c:37
37	}
=> 0x102e4 <start_trigger+32>:	ld	ra,8(sp)
0x00000000000102e8	37	}
=> 0x102e8 <start_trigger+36>:	addi	sp,sp,16
0x00000000000102ec	37	}
=> 0x102ec <start_trigger+40>:	ld	ra,0(t6)
0x00000000000102f0	37	}
=> 0x102f0 <start_trigger+44>:	addi	t6,t6,16
0x00000000000102f4	37	}
=> 0x102f4 <start_trigger+48>:	ret
main (argc=1, argv=0x3ffffffb68) at main.c:54
54	  for (i = 0; i < REPEAT_FACTOR; i++)
=> 0x10220 <main+144>:	ld	a0,-88(s0)
0x0000000000010224	54	  for (i = 0; i < REPEAT_FACTOR; i++)
=> 0x10224 <main+148>:	sw	a0,-36(s0)
0x0000000000010228	54	  for (i = 0; i < REPEAT_FACTOR; i++)
=> 0x10228 <main+152>:	j	0x1022c <main+156>
0x000000000001022c	54	  for (i = 0; i < REPEAT_FACTOR; i++)
=> 0x1022c <main+156>:	lw	a0,-36(s0)
0x0000000000010230	54	  for (i = 0; i < REPEAT_FACTOR; i++)
=> 0x10230 <main+160>:	li	a1,0
0x0000000000010234	54	  for (i = 0; i < REPEAT_FACTOR; i++)
=> 0x10234 <main+164>:	blt	a1,a0,0x10260 <main+208>
0x0000000000010238	54	  for (i = 0; i < REPEAT_FACTOR; i++)
=> 0x10238 <main+168>:	j	0x1023c <main+172>
56	      initialise_benchmark ();
=> 0x1023c <main+172>:	jal	ra,0x1092c <initialise_benchmark>
initialise_benchmark () at mont64.c:274
274	{
=> 0x1092c <initialise_benchmark>:	addi	t6,t6,-16
0x0000000000010930	274	{
=> 0x10930 <initialise_benchmark+4>:	sd	ra,0(t6)
0x0000000000010934	274	{
=> 0x10934 <initialise_benchmark+8>:	st	zero,0(t6)
0x0000000000010938	274	{
=> 0x10938 <initialise_benchmark+12>:	addi	sp,sp,-16
275	   in_m = 0xfae849273928f89fLL;             // Must be odd.
=> 0x1093c <initialise_benchmark+16>:	sd	ra,8(sp)
0x0000000000010940	275	   in_m = 0xfae849273928f89fLL;             // Must be odd.
=> 0x10940 <initialise_benchmark+20>:	sd	s0,0(sp)
0x0000000000010944	275	   in_m = 0xfae849273928f89fLL;             // Must be odd.
=> 0x10944 <initialise_benchmark+24>:	addi	s0,sp,16
0x0000000000010948	275	   in_m = 0xfae849273928f89fLL;             // Must be odd.
=> 0x10948 <initialise_benchmark+28>:	lui	a1,0xeba12
0x000000000001094c	275	   in_m = 0xfae849273928f89fLL;             // Must be odd.
=> 0x1094c <initialise_benchmark+32>:	addiw	a1,a1,1181
0x0000000000010950	275	   in_m = 0xfae849273928f89fLL;             // Must be odd.
=> 0x10950 <initialise_benchmark+36>:	slli	a1,a1,0xe
0x0000000000010954	275	   in_m = 0xfae849273928f89fLL;             // Must be odd.
=> 0x10954 <initialise_benchmark+40>:	addi	a1,a1,-1751
0x0000000000010958	275	   in_m = 0xfae849273928f89fLL;             // Must be odd.
=> 0x10958 <initialise_benchmark+44>:	slli	a1,a1,0x10
0x000000000001095c	275	   in_m = 0xfae849273928f89fLL;             // Must be odd.
=> 0x1095c <initialise_benchmark+48>:	addi	a1,a1,-1889
0x0000000000010960	275	   in_m = 0xfae849273928f89fLL;             // Must be odd.
=> 0x10960 <initialise_benchmark+52>:	sd	a1,1880(gp)
276	   in_b = 0x14736defb9330573LL;             // Must be smaller than m.
=> 0x10964 <initialise_benchmark+56>:	lui	a1,0x51cdb
0x0000000000010968	276	   in_b = 0x14736defb9330573LL;             // Must be smaller than m.
=> 0x10968 <initialise_benchmark+60>:	addiw	a1,a1,1983
0x000000000001096c	276	   in_b = 0x14736defb9330573LL;             // Must be smaller than m.
=> 0x1096c <initialise_benchmark+64>:	slli	a1,a1,0xe
0x0000000000010970	276	   in_b = 0x14736defb9330573LL;             // Must be smaller than m.
=> 0x10970 <initialise_benchmark+68>:	addi	a1,a1,-1741
0x0000000000010974	276	   in_b = 0x14736defb9330573LL;             // Must be smaller than m.
=> 0x10974 <initialise_benchmark+72>:	slli	a1,a1,0x10
0x0000000000010978	276	   in_b = 0x14736defb9330573LL;             // Must be smaller than m.
=> 0x10978 <initialise_benchmark+76>:	addi	a1,a1,1395
0x000000000001097c	276	   in_b = 0x14736defb9330573LL;             // Must be smaller than m.
=> 0x1097c <initialise_benchmark+80>:	sd	a1,1888(gp)
277	   in_a = 0x0549372187237fefLL;             // Must be smaller than m.
=> 0x10980 <initialise_benchmark+84>:	lui	a1,0x55
0x0000000000010984	277	   in_a = 0x0549372187237fefLL;             // Must be smaller than m.
=> 0x10984 <initialise_benchmark+88>:	addiw	a1,a1,-1737
0x0000000000010988	277	   in_a = 0x0549372187237fefLL;             // Must be smaller than m.
=> 0x10988 <initialise_benchmark+92>:	slli	a1,a1,0xd
0x000000000001098c	277	   in_a = 0x0549372187237fefLL;             // Must be smaller than m.
=> 0x1098c <initialise_benchmark+96>:	addi	a1,a1,1073
0x0000000000010990	277	   in_a = 0x0549372187237fefLL;             // Must be smaller than m.
=> 0x10990 <initialise_benchmark+100>:	slli	a1,a1,0xc
0x0000000000010994	277	   in_a = 0x0549372187237fefLL;             // Must be smaller than m.
=> 0x10994 <initialise_benchmark+104>:	addi	a1,a1,-441
0x0000000000010998	277	   in_a = 0x0549372187237fefLL;             // Must be smaller than m.
=> 0x10998 <initialise_benchmark+108>:	slli	a1,a1,0xf
0x000000000001099c	277	   in_a = 0x0549372187237fefLL;             // Must be smaller than m.
=> 0x1099c <initialise_benchmark+112>:	addi	a1,a1,-17
0x00000000000109a0	277	   in_a = 0x0549372187237fefLL;             // Must be smaller than m.
=> 0x109a0 <initialise_benchmark+116>:	sd	a1,1896(gp)
278	}
=> 0x109a4 <initialise_benchmark+120>:	ld	s0,0(sp)
0x00000000000109a8 in initialise_benchmark () at mont64.c:278
278	}
=> 0x109a8 <initialise_benchmark+124>:	ld	ra,8(sp)
0x00000000000109ac	278	}
=> 0x109ac <initialise_benchmark+128>:	addi	sp,sp,16
0x00000000000109b0	278	}
=> 0x109b0 <initialise_benchmark+132>:	ld	ra,0(t6)
0x00000000000109b4	278	}
=> 0x109b4 <initialise_benchmark+136>:	addi	t6,t6,16
0x00000000000109b8	278	}
=> 0x109b8 <initialise_benchmark+140>:	ret
main (argc=1, argv=0x3ffffffb68) at main.c:57
57	      result = benchmark ();
=> 0x10240 <main+176>:	sd	a0,-120(s0)
0x0000000000010244	57	      result = benchmark ();
=> 0x10244 <main+180>:	jal	ra,0x10734 <benchmark>
benchmark () at mont64.c:197
197	int benchmark() {
=> 0x10734 <benchmark>:	addi	t6,t6,-16
0x0000000000010738	197	int benchmark() {
=> 0x10738 <benchmark+4>:	sd	ra,0(t6)
0x000000000001073c	197	int benchmark() {
=> 0x1073c <benchmark+8>:	st	zero,0(t6)
0x0000000000010740	197	int benchmark() {
=> 0x10740 <benchmark+12>:	addi	sp,sp,-192
0x0000000000010744	197	int benchmark() {
=> 0x10744 <benchmark+16>:	sd	ra,184(sp)
0x0000000000010748	197	int benchmark() {
=> 0x10748 <benchmark+20>:	sd	s0,176(sp)
0x000000000001074c	197	int benchmark() {
=> 0x1074c <benchmark+24>:	addi	s0,sp,192
0x0000000000010750	197	int benchmark() {
=> 0x10750 <benchmark+28>:	li	a0,0
201	   int errors = 0;
=> 0x10754 <benchmark+32>:	sw	a0,-132(s0)
203	   m = in_m;             // Must be odd.
=> 0x10758 <benchmark+36>:	ld	a0,1880(gp)
0x000000000001075c	203	   m = in_m;             // Must be odd.
=> 0x1075c <benchmark+40>:	sd	a0,-40(s0)
204	   b = in_b;             // Must be smaller than m.
=> 0x10760 <benchmark+44>:	ld	a0,1888(gp)
0x0000000000010764	204	   b = in_b;             // Must be smaller than m.
=> 0x10764 <benchmark+48>:	sd	a0,-32(s0)
205	   a = in_a;             // Must be smaller than m.
=> 0x10768 <benchmark+52>:	ld	a0,1896(gp)
0x000000000001076c	205	   a = in_a;             // Must be smaller than m.
=> 0x1076c <benchmark+56>:	sd	a0,-24(s0)
210	   mulul64(a, b, &p1hi, &p1lo);         // Compute a*b (mod m).
=> 0x10770 <benchmark+60>:	ld	a0,-24(s0)
0x0000000000010774	210	   mulul64(a, b, &p1hi, &p1lo);         // Compute a*b (mod m).
=> 0x10774 <benchmark+64>:	ld	a1,-32(s0)
0x0000000000010778	210	   mulul64(a, b, &p1hi, &p1lo);         // Compute a*b (mod m).
=> 0x10778 <benchmark+68>:	addi	a2,s0,-56
0x000000000001077c	210	   mulul64(a, b, &p1hi, &p1lo);         // Compute a*b (mod m).
=> 0x1077c <benchmark+72>:	addi	a3,s0,-64
0x0000000000010780	210	   mulul64(a, b, &p1hi, &p1lo);         // Compute a*b (mod m).
=> 0x10780 <benchmark+76>:	sd	a2,-144(s0)
0x0000000000010784	210	   mulul64(a, b, &p1hi, &p1lo);         // Compute a*b (mod m).
=> 0x10784 <benchmark+80>:	sd	a3,-152(s0)
0x0000000000010788	210	   mulul64(a, b, &p1hi, &p1lo);         // Compute a*b (mod m).
=> 0x10788 <benchmark+84>:	jal	ra,0x1032c <mulul64>
mulul64 (u=380896260630216687, v=1473642379452024179, whi=0xfae849273928f89f, wlo=0x400000) at mont64.c:54
54	   {
=> 0x1032c <mulul64>:	addi	t6,t6,-16
0x0000000000010330	54	   {
=> 0x10330 <mulul64+4>:	sd	ra,0(t6)
0x0000000000010334	54	   {
=> 0x10334 <mulul64+8>:	st	zero,0(t6)
0x0000000000010338	54	   {
=> 0x10338 <mulul64+12>:	addi	sp,sp,-128
0x000000000001033c	54	   {
=> 0x1033c <mulul64+16>:	sd	ra,120(sp)
0x0000000000010340	54	   {
=> 0x10340 <mulul64+20>:	sd	s0,112(sp)
0x0000000000010344	54	   {
=> 0x10344 <mulul64+24>:	addi	s0,sp,128
0x0000000000010348	54	   {
=> 0x10348 <mulul64+28>:	sd	a0,-24(s0)
0x000000000001034c	54	   {
=> 0x1034c <mulul64+32>:	sd	a1,-32(s0)
0x0000000000010350	54	   {
=> 0x10350 <mulul64+36>:	sd	a2,-40(s0)
0x0000000000010354	54	   {
=> 0x10354 <mulul64+40>:	sd	a3,-48(s0)
58	   u1 = u >> 32; u0 = u & 0xFFFFFFFF;
=> 0x10358 <mulul64+44>:	lwu	a0,-20(s0)
0x000000000001035c	58	   u1 = u >> 32; u0 = u & 0xFFFFFFFF;
=> 0x1035c <mulul64+48>:	sd	a0,-64(s0)
0x0000000000010360	58	   u1 = u >> 32; u0 = u & 0xFFFFFFFF;
=> 0x10360 <mulul64+52>:	lwu	a0,-24(s0)
0x0000000000010364	58	   u1 = u >> 32; u0 = u & 0xFFFFFFFF;
=> 0x10364 <mulul64+56>:	sd	a0,-56(s0)
59	   v1 = v >> 32; v0 = v & 0xFFFFFFFF;
=> 0x10368 <mulul64+60>:	lwu	a0,-28(s0)
0x000000000001036c	59	   v1 = v >> 32; v0 = v & 0xFFFFFFFF;
=> 0x1036c <mulul64+64>:	sd	a0,-80(s0)
0x0000000000010370	59	   v1 = v >> 32; v0 = v & 0xFFFFFFFF;
=> 0x10370 <mulul64+68>:	lwu	a0,-32(s0)
0x0000000000010374	59	   v1 = v >> 32; v0 = v & 0xFFFFFFFF;
=> 0x10374 <mulul64+72>:	sd	a0,-72(s0)
61	   t = u0*v0;
=> 0x10378 <mulul64+76>:	ld	a0,-56(s0)
0x000000000001037c	61	   t = u0*v0;
=> 0x1037c <mulul64+80>:	ld	a1,-72(s0)
0x0000000000010380	61	   t = u0*v0;
=> 0x10380 <mulul64+84>:	mul	a0,a0,a1
0x0000000000010384	61	   t = u0*v0;
=> 0x10384 <mulul64+88>:	sd	a0,-96(s0)
62	   w0 = t & 0xFFFFFFFF;
=> 0x10388 <mulul64+92>:	lwu	a0,-96(s0)
0x000000000001038c	62	   w0 = t & 0xFFFFFFFF;
=> 0x1038c <mulul64+96>:	sd	a0,-104(s0)
63	   k = t >> 32;
=> 0x10390 <mulul64+100>:	lwu	a0,-92(s0)
0x0000000000010394	63	   k = t >> 32;
=> 0x10394 <mulul64+104>:	sd	a0,-88(s0)
65	   t = u1*v0 + k;
=> 0x10398 <mulul64+108>:	ld	a0,-64(s0)
0x000000000001039c	65	   t = u1*v0 + k;
=> 0x1039c <mulul64+112>:	ld	a1,-72(s0)
0x00000000000103a0	65	   t = u1*v0 + k;
=> 0x103a0 <mulul64+116>:	mul	a0,a0,a1
0x00000000000103a4	65	   t = u1*v0 + k;
=> 0x103a4 <mulul64+120>:	ld	a1,-88(s0)
0x00000000000103a8	65	   t = u1*v0 + k;
=> 0x103a8 <mulul64+124>:	add	a0,a0,a1
0x00000000000103ac	65	   t = u1*v0 + k;
=> 0x103ac <mulul64+128>:	sd	a0,-96(s0)
66	   w1 = t & 0xFFFFFFFF;
=> 0x103b0 <mulul64+132>:	lwu	a0,-96(s0)
0x00000000000103b4	66	   w1 = t & 0xFFFFFFFF;
=> 0x103b4 <mulul64+136>:	sd	a0,-112(s0)
67	   w2 = t >> 32;
=> 0x103b8 <mulul64+140>:	lwu	a0,-92(s0)
0x00000000000103bc	67	   w2 = t >> 32;
=> 0x103bc <mulul64+144>:	sd	a0,-120(s0)
69	   t = u0*v1 + w1;
=> 0x103c0 <mulul64+148>:	ld	a0,-56(s0)
0x00000000000103c4	69	   t = u0*v1 + w1;
=> 0x103c4 <mulul64+152>:	ld	a1,-80(s0)
0x00000000000103c8	69	   t = u0*v1 + w1;
=> 0x103c8 <mulul64+156>:	mul	a0,a0,a1
0x00000000000103cc	69	   t = u0*v1 + w1;
=> 0x103cc <mulul64+160>:	ld	a1,-112(s0)
0x00000000000103d0	69	   t = u0*v1 + w1;
=> 0x103d0 <mulul64+164>:	add	a0,a0,a1
0x00000000000103d4	69	   t = u0*v1 + w1;
=> 0x103d4 <mulul64+168>:	sd	a0,-96(s0)
70	   k = t >> 32;
=> 0x103d8 <mulul64+172>:	lwu	a0,-92(s0)
0x00000000000103dc	70	   k = t >> 32;
=> 0x103dc <mulul64+176>:	sd	a0,-88(s0)
72	   *wlo = (t << 32) + w0;
=> 0x103e0 <mulul64+180>:	ld	a0,-96(s0)
0x00000000000103e4	72	   *wlo = (t << 32) + w0;
=> 0x103e4 <mulul64+184>:	slli	a0,a0,0x20
0x00000000000103e8	72	   *wlo = (t << 32) + w0;
=> 0x103e8 <mulul64+188>:	ld	a1,-104(s0)
0x00000000000103ec	72	   *wlo = (t << 32) + w0;
=> 0x103ec <mulul64+192>:	add	a0,a0,a1
0x00000000000103f0	72	   *wlo = (t << 32) + w0;
=> 0x103f0 <mulul64+196>:	ld	a1,-48(s0)
0x00000000000103f4	72	   *wlo = (t << 32) + w0;
=> 0x103f4 <mulul64+200>:	sd	a0,0(a1)
73	   *whi = u1*v1 + w2 + k;
=> 0x103f8 <mulul64+204>:	ld	a0,-64(s0)
0x00000000000103fc	73	   *whi = u1*v1 + w2 + k;
=> 0x103fc <mulul64+208>:	ld	a1,-80(s0)
0x0000000000010400	73	   *whi = u1*v1 + w2 + k;
=> 0x10400 <mulul64+212>:	mul	a0,a0,a1
0x0000000000010404	73	   *whi = u1*v1 + w2 + k;
=> 0x10404 <mulul64+216>:	ld	a1,-120(s0)
0x0000000000010408	73	   *whi = u1*v1 + w2 + k;
=> 0x10408 <mulul64+220>:	add	a0,a0,a1
0x000000000001040c	73	   *whi = u1*v1 + w2 + k;
=> 0x1040c <mulul64+224>:	ld	a1,-88(s0)
0x0000000000010410	73	   *whi = u1*v1 + w2 + k;
=> 0x10410 <mulul64+228>:	add	a0,a0,a1
0x0000000000010414	73	   *whi = u1*v1 + w2 + k;
=> 0x10414 <mulul64+232>:	ld	a1,-40(s0)
0x0000000000010418	73	   *whi = u1*v1 + w2 + k;
=> 0x10418 <mulul64+236>:	sd	a0,0(a1)
75	   return;
=> 0x1041c <mulul64+240>:	ld	s0,112(sp)
0x0000000000010420 in mulul64 (u=380896260630216687, v=1473642379452024179, whi=0xfae849273928f89f, wlo=0x400000) at mont64.c:75
75	   return;
=> 0x10420 <mulul64+244>:	ld	ra,120(sp)
0x0000000000010424	75	   return;
=> 0x10424 <mulul64+248>:	addi	sp,sp,128
0x0000000000010428	75	   return;
=> 0x10428 <mulul64+252>:	ld	ra,0(t6)
0x000000000001042c	75	   return;
=> 0x1042c <mulul64+256>:	addi	t6,t6,16
0x0000000000010430	75	   return;
=> 0x10430 <mulul64+260>:	ret
benchmark () at mont64.c:211
211	   p1 = modul64(p1hi, p1lo, m);
=> 0x1078c <benchmark+88>:	ld	a0,-56(s0)
0x0000000000010790	211	   p1 = modul64(p1hi, p1lo, m);
=> 0x10790 <benchmark+92>:	ld	a1,-64(s0)
0x0000000000010794	211	   p1 = modul64(p1hi, p1lo, m);
=> 0x10794 <benchmark+96>:	ld	a2,-40(s0)
0x0000000000010798	211	   p1 = modul64(p1hi, p1lo, m);
=> 0x10798 <benchmark+100>:	jal	ra,0x10434 <modul64>
modul64 (x=380896260630216687, y=1473642379452024179, z=18079781136890394783) at mont64.c:80
80	uint64 modul64(uint64 x, uint64 y, uint64 z) {
=> 0x10434 <modul64>:	addi	t6,t6,-16
0x0000000000010438	80	uint64 modul64(uint64 x, uint64 y, uint64 z) {
=> 0x10438 <modul64+4>:	sd	ra,0(t6)
0x000000000001043c	80	uint64 modul64(uint64 x, uint64 y, uint64 z) {
=> 0x1043c <modul64+8>:	st	zero,0(t6)
0x0000000000010440	80	uint64 modul64(uint64 x, uint64 y, uint64 z) {
=> 0x10440 <modul64+12>:	addi	sp,sp,-64
0x0000000000010444	80	uint64 modul64(uint64 x, uint64 y, uint64 z) {
=> 0x10444 <modul64+16>:	sd	ra,56(sp)
0x0000000000010448	80	uint64 modul64(uint64 x, uint64 y, uint64 z) {
=> 0x10448 <modul64+20>:	sd	s0,48(sp)
0x000000000001044c	80	uint64 modul64(uint64 x, uint64 y, uint64 z) {
=> 0x1044c <modul64+24>:	addi	s0,sp,64
0x0000000000010450	80	uint64 modul64(uint64 x, uint64 y, uint64 z) {
=> 0x10450 <modul64+28>:	sd	a0,-24(s0)
0x0000000000010454	80	uint64 modul64(uint64 x, uint64 y, uint64 z) {
=> 0x10454 <modul64+32>:	sd	a1,-32(s0)
0x0000000000010458	80	uint64 modul64(uint64 x, uint64 y, uint64 z) {
=> 0x10458 <modul64+36>:	sd	a2,-40(s0)
0x000000000001045c	80	uint64 modul64(uint64 x, uint64 y, uint64 z) {
=> 0x1045c <modul64+40>:	li	a0,1
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10460 <modul64+44>:	sd	a0,-48(s0)
0x0000000000010464	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10464 <modul64+48>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
98	   return x;                    // Quotient is y.
=> 0x104f4 <modul64+192>:	ld	a0,-24(s0)
0x00000000000104f8	98	   return x;                    // Quotient is y.
=> 0x104f8 <modul64+196>:	ld	s0,48(sp)
0x00000000000104fc in modul64 (x=380896260630216687, y=1473642379452024179, z=18079781136890394783) at mont64.c:98
98	   return x;                    // Quotient is y.
=> 0x104fc <modul64+200>:	ld	ra,56(sp)
0x0000000000010500	98	   return x;                    // Quotient is y.
=> 0x10500 <modul64+204>:	addi	sp,sp,64
0x0000000000010504	98	   return x;                    // Quotient is y.
=> 0x10504 <modul64+208>:	ld	ra,0(t6)
0x0000000000010508	98	   return x;                    // Quotient is y.
=> 0x10508 <modul64+212>:	addi	t6,t6,16
0x000000000001050c	98	   return x;                    // Quotient is y.
=> 0x1050c <modul64+216>:	ret
0x000000000001079c in benchmark () at mont64.c:211
211	   p1 = modul64(p1hi, p1lo, m);
=> 0x1079c <benchmark+104>:	sd	a0,-72(s0)
212	   mulul64(p1, p1, &p1hi, &p1lo);       // Compute (a*b)**2 (mod m).
=> 0x107a0 <benchmark+108>:	ld	a0,-72(s0)
0x00000000000107a4	212	   mulul64(p1, p1, &p1hi, &p1lo);       // Compute (a*b)**2 (mod m).
=> 0x107a4 <benchmark+112>:	sd	a0,-160(s0)
0x00000000000107a8	212	   mulul64(p1, p1, &p1hi, &p1lo);       // Compute (a*b)**2 (mod m).
=> 0x107a8 <benchmark+116>:	ld	a1,-160(s0)
0x00000000000107ac	212	   mulul64(p1, p1, &p1hi, &p1lo);       // Compute (a*b)**2 (mod m).
=> 0x107ac <benchmark+120>:	ld	a2,-144(s0)
0x00000000000107b0	212	   mulul64(p1, p1, &p1hi, &p1lo);       // Compute (a*b)**2 (mod m).
=> 0x107b0 <benchmark+124>:	ld	a3,-152(s0)
0x00000000000107b4	212	   mulul64(p1, p1, &p1hi, &p1lo);       // Compute (a*b)**2 (mod m).
=> 0x107b4 <benchmark+128>:	jal	ra,0x1032c <mulul64>
mulul64 (u=380896260630216687, v=1473642379452024179, whi=0xfae849273928f89f, wlo=0x400000) at mont64.c:54
54	   {
=> 0x1032c <mulul64>:	addi	t6,t6,-16
0x0000000000010330	54	   {
=> 0x10330 <mulul64+4>:	sd	ra,0(t6)
0x0000000000010334	54	   {
=> 0x10334 <mulul64+8>:	st	zero,0(t6)
0x0000000000010338	54	   {
=> 0x10338 <mulul64+12>:	addi	sp,sp,-128
0x000000000001033c	54	   {
=> 0x1033c <mulul64+16>:	sd	ra,120(sp)
0x0000000000010340	54	   {
=> 0x10340 <mulul64+20>:	sd	s0,112(sp)
0x0000000000010344	54	   {
=> 0x10344 <mulul64+24>:	addi	s0,sp,128
0x0000000000010348	54	   {
=> 0x10348 <mulul64+28>:	sd	a0,-24(s0)
0x000000000001034c	54	   {
=> 0x1034c <mulul64+32>:	sd	a1,-32(s0)
0x0000000000010350	54	   {
=> 0x10350 <mulul64+36>:	sd	a2,-40(s0)
0x0000000000010354	54	   {
=> 0x10354 <mulul64+40>:	sd	a3,-48(s0)
58	   u1 = u >> 32; u0 = u & 0xFFFFFFFF;
=> 0x10358 <mulul64+44>:	lwu	a0,-20(s0)
0x000000000001035c	58	   u1 = u >> 32; u0 = u & 0xFFFFFFFF;
=> 0x1035c <mulul64+48>:	sd	a0,-64(s0)
0x0000000000010360	58	   u1 = u >> 32; u0 = u & 0xFFFFFFFF;
=> 0x10360 <mulul64+52>:	lwu	a0,-24(s0)
0x0000000000010364	58	   u1 = u >> 32; u0 = u & 0xFFFFFFFF;
=> 0x10364 <mulul64+56>:	sd	a0,-56(s0)
59	   v1 = v >> 32; v0 = v & 0xFFFFFFFF;
=> 0x10368 <mulul64+60>:	lwu	a0,-28(s0)
0x000000000001036c	59	   v1 = v >> 32; v0 = v & 0xFFFFFFFF;
=> 0x1036c <mulul64+64>:	sd	a0,-80(s0)
0x0000000000010370	59	   v1 = v >> 32; v0 = v & 0xFFFFFFFF;
=> 0x10370 <mulul64+68>:	lwu	a0,-32(s0)
0x0000000000010374	59	   v1 = v >> 32; v0 = v & 0xFFFFFFFF;
=> 0x10374 <mulul64+72>:	sd	a0,-72(s0)
61	   t = u0*v0;
=> 0x10378 <mulul64+76>:	ld	a0,-56(s0)
0x000000000001037c	61	   t = u0*v0;
=> 0x1037c <mulul64+80>:	ld	a1,-72(s0)
0x0000000000010380	61	   t = u0*v0;
=> 0x10380 <mulul64+84>:	mul	a0,a0,a1
0x0000000000010384	61	   t = u0*v0;
=> 0x10384 <mulul64+88>:	sd	a0,-96(s0)
62	   w0 = t & 0xFFFFFFFF;
=> 0x10388 <mulul64+92>:	lwu	a0,-96(s0)
0x000000000001038c	62	   w0 = t & 0xFFFFFFFF;
=> 0x1038c <mulul64+96>:	sd	a0,-104(s0)
63	   k = t >> 32;
=> 0x10390 <mulul64+100>:	lwu	a0,-92(s0)
0x0000000000010394	63	   k = t >> 32;
=> 0x10394 <mulul64+104>:	sd	a0,-88(s0)
65	   t = u1*v0 + k;
=> 0x10398 <mulul64+108>:	ld	a0,-64(s0)
0x000000000001039c	65	   t = u1*v0 + k;
=> 0x1039c <mulul64+112>:	ld	a1,-72(s0)
0x00000000000103a0	65	   t = u1*v0 + k;
=> 0x103a0 <mulul64+116>:	mul	a0,a0,a1
0x00000000000103a4	65	   t = u1*v0 + k;
=> 0x103a4 <mulul64+120>:	ld	a1,-88(s0)
0x00000000000103a8	65	   t = u1*v0 + k;
=> 0x103a8 <mulul64+124>:	add	a0,a0,a1
0x00000000000103ac	65	   t = u1*v0 + k;
=> 0x103ac <mulul64+128>:	sd	a0,-96(s0)
66	   w1 = t & 0xFFFFFFFF;
=> 0x103b0 <mulul64+132>:	lwu	a0,-96(s0)
0x00000000000103b4	66	   w1 = t & 0xFFFFFFFF;
=> 0x103b4 <mulul64+136>:	sd	a0,-112(s0)
67	   w2 = t >> 32;
=> 0x103b8 <mulul64+140>:	lwu	a0,-92(s0)
0x00000000000103bc	67	   w2 = t >> 32;
=> 0x103bc <mulul64+144>:	sd	a0,-120(s0)
69	   t = u0*v1 + w1;
=> 0x103c0 <mulul64+148>:	ld	a0,-56(s0)
0x00000000000103c4	69	   t = u0*v1 + w1;
=> 0x103c4 <mulul64+152>:	ld	a1,-80(s0)
0x00000000000103c8	69	   t = u0*v1 + w1;
=> 0x103c8 <mulul64+156>:	mul	a0,a0,a1
0x00000000000103cc	69	   t = u0*v1 + w1;
=> 0x103cc <mulul64+160>:	ld	a1,-112(s0)
0x00000000000103d0	69	   t = u0*v1 + w1;
=> 0x103d0 <mulul64+164>:	add	a0,a0,a1
0x00000000000103d4	69	   t = u0*v1 + w1;
=> 0x103d4 <mulul64+168>:	sd	a0,-96(s0)
70	   k = t >> 32;
=> 0x103d8 <mulul64+172>:	lwu	a0,-92(s0)
0x00000000000103dc	70	   k = t >> 32;
=> 0x103dc <mulul64+176>:	sd	a0,-88(s0)
72	   *wlo = (t << 32) + w0;
=> 0x103e0 <mulul64+180>:	ld	a0,-96(s0)
0x00000000000103e4	72	   *wlo = (t << 32) + w0;
=> 0x103e4 <mulul64+184>:	slli	a0,a0,0x20
0x00000000000103e8	72	   *wlo = (t << 32) + w0;
=> 0x103e8 <mulul64+188>:	ld	a1,-104(s0)
0x00000000000103ec	72	   *wlo = (t << 32) + w0;
=> 0x103ec <mulul64+192>:	add	a0,a0,a1
0x00000000000103f0	72	   *wlo = (t << 32) + w0;
=> 0x103f0 <mulul64+196>:	ld	a1,-48(s0)
0x00000000000103f4	72	   *wlo = (t << 32) + w0;
=> 0x103f4 <mulul64+200>:	sd	a0,0(a1)
73	   *whi = u1*v1 + w2 + k;
=> 0x103f8 <mulul64+204>:	ld	a0,-64(s0)
0x00000000000103fc	73	   *whi = u1*v1 + w2 + k;
=> 0x103fc <mulul64+208>:	ld	a1,-80(s0)
0x0000000000010400	73	   *whi = u1*v1 + w2 + k;
=> 0x10400 <mulul64+212>:	mul	a0,a0,a1
0x0000000000010404	73	   *whi = u1*v1 + w2 + k;
=> 0x10404 <mulul64+216>:	ld	a1,-120(s0)
0x0000000000010408	73	   *whi = u1*v1 + w2 + k;
=> 0x10408 <mulul64+220>:	add	a0,a0,a1
0x000000000001040c	73	   *whi = u1*v1 + w2 + k;
=> 0x1040c <mulul64+224>:	ld	a1,-88(s0)
0x0000000000010410	73	   *whi = u1*v1 + w2 + k;
=> 0x10410 <mulul64+228>:	add	a0,a0,a1
0x0000000000010414	73	   *whi = u1*v1 + w2 + k;
=> 0x10414 <mulul64+232>:	ld	a1,-40(s0)
0x0000000000010418	73	   *whi = u1*v1 + w2 + k;
=> 0x10418 <mulul64+236>:	sd	a0,0(a1)
75	   return;
=> 0x1041c <mulul64+240>:	ld	s0,112(sp)
0x0000000000010420 in mulul64 (u=380896260630216687, v=1473642379452024179, whi=0xfae849273928f89f, wlo=0x400000) at mont64.c:75
75	   return;
=> 0x10420 <mulul64+244>:	ld	ra,120(sp)
0x0000000000010424	75	   return;
=> 0x10424 <mulul64+248>:	addi	sp,sp,128
0x0000000000010428	75	   return;
=> 0x10428 <mulul64+252>:	ld	ra,0(t6)
0x000000000001042c	75	   return;
=> 0x1042c <mulul64+256>:	addi	t6,t6,16
0x0000000000010430	75	   return;
=> 0x10430 <mulul64+260>:	ret
benchmark () at mont64.c:213
213	   p1 = modul64(p1hi, p1lo, m);
=> 0x107b8 <benchmark+132>:	ld	a0,-56(s0)
0x00000000000107bc	213	   p1 = modul64(p1hi, p1lo, m);
=> 0x107bc <benchmark+136>:	ld	a1,-64(s0)
0x00000000000107c0	213	   p1 = modul64(p1hi, p1lo, m);
=> 0x107c0 <benchmark+140>:	ld	a2,-40(s0)
0x00000000000107c4	213	   p1 = modul64(p1hi, p1lo, m);
=> 0x107c4 <benchmark+144>:	jal	ra,0x10434 <modul64>
modul64 (x=380896260630216687, y=1473642379452024179, z=18079781136890394783) at mont64.c:80
80	uint64 modul64(uint64 x, uint64 y, uint64 z) {
=> 0x10434 <modul64>:	addi	t6,t6,-16
0x0000000000010438	80	uint64 modul64(uint64 x, uint64 y, uint64 z) {
=> 0x10438 <modul64+4>:	sd	ra,0(t6)
0x000000000001043c	80	uint64 modul64(uint64 x, uint64 y, uint64 z) {
=> 0x1043c <modul64+8>:	st	zero,0(t6)
0x0000000000010440	80	uint64 modul64(uint64 x, uint64 y, uint64 z) {
=> 0x10440 <modul64+12>:	addi	sp,sp,-64
0x0000000000010444	80	uint64 modul64(uint64 x, uint64 y, uint64 z) {
=> 0x10444 <modul64+16>:	sd	ra,56(sp)
0x0000000000010448	80	uint64 modul64(uint64 x, uint64 y, uint64 z) {
=> 0x10448 <modul64+20>:	sd	s0,48(sp)
0x000000000001044c	80	uint64 modul64(uint64 x, uint64 y, uint64 z) {
=> 0x1044c <modul64+24>:	addi	s0,sp,64
0x0000000000010450	80	uint64 modul64(uint64 x, uint64 y, uint64 z) {
=> 0x10450 <modul64+28>:	sd	a0,-24(s0)
0x0000000000010454	80	uint64 modul64(uint64 x, uint64 y, uint64 z) {
=> 0x10454 <modul64+32>:	sd	a1,-32(s0)
0x0000000000010458	80	uint64 modul64(uint64 x, uint64 y, uint64 z) {
=> 0x10458 <modul64+36>:	sd	a2,-40(s0)
0x000000000001045c	80	uint64 modul64(uint64 x, uint64 y, uint64 z) {
=> 0x1045c <modul64+40>:	li	a0,1
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10460 <modul64+44>:	sd	a0,-48(s0)
0x0000000000010464	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10464 <modul64+48>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
98	   return x;                    // Quotient is y.
=> 0x104f4 <modul64+192>:	ld	a0,-24(s0)
0x00000000000104f8	98	   return x;                    // Quotient is y.
=> 0x104f8 <modul64+196>:	ld	s0,48(sp)
0x00000000000104fc in modul64 (x=380896260630216687, y=1473642379452024179, z=18079781136890394783) at mont64.c:98
98	   return x;                    // Quotient is y.
=> 0x104fc <modul64+200>:	ld	ra,56(sp)
0x0000000000010500	98	   return x;                    // Quotient is y.
=> 0x10500 <modul64+204>:	addi	sp,sp,64
0x0000000000010504	98	   return x;                    // Quotient is y.
=> 0x10504 <modul64+208>:	ld	ra,0(t6)
0x0000000000010508	98	   return x;                    // Quotient is y.
=> 0x10508 <modul64+212>:	addi	t6,t6,16
0x000000000001050c	98	   return x;                    // Quotient is y.
=> 0x1050c <modul64+216>:	ret
0x00000000000107c8 in benchmark () at mont64.c:213
213	   p1 = modul64(p1hi, p1lo, m);
=> 0x107c8 <benchmark+148>:	sd	a0,-72(s0)
214	   mulul64(p1, p1, &p1hi, &p1lo);       // Compute (a*b)**4 (mod m).
=> 0x107cc <benchmark+152>:	ld	a0,-72(s0)
0x00000000000107d0	214	   mulul64(p1, p1, &p1hi, &p1lo);       // Compute (a*b)**4 (mod m).
=> 0x107d0 <benchmark+156>:	sd	a0,-168(s0)
0x00000000000107d4	214	   mulul64(p1, p1, &p1hi, &p1lo);       // Compute (a*b)**4 (mod m).
=> 0x107d4 <benchmark+160>:	ld	a1,-168(s0)
0x00000000000107d8	214	   mulul64(p1, p1, &p1hi, &p1lo);       // Compute (a*b)**4 (mod m).
=> 0x107d8 <benchmark+164>:	ld	a2,-144(s0)
0x00000000000107dc	214	   mulul64(p1, p1, &p1hi, &p1lo);       // Compute (a*b)**4 (mod m).
=> 0x107dc <benchmark+168>:	ld	a3,-152(s0)
0x00000000000107e0	214	   mulul64(p1, p1, &p1hi, &p1lo);       // Compute (a*b)**4 (mod m).
=> 0x107e0 <benchmark+172>:	jal	ra,0x1032c <mulul64>
mulul64 (u=380896260630216687, v=1473642379452024179, whi=0xfae849273928f89f, wlo=0x400000) at mont64.c:54
54	   {
=> 0x1032c <mulul64>:	addi	t6,t6,-16
0x0000000000010330	54	   {
=> 0x10330 <mulul64+4>:	sd	ra,0(t6)
0x0000000000010334	54	   {
=> 0x10334 <mulul64+8>:	st	zero,0(t6)
0x0000000000010338	54	   {
=> 0x10338 <mulul64+12>:	addi	sp,sp,-128
0x000000000001033c	54	   {
=> 0x1033c <mulul64+16>:	sd	ra,120(sp)
0x0000000000010340	54	   {
=> 0x10340 <mulul64+20>:	sd	s0,112(sp)
0x0000000000010344	54	   {
=> 0x10344 <mulul64+24>:	addi	s0,sp,128
0x0000000000010348	54	   {
=> 0x10348 <mulul64+28>:	sd	a0,-24(s0)
0x000000000001034c	54	   {
=> 0x1034c <mulul64+32>:	sd	a1,-32(s0)
0x0000000000010350	54	   {
=> 0x10350 <mulul64+36>:	sd	a2,-40(s0)
0x0000000000010354	54	   {
=> 0x10354 <mulul64+40>:	sd	a3,-48(s0)
58	   u1 = u >> 32; u0 = u & 0xFFFFFFFF;
=> 0x10358 <mulul64+44>:	lwu	a0,-20(s0)
0x000000000001035c	58	   u1 = u >> 32; u0 = u & 0xFFFFFFFF;
=> 0x1035c <mulul64+48>:	sd	a0,-64(s0)
0x0000000000010360	58	   u1 = u >> 32; u0 = u & 0xFFFFFFFF;
=> 0x10360 <mulul64+52>:	lwu	a0,-24(s0)
0x0000000000010364	58	   u1 = u >> 32; u0 = u & 0xFFFFFFFF;
=> 0x10364 <mulul64+56>:	sd	a0,-56(s0)
59	   v1 = v >> 32; v0 = v & 0xFFFFFFFF;
=> 0x10368 <mulul64+60>:	lwu	a0,-28(s0)
0x000000000001036c	59	   v1 = v >> 32; v0 = v & 0xFFFFFFFF;
=> 0x1036c <mulul64+64>:	sd	a0,-80(s0)
0x0000000000010370	59	   v1 = v >> 32; v0 = v & 0xFFFFFFFF;
=> 0x10370 <mulul64+68>:	lwu	a0,-32(s0)
0x0000000000010374	59	   v1 = v >> 32; v0 = v & 0xFFFFFFFF;
=> 0x10374 <mulul64+72>:	sd	a0,-72(s0)
61	   t = u0*v0;
=> 0x10378 <mulul64+76>:	ld	a0,-56(s0)
0x000000000001037c	61	   t = u0*v0;
=> 0x1037c <mulul64+80>:	ld	a1,-72(s0)
0x0000000000010380	61	   t = u0*v0;
=> 0x10380 <mulul64+84>:	mul	a0,a0,a1
0x0000000000010384	61	   t = u0*v0;
=> 0x10384 <mulul64+88>:	sd	a0,-96(s0)
62	   w0 = t & 0xFFFFFFFF;
=> 0x10388 <mulul64+92>:	lwu	a0,-96(s0)
0x000000000001038c	62	   w0 = t & 0xFFFFFFFF;
=> 0x1038c <mulul64+96>:	sd	a0,-104(s0)
63	   k = t >> 32;
=> 0x10390 <mulul64+100>:	lwu	a0,-92(s0)
0x0000000000010394	63	   k = t >> 32;
=> 0x10394 <mulul64+104>:	sd	a0,-88(s0)
65	   t = u1*v0 + k;
=> 0x10398 <mulul64+108>:	ld	a0,-64(s0)
0x000000000001039c	65	   t = u1*v0 + k;
=> 0x1039c <mulul64+112>:	ld	a1,-72(s0)
0x00000000000103a0	65	   t = u1*v0 + k;
=> 0x103a0 <mulul64+116>:	mul	a0,a0,a1
0x00000000000103a4	65	   t = u1*v0 + k;
=> 0x103a4 <mulul64+120>:	ld	a1,-88(s0)
0x00000000000103a8	65	   t = u1*v0 + k;
=> 0x103a8 <mulul64+124>:	add	a0,a0,a1
0x00000000000103ac	65	   t = u1*v0 + k;
=> 0x103ac <mulul64+128>:	sd	a0,-96(s0)
66	   w1 = t & 0xFFFFFFFF;
=> 0x103b0 <mulul64+132>:	lwu	a0,-96(s0)
0x00000000000103b4	66	   w1 = t & 0xFFFFFFFF;
=> 0x103b4 <mulul64+136>:	sd	a0,-112(s0)
67	   w2 = t >> 32;
=> 0x103b8 <mulul64+140>:	lwu	a0,-92(s0)
0x00000000000103bc	67	   w2 = t >> 32;
=> 0x103bc <mulul64+144>:	sd	a0,-120(s0)
69	   t = u0*v1 + w1;
=> 0x103c0 <mulul64+148>:	ld	a0,-56(s0)
0x00000000000103c4	69	   t = u0*v1 + w1;
=> 0x103c4 <mulul64+152>:	ld	a1,-80(s0)
0x00000000000103c8	69	   t = u0*v1 + w1;
=> 0x103c8 <mulul64+156>:	mul	a0,a0,a1
0x00000000000103cc	69	   t = u0*v1 + w1;
=> 0x103cc <mulul64+160>:	ld	a1,-112(s0)
0x00000000000103d0	69	   t = u0*v1 + w1;
=> 0x103d0 <mulul64+164>:	add	a0,a0,a1
0x00000000000103d4	69	   t = u0*v1 + w1;
=> 0x103d4 <mulul64+168>:	sd	a0,-96(s0)
70	   k = t >> 32;
=> 0x103d8 <mulul64+172>:	lwu	a0,-92(s0)
0x00000000000103dc	70	   k = t >> 32;
=> 0x103dc <mulul64+176>:	sd	a0,-88(s0)
72	   *wlo = (t << 32) + w0;
=> 0x103e0 <mulul64+180>:	ld	a0,-96(s0)
0x00000000000103e4	72	   *wlo = (t << 32) + w0;
=> 0x103e4 <mulul64+184>:	slli	a0,a0,0x20
0x00000000000103e8	72	   *wlo = (t << 32) + w0;
=> 0x103e8 <mulul64+188>:	ld	a1,-104(s0)
0x00000000000103ec	72	   *wlo = (t << 32) + w0;
=> 0x103ec <mulul64+192>:	add	a0,a0,a1
0x00000000000103f0	72	   *wlo = (t << 32) + w0;
=> 0x103f0 <mulul64+196>:	ld	a1,-48(s0)
0x00000000000103f4	72	   *wlo = (t << 32) + w0;
=> 0x103f4 <mulul64+200>:	sd	a0,0(a1)
73	   *whi = u1*v1 + w2 + k;
=> 0x103f8 <mulul64+204>:	ld	a0,-64(s0)
0x00000000000103fc	73	   *whi = u1*v1 + w2 + k;
=> 0x103fc <mulul64+208>:	ld	a1,-80(s0)
0x0000000000010400	73	   *whi = u1*v1 + w2 + k;
=> 0x10400 <mulul64+212>:	mul	a0,a0,a1
0x0000000000010404	73	   *whi = u1*v1 + w2 + k;
=> 0x10404 <mulul64+216>:	ld	a1,-120(s0)
0x0000000000010408	73	   *whi = u1*v1 + w2 + k;
=> 0x10408 <mulul64+220>:	add	a0,a0,a1
0x000000000001040c	73	   *whi = u1*v1 + w2 + k;
=> 0x1040c <mulul64+224>:	ld	a1,-88(s0)
0x0000000000010410	73	   *whi = u1*v1 + w2 + k;
=> 0x10410 <mulul64+228>:	add	a0,a0,a1
0x0000000000010414	73	   *whi = u1*v1 + w2 + k;
=> 0x10414 <mulul64+232>:	ld	a1,-40(s0)
0x0000000000010418	73	   *whi = u1*v1 + w2 + k;
=> 0x10418 <mulul64+236>:	sd	a0,0(a1)
75	   return;
=> 0x1041c <mulul64+240>:	ld	s0,112(sp)
0x0000000000010420 in mulul64 (u=380896260630216687, v=1473642379452024179, whi=0xfae849273928f89f, wlo=0x400000) at mont64.c:75
75	   return;
=> 0x10420 <mulul64+244>:	ld	ra,120(sp)
0x0000000000010424	75	   return;
=> 0x10424 <mulul64+248>:	addi	sp,sp,128
0x0000000000010428	75	   return;
=> 0x10428 <mulul64+252>:	ld	ra,0(t6)
0x000000000001042c	75	   return;
=> 0x1042c <mulul64+256>:	addi	t6,t6,16
0x0000000000010430	75	   return;
=> 0x10430 <mulul64+260>:	ret
benchmark () at mont64.c:215
215	   p1 = modul64(p1hi, p1lo, m);
=> 0x107e4 <benchmark+176>:	ld	a0,-56(s0)
0x00000000000107e8	215	   p1 = modul64(p1hi, p1lo, m);
=> 0x107e8 <benchmark+180>:	ld	a1,-64(s0)
0x00000000000107ec	215	   p1 = modul64(p1hi, p1lo, m);
=> 0x107ec <benchmark+184>:	ld	a2,-40(s0)
0x00000000000107f0	215	   p1 = modul64(p1hi, p1lo, m);
=> 0x107f0 <benchmark+188>:	jal	ra,0x10434 <modul64>
modul64 (x=380896260630216687, y=1473642379452024179, z=18079781136890394783) at mont64.c:80
80	uint64 modul64(uint64 x, uint64 y, uint64 z) {
=> 0x10434 <modul64>:	addi	t6,t6,-16
0x0000000000010438	80	uint64 modul64(uint64 x, uint64 y, uint64 z) {
=> 0x10438 <modul64+4>:	sd	ra,0(t6)
0x000000000001043c	80	uint64 modul64(uint64 x, uint64 y, uint64 z) {
=> 0x1043c <modul64+8>:	st	zero,0(t6)
0x0000000000010440	80	uint64 modul64(uint64 x, uint64 y, uint64 z) {
=> 0x10440 <modul64+12>:	addi	sp,sp,-64
0x0000000000010444	80	uint64 modul64(uint64 x, uint64 y, uint64 z) {
=> 0x10444 <modul64+16>:	sd	ra,56(sp)
0x0000000000010448	80	uint64 modul64(uint64 x, uint64 y, uint64 z) {
=> 0x10448 <modul64+20>:	sd	s0,48(sp)
0x000000000001044c	80	uint64 modul64(uint64 x, uint64 y, uint64 z) {
=> 0x1044c <modul64+24>:	addi	s0,sp,64
0x0000000000010450	80	uint64 modul64(uint64 x, uint64 y, uint64 z) {
=> 0x10450 <modul64+28>:	sd	a0,-24(s0)
0x0000000000010454	80	uint64 modul64(uint64 x, uint64 y, uint64 z) {
=> 0x10454 <modul64+32>:	sd	a1,-32(s0)
0x0000000000010458	80	uint64 modul64(uint64 x, uint64 y, uint64 z) {
=> 0x10458 <modul64+36>:	sd	a2,-40(s0)
0x000000000001045c	80	uint64 modul64(uint64 x, uint64 y, uint64 z) {
=> 0x1045c <modul64+40>:	li	a0,1
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10460 <modul64+44>:	sd	a0,-48(s0)
0x0000000000010464	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10464 <modul64+48>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
98	   return x;                    // Quotient is y.
=> 0x104f4 <modul64+192>:	ld	a0,-24(s0)
0x00000000000104f8	98	   return x;                    // Quotient is y.
=> 0x104f8 <modul64+196>:	ld	s0,48(sp)
0x00000000000104fc in modul64 (x=380896260630216687, y=1473642379452024179, z=18079781136890394783) at mont64.c:98
98	   return x;                    // Quotient is y.
=> 0x104fc <modul64+200>:	ld	ra,56(sp)
0x0000000000010500	98	   return x;                    // Quotient is y.
=> 0x10500 <modul64+204>:	addi	sp,sp,64
0x0000000000010504	98	   return x;                    // Quotient is y.
=> 0x10504 <modul64+208>:	ld	ra,0(t6)
0x0000000000010508	98	   return x;                    // Quotient is y.
=> 0x10508 <modul64+212>:	addi	t6,t6,16
0x000000000001050c	98	   return x;                    // Quotient is y.
=> 0x1050c <modul64+216>:	ret
0x00000000000107f4 in benchmark () at mont64.c:215
215	   p1 = modul64(p1hi, p1lo, m);
=> 0x107f4 <benchmark+192>:	sd	a0,-72(s0)
0x00000000000107f8	215	   p1 = modul64(p1hi, p1lo, m);
=> 0x107f8 <benchmark+196>:	li	a0,-1
0x00000000000107fc	215	   p1 = modul64(p1hi, p1lo, m);
=> 0x107fc <benchmark+200>:	slli	a0,a0,0x3f
227	   hr = 0x8000000000000000LL;
=> 0x10800 <benchmark+204>:	sd	a0,-48(s0)
243	   xbinGCD(hr, m, &rinv, &mprime);      // xbinGCD, in effect, doubles hr.
=> 0x10804 <benchmark+208>:	ld	a0,-48(s0)
0x0000000000010808	243	   xbinGCD(hr, m, &rinv, &mprime);      // xbinGCD, in effect, doubles hr.
=> 0x10808 <benchmark+212>:	ld	a1,-40(s0)
0x000000000001080c	243	   xbinGCD(hr, m, &rinv, &mprime);      // xbinGCD, in effect, doubles hr.
=> 0x1080c <benchmark+216>:	addi	a2,s0,-120
0x0000000000010810	243	   xbinGCD(hr, m, &rinv, &mprime);      // xbinGCD, in effect, doubles hr.
=> 0x10810 <benchmark+220>:	addi	a3,s0,-128
0x0000000000010814	243	   xbinGCD(hr, m, &rinv, &mprime);      // xbinGCD, in effect, doubles hr.
=> 0x10814 <benchmark+224>:	jal	ra,0x10634 <xbinGCD>
xbinGCD (a=380896260630216687, b=1473642379452024179, pu=0xfae849273928f89f, pv=0x8000000000000000) at mont64.c:163
163	   {
=> 0x10634 <xbinGCD>:	addi	t6,t6,-16
0x0000000000010638	163	   {
=> 0x10638 <xbinGCD+4>:	sd	ra,0(t6)
0x000000000001063c	163	   {
=> 0x1063c <xbinGCD+8>:	st	zero,0(t6)
0x0000000000010640	163	   {
=> 0x10640 <xbinGCD+12>:	addi	sp,sp,-80
0x0000000000010644	163	   {
=> 0x10644 <xbinGCD+16>:	sd	ra,72(sp)
0x0000000000010648	163	   {
=> 0x10648 <xbinGCD+20>:	sd	s0,64(sp)
0x000000000001064c	163	   {
=> 0x1064c <xbinGCD+24>:	addi	s0,sp,80
0x0000000000010650	163	   {
=> 0x10650 <xbinGCD+28>:	sd	a0,-24(s0)
0x0000000000010654	163	   {
=> 0x10654 <xbinGCD+32>:	sd	a1,-32(s0)
0x0000000000010658	163	   {
=> 0x10658 <xbinGCD+36>:	sd	a2,-40(s0)
0x000000000001065c	163	   {
=> 0x1065c <xbinGCD+40>:	sd	a3,-48(s0)
0x0000000000010660	163	   {
=> 0x10660 <xbinGCD+44>:	li	a0,1
166	   u = 1; v = 0;
=> 0x10664 <xbinGCD+48>:	sd	a0,-72(s0)
0x0000000000010668	166	   u = 1; v = 0;
=> 0x10668 <xbinGCD+52>:	li	a0,0
0x000000000001066c	166	   u = 1; v = 0;
=> 0x1066c <xbinGCD+56>:	sd	a0,-80(s0)
167	   alpha = a; beta = b;         // Note that alpha is
=> 0x10670 <xbinGCD+60>:	ld	a0,-24(s0)
0x0000000000010674	167	   alpha = a; beta = b;         // Note that alpha is
=> 0x10674 <xbinGCD+64>:	sd	a0,-56(s0)
0x0000000000010678	167	   alpha = a; beta = b;         // Note that alpha is
=> 0x10678 <xbinGCD+68>:	ld	a0,-32(s0)
0x000000000001067c	167	   alpha = a; beta = b;         // Note that alpha is
=> 0x1067c <xbinGCD+72>:	sd	a0,-64(s0)
174	   while (a > 0) {
=> 0x10680 <xbinGCD+76>:	j	0x10684 <xbinGCD+80>
0x0000000000010684	174	   while (a > 0) {
=> 0x10684 <xbinGCD+80>:	ld	a0,-24(s0)
0x0000000000010688	174	   while (a > 0) {
=> 0x10688 <xbinGCD+84>:	li	a1,0
0x000000000001068c	174	   while (a > 0) {
=> 0x1068c <xbinGCD+88>:	beq	a0,a1,0x10704 <xbinGCD+208>
0x0000000000010690	174	   while (a > 0) {
=> 0x10690 <xbinGCD+92>:	j	0x10694 <xbinGCD+96>
175	      a = a >> 1;
=> 0x10694 <xbinGCD+96>:	ld	a0,-24(s0)
0x0000000000010698	175	      a = a >> 1;
=> 0x10698 <xbinGCD+100>:	srli	a0,a0,0x1
0x000000000001069c	175	      a = a >> 1;
=> 0x1069c <xbinGCD+104>:	sd	a0,-24(s0)
176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a0 <xbinGCD+108>:	lbu	a0,-72(s0)
0x00000000000106a4	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a4 <xbinGCD+112>:	andi	a0,a0,1
0x00000000000106a8	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a8 <xbinGCD+116>:	bnez	a0,0x106cc <xbinGCD+152>
182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106cc <xbinGCD+152>:	ld	a0,-72(s0)
0x00000000000106d0	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106d0 <xbinGCD+156>:	ld	a1,-64(s0)
0x00000000000106d4	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106d4 <xbinGCD+160>:	xor	a2,a0,a1
0x00000000000106d8	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106d8 <xbinGCD+164>:	srli	a2,a2,0x1
0x00000000000106dc	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106dc <xbinGCD+168>:	and	a0,a0,a1
0x00000000000106e0	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106e0 <xbinGCD+172>:	add	a0,a2,a0
0x00000000000106e4	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106e4 <xbinGCD+176>:	sd	a0,-72(s0)
183	         v = (v >> 1) + alpha;
=> 0x106e8 <xbinGCD+180>:	ld	a0,-80(s0)
0x00000000000106ec	183	         v = (v >> 1) + alpha;
=> 0x106ec <xbinGCD+184>:	srli	a0,a0,0x1
0x00000000000106f0	183	         v = (v >> 1) + alpha;
=> 0x106f0 <xbinGCD+188>:	ld	a1,-56(s0)
0x00000000000106f4	183	         v = (v >> 1) + alpha;
=> 0x106f4 <xbinGCD+192>:	add	a0,a0,a1
0x00000000000106f8	183	         v = (v >> 1) + alpha;
=> 0x106f8 <xbinGCD+196>:	sd	a0,-80(s0)
0x00000000000106fc	183	         v = (v >> 1) + alpha;
=> 0x106fc <xbinGCD+200>:	j	0x10700 <xbinGCD+204>
174	   while (a > 0) {
=> 0x10700 <xbinGCD+204>:	j	0x10684 <xbinGCD+80>
0x0000000000010684	174	   while (a > 0) {
=> 0x10684 <xbinGCD+80>:	ld	a0,-24(s0)
0x0000000000010688	174	   while (a > 0) {
=> 0x10688 <xbinGCD+84>:	li	a1,0
0x000000000001068c	174	   while (a > 0) {
=> 0x1068c <xbinGCD+88>:	beq	a0,a1,0x10704 <xbinGCD+208>
0x0000000000010690	174	   while (a > 0) {
=> 0x10690 <xbinGCD+92>:	j	0x10694 <xbinGCD+96>
175	      a = a >> 1;
=> 0x10694 <xbinGCD+96>:	ld	a0,-24(s0)
0x0000000000010698	175	      a = a >> 1;
=> 0x10698 <xbinGCD+100>:	srli	a0,a0,0x1
0x000000000001069c	175	      a = a >> 1;
=> 0x1069c <xbinGCD+104>:	sd	a0,-24(s0)
176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a0 <xbinGCD+108>:	lbu	a0,-72(s0)
0x00000000000106a4	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a4 <xbinGCD+112>:	andi	a0,a0,1
0x00000000000106a8	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a8 <xbinGCD+116>:	bnez	a0,0x106cc <xbinGCD+152>
0x00000000000106ac	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106ac <xbinGCD+120>:	j	0x106b0 <xbinGCD+124>
177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106b0 <xbinGCD+124>:	ld	a0,-72(s0)
0x00000000000106b4	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106b4 <xbinGCD+128>:	srli	a0,a0,0x1
0x00000000000106b8	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106b8 <xbinGCD+132>:	sd	a0,-72(s0)
0x00000000000106bc	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106bc <xbinGCD+136>:	ld	a0,-80(s0)
0x00000000000106c0	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106c0 <xbinGCD+140>:	srli	a0,a0,0x1
0x00000000000106c4	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106c4 <xbinGCD+144>:	sd	a0,-80(s0)
178	      }                               // u and v.
=> 0x106c8 <xbinGCD+148>:	j	0x10700 <xbinGCD+204>
174	   while (a > 0) {
=> 0x10700 <xbinGCD+204>:	j	0x10684 <xbinGCD+80>
0x0000000000010684	174	   while (a > 0) {
=> 0x10684 <xbinGCD+80>:	ld	a0,-24(s0)
0x0000000000010688	174	   while (a > 0) {
=> 0x10688 <xbinGCD+84>:	li	a1,0
0x000000000001068c	174	   while (a > 0) {
=> 0x1068c <xbinGCD+88>:	beq	a0,a1,0x10704 <xbinGCD+208>
0x0000000000010690	174	   while (a > 0) {
=> 0x10690 <xbinGCD+92>:	j	0x10694 <xbinGCD+96>
175	      a = a >> 1;
=> 0x10694 <xbinGCD+96>:	ld	a0,-24(s0)
0x0000000000010698	175	      a = a >> 1;
=> 0x10698 <xbinGCD+100>:	srli	a0,a0,0x1
0x000000000001069c	175	      a = a >> 1;
=> 0x1069c <xbinGCD+104>:	sd	a0,-24(s0)
176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a0 <xbinGCD+108>:	lbu	a0,-72(s0)
0x00000000000106a4	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a4 <xbinGCD+112>:	andi	a0,a0,1
0x00000000000106a8	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a8 <xbinGCD+116>:	bnez	a0,0x106cc <xbinGCD+152>
0x00000000000106ac	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106ac <xbinGCD+120>:	j	0x106b0 <xbinGCD+124>
177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106b0 <xbinGCD+124>:	ld	a0,-72(s0)
0x00000000000106b4	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106b4 <xbinGCD+128>:	srli	a0,a0,0x1
0x00000000000106b8	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106b8 <xbinGCD+132>:	sd	a0,-72(s0)
0x00000000000106bc	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106bc <xbinGCD+136>:	ld	a0,-80(s0)
0x00000000000106c0	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106c0 <xbinGCD+140>:	srli	a0,a0,0x1
0x00000000000106c4	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106c4 <xbinGCD+144>:	sd	a0,-80(s0)
178	      }                               // u and v.
=> 0x106c8 <xbinGCD+148>:	j	0x10700 <xbinGCD+204>
174	   while (a > 0) {
=> 0x10700 <xbinGCD+204>:	j	0x10684 <xbinGCD+80>
0x0000000000010684	174	   while (a > 0) {
=> 0x10684 <xbinGCD+80>:	ld	a0,-24(s0)
0x0000000000010688	174	   while (a > 0) {
=> 0x10688 <xbinGCD+84>:	li	a1,0
0x000000000001068c	174	   while (a > 0) {
=> 0x1068c <xbinGCD+88>:	beq	a0,a1,0x10704 <xbinGCD+208>
0x0000000000010690	174	   while (a > 0) {
=> 0x10690 <xbinGCD+92>:	j	0x10694 <xbinGCD+96>
175	      a = a >> 1;
=> 0x10694 <xbinGCD+96>:	ld	a0,-24(s0)
0x0000000000010698	175	      a = a >> 1;
=> 0x10698 <xbinGCD+100>:	srli	a0,a0,0x1
0x000000000001069c	175	      a = a >> 1;
=> 0x1069c <xbinGCD+104>:	sd	a0,-24(s0)
176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a0 <xbinGCD+108>:	lbu	a0,-72(s0)
0x00000000000106a4	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a4 <xbinGCD+112>:	andi	a0,a0,1
0x00000000000106a8	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a8 <xbinGCD+116>:	bnez	a0,0x106cc <xbinGCD+152>
0x00000000000106ac	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106ac <xbinGCD+120>:	j	0x106b0 <xbinGCD+124>
177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106b0 <xbinGCD+124>:	ld	a0,-72(s0)
0x00000000000106b4	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106b4 <xbinGCD+128>:	srli	a0,a0,0x1
0x00000000000106b8	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106b8 <xbinGCD+132>:	sd	a0,-72(s0)
0x00000000000106bc	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106bc <xbinGCD+136>:	ld	a0,-80(s0)
0x00000000000106c0	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106c0 <xbinGCD+140>:	srli	a0,a0,0x1
0x00000000000106c4	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106c4 <xbinGCD+144>:	sd	a0,-80(s0)
178	      }                               // u and v.
=> 0x106c8 <xbinGCD+148>:	j	0x10700 <xbinGCD+204>
174	   while (a > 0) {
=> 0x10700 <xbinGCD+204>:	j	0x10684 <xbinGCD+80>
0x0000000000010684	174	   while (a > 0) {
=> 0x10684 <xbinGCD+80>:	ld	a0,-24(s0)
0x0000000000010688	174	   while (a > 0) {
=> 0x10688 <xbinGCD+84>:	li	a1,0
0x000000000001068c	174	   while (a > 0) {
=> 0x1068c <xbinGCD+88>:	beq	a0,a1,0x10704 <xbinGCD+208>
0x0000000000010690	174	   while (a > 0) {
=> 0x10690 <xbinGCD+92>:	j	0x10694 <xbinGCD+96>
175	      a = a >> 1;
=> 0x10694 <xbinGCD+96>:	ld	a0,-24(s0)
0x0000000000010698	175	      a = a >> 1;
=> 0x10698 <xbinGCD+100>:	srli	a0,a0,0x1
0x000000000001069c	175	      a = a >> 1;
=> 0x1069c <xbinGCD+104>:	sd	a0,-24(s0)
176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a0 <xbinGCD+108>:	lbu	a0,-72(s0)
0x00000000000106a4	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a4 <xbinGCD+112>:	andi	a0,a0,1
0x00000000000106a8	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a8 <xbinGCD+116>:	bnez	a0,0x106cc <xbinGCD+152>
0x00000000000106ac	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106ac <xbinGCD+120>:	j	0x106b0 <xbinGCD+124>
177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106b0 <xbinGCD+124>:	ld	a0,-72(s0)
0x00000000000106b4	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106b4 <xbinGCD+128>:	srli	a0,a0,0x1
0x00000000000106b8	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106b8 <xbinGCD+132>:	sd	a0,-72(s0)
0x00000000000106bc	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106bc <xbinGCD+136>:	ld	a0,-80(s0)
0x00000000000106c0	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106c0 <xbinGCD+140>:	srli	a0,a0,0x1
0x00000000000106c4	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106c4 <xbinGCD+144>:	sd	a0,-80(s0)
178	      }                               // u and v.
=> 0x106c8 <xbinGCD+148>:	j	0x10700 <xbinGCD+204>
174	   while (a > 0) {
=> 0x10700 <xbinGCD+204>:	j	0x10684 <xbinGCD+80>
0x0000000000010684	174	   while (a > 0) {
=> 0x10684 <xbinGCD+80>:	ld	a0,-24(s0)
0x0000000000010688	174	   while (a > 0) {
=> 0x10688 <xbinGCD+84>:	li	a1,0
0x000000000001068c	174	   while (a > 0) {
=> 0x1068c <xbinGCD+88>:	beq	a0,a1,0x10704 <xbinGCD+208>
0x0000000000010690	174	   while (a > 0) {
=> 0x10690 <xbinGCD+92>:	j	0x10694 <xbinGCD+96>
175	      a = a >> 1;
=> 0x10694 <xbinGCD+96>:	ld	a0,-24(s0)
0x0000000000010698	175	      a = a >> 1;
=> 0x10698 <xbinGCD+100>:	srli	a0,a0,0x1
0x000000000001069c	175	      a = a >> 1;
=> 0x1069c <xbinGCD+104>:	sd	a0,-24(s0)
176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a0 <xbinGCD+108>:	lbu	a0,-72(s0)
0x00000000000106a4	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a4 <xbinGCD+112>:	andi	a0,a0,1
0x00000000000106a8	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a8 <xbinGCD+116>:	bnez	a0,0x106cc <xbinGCD+152>
182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106cc <xbinGCD+152>:	ld	a0,-72(s0)
0x00000000000106d0	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106d0 <xbinGCD+156>:	ld	a1,-64(s0)
0x00000000000106d4	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106d4 <xbinGCD+160>:	xor	a2,a0,a1
0x00000000000106d8	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106d8 <xbinGCD+164>:	srli	a2,a2,0x1
0x00000000000106dc	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106dc <xbinGCD+168>:	and	a0,a0,a1
0x00000000000106e0	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106e0 <xbinGCD+172>:	add	a0,a2,a0
0x00000000000106e4	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106e4 <xbinGCD+176>:	sd	a0,-72(s0)
183	         v = (v >> 1) + alpha;
=> 0x106e8 <xbinGCD+180>:	ld	a0,-80(s0)
0x00000000000106ec	183	         v = (v >> 1) + alpha;
=> 0x106ec <xbinGCD+184>:	srli	a0,a0,0x1
0x00000000000106f0	183	         v = (v >> 1) + alpha;
=> 0x106f0 <xbinGCD+188>:	ld	a1,-56(s0)
0x00000000000106f4	183	         v = (v >> 1) + alpha;
=> 0x106f4 <xbinGCD+192>:	add	a0,a0,a1
0x00000000000106f8	183	         v = (v >> 1) + alpha;
=> 0x106f8 <xbinGCD+196>:	sd	a0,-80(s0)
0x00000000000106fc	183	         v = (v >> 1) + alpha;
=> 0x106fc <xbinGCD+200>:	j	0x10700 <xbinGCD+204>
174	   while (a > 0) {
=> 0x10700 <xbinGCD+204>:	j	0x10684 <xbinGCD+80>
0x0000000000010684	174	   while (a > 0) {
=> 0x10684 <xbinGCD+80>:	ld	a0,-24(s0)
0x0000000000010688	174	   while (a > 0) {
=> 0x10688 <xbinGCD+84>:	li	a1,0
0x000000000001068c	174	   while (a > 0) {
=> 0x1068c <xbinGCD+88>:	beq	a0,a1,0x10704 <xbinGCD+208>
0x0000000000010690	174	   while (a > 0) {
=> 0x10690 <xbinGCD+92>:	j	0x10694 <xbinGCD+96>
175	      a = a >> 1;
=> 0x10694 <xbinGCD+96>:	ld	a0,-24(s0)
0x0000000000010698	175	      a = a >> 1;
=> 0x10698 <xbinGCD+100>:	srli	a0,a0,0x1
0x000000000001069c	175	      a = a >> 1;
=> 0x1069c <xbinGCD+104>:	sd	a0,-24(s0)
176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a0 <xbinGCD+108>:	lbu	a0,-72(s0)
0x00000000000106a4	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a4 <xbinGCD+112>:	andi	a0,a0,1
0x00000000000106a8	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a8 <xbinGCD+116>:	bnez	a0,0x106cc <xbinGCD+152>
0x00000000000106ac	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106ac <xbinGCD+120>:	j	0x106b0 <xbinGCD+124>
177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106b0 <xbinGCD+124>:	ld	a0,-72(s0)
0x00000000000106b4	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106b4 <xbinGCD+128>:	srli	a0,a0,0x1
0x00000000000106b8	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106b8 <xbinGCD+132>:	sd	a0,-72(s0)
0x00000000000106bc	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106bc <xbinGCD+136>:	ld	a0,-80(s0)
0x00000000000106c0	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106c0 <xbinGCD+140>:	srli	a0,a0,0x1
0x00000000000106c4	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106c4 <xbinGCD+144>:	sd	a0,-80(s0)
178	      }                               // u and v.
=> 0x106c8 <xbinGCD+148>:	j	0x10700 <xbinGCD+204>
174	   while (a > 0) {
=> 0x10700 <xbinGCD+204>:	j	0x10684 <xbinGCD+80>
0x0000000000010684	174	   while (a > 0) {
=> 0x10684 <xbinGCD+80>:	ld	a0,-24(s0)
0x0000000000010688	174	   while (a > 0) {
=> 0x10688 <xbinGCD+84>:	li	a1,0
0x000000000001068c	174	   while (a > 0) {
=> 0x1068c <xbinGCD+88>:	beq	a0,a1,0x10704 <xbinGCD+208>
0x0000000000010690	174	   while (a > 0) {
=> 0x10690 <xbinGCD+92>:	j	0x10694 <xbinGCD+96>
175	      a = a >> 1;
=> 0x10694 <xbinGCD+96>:	ld	a0,-24(s0)
0x0000000000010698	175	      a = a >> 1;
=> 0x10698 <xbinGCD+100>:	srli	a0,a0,0x1
0x000000000001069c	175	      a = a >> 1;
=> 0x1069c <xbinGCD+104>:	sd	a0,-24(s0)
176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a0 <xbinGCD+108>:	lbu	a0,-72(s0)
0x00000000000106a4	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a4 <xbinGCD+112>:	andi	a0,a0,1
0x00000000000106a8	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a8 <xbinGCD+116>:	bnez	a0,0x106cc <xbinGCD+152>
182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106cc <xbinGCD+152>:	ld	a0,-72(s0)
0x00000000000106d0	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106d0 <xbinGCD+156>:	ld	a1,-64(s0)
0x00000000000106d4	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106d4 <xbinGCD+160>:	xor	a2,a0,a1
0x00000000000106d8	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106d8 <xbinGCD+164>:	srli	a2,a2,0x1
0x00000000000106dc	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106dc <xbinGCD+168>:	and	a0,a0,a1
0x00000000000106e0	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106e0 <xbinGCD+172>:	add	a0,a2,a0
0x00000000000106e4	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106e4 <xbinGCD+176>:	sd	a0,-72(s0)
183	         v = (v >> 1) + alpha;
=> 0x106e8 <xbinGCD+180>:	ld	a0,-80(s0)
0x00000000000106ec	183	         v = (v >> 1) + alpha;
=> 0x106ec <xbinGCD+184>:	srli	a0,a0,0x1
0x00000000000106f0	183	         v = (v >> 1) + alpha;
=> 0x106f0 <xbinGCD+188>:	ld	a1,-56(s0)
0x00000000000106f4	183	         v = (v >> 1) + alpha;
=> 0x106f4 <xbinGCD+192>:	add	a0,a0,a1
0x00000000000106f8	183	         v = (v >> 1) + alpha;
=> 0x106f8 <xbinGCD+196>:	sd	a0,-80(s0)
0x00000000000106fc	183	         v = (v >> 1) + alpha;
=> 0x106fc <xbinGCD+200>:	j	0x10700 <xbinGCD+204>
174	   while (a > 0) {
=> 0x10700 <xbinGCD+204>:	j	0x10684 <xbinGCD+80>
0x0000000000010684	174	   while (a > 0) {
=> 0x10684 <xbinGCD+80>:	ld	a0,-24(s0)
0x0000000000010688	174	   while (a > 0) {
=> 0x10688 <xbinGCD+84>:	li	a1,0
0x000000000001068c	174	   while (a > 0) {
=> 0x1068c <xbinGCD+88>:	beq	a0,a1,0x10704 <xbinGCD+208>
0x0000000000010690	174	   while (a > 0) {
=> 0x10690 <xbinGCD+92>:	j	0x10694 <xbinGCD+96>
175	      a = a >> 1;
=> 0x10694 <xbinGCD+96>:	ld	a0,-24(s0)
0x0000000000010698	175	      a = a >> 1;
=> 0x10698 <xbinGCD+100>:	srli	a0,a0,0x1
0x000000000001069c	175	      a = a >> 1;
=> 0x1069c <xbinGCD+104>:	sd	a0,-24(s0)
176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a0 <xbinGCD+108>:	lbu	a0,-72(s0)
0x00000000000106a4	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a4 <xbinGCD+112>:	andi	a0,a0,1
0x00000000000106a8	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a8 <xbinGCD+116>:	bnez	a0,0x106cc <xbinGCD+152>
0x00000000000106ac	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106ac <xbinGCD+120>:	j	0x106b0 <xbinGCD+124>
177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106b0 <xbinGCD+124>:	ld	a0,-72(s0)
0x00000000000106b4	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106b4 <xbinGCD+128>:	srli	a0,a0,0x1
0x00000000000106b8	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106b8 <xbinGCD+132>:	sd	a0,-72(s0)
0x00000000000106bc	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106bc <xbinGCD+136>:	ld	a0,-80(s0)
0x00000000000106c0	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106c0 <xbinGCD+140>:	srli	a0,a0,0x1
0x00000000000106c4	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106c4 <xbinGCD+144>:	sd	a0,-80(s0)
178	      }                               // u and v.
=> 0x106c8 <xbinGCD+148>:	j	0x10700 <xbinGCD+204>
174	   while (a > 0) {
=> 0x10700 <xbinGCD+204>:	j	0x10684 <xbinGCD+80>
0x0000000000010684	174	   while (a > 0) {
=> 0x10684 <xbinGCD+80>:	ld	a0,-24(s0)
0x0000000000010688	174	   while (a > 0) {
=> 0x10688 <xbinGCD+84>:	li	a1,0
0x000000000001068c	174	   while (a > 0) {
=> 0x1068c <xbinGCD+88>:	beq	a0,a1,0x10704 <xbinGCD+208>
0x0000000000010690	174	   while (a > 0) {
=> 0x10690 <xbinGCD+92>:	j	0x10694 <xbinGCD+96>
175	      a = a >> 1;
=> 0x10694 <xbinGCD+96>:	ld	a0,-24(s0)
0x0000000000010698	175	      a = a >> 1;
=> 0x10698 <xbinGCD+100>:	srli	a0,a0,0x1
0x000000000001069c	175	      a = a >> 1;
=> 0x1069c <xbinGCD+104>:	sd	a0,-24(s0)
176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a0 <xbinGCD+108>:	lbu	a0,-72(s0)
0x00000000000106a4	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a4 <xbinGCD+112>:	andi	a0,a0,1
0x00000000000106a8	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a8 <xbinGCD+116>:	bnez	a0,0x106cc <xbinGCD+152>
0x00000000000106ac	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106ac <xbinGCD+120>:	j	0x106b0 <xbinGCD+124>
177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106b0 <xbinGCD+124>:	ld	a0,-72(s0)
0x00000000000106b4	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106b4 <xbinGCD+128>:	srli	a0,a0,0x1
0x00000000000106b8	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106b8 <xbinGCD+132>:	sd	a0,-72(s0)
0x00000000000106bc	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106bc <xbinGCD+136>:	ld	a0,-80(s0)
0x00000000000106c0	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106c0 <xbinGCD+140>:	srli	a0,a0,0x1
0x00000000000106c4	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106c4 <xbinGCD+144>:	sd	a0,-80(s0)
178	      }                               // u and v.
=> 0x106c8 <xbinGCD+148>:	j	0x10700 <xbinGCD+204>
174	   while (a > 0) {
=> 0x10700 <xbinGCD+204>:	j	0x10684 <xbinGCD+80>
0x0000000000010684	174	   while (a > 0) {
=> 0x10684 <xbinGCD+80>:	ld	a0,-24(s0)
0x0000000000010688	174	   while (a > 0) {
=> 0x10688 <xbinGCD+84>:	li	a1,0
0x000000000001068c	174	   while (a > 0) {
=> 0x1068c <xbinGCD+88>:	beq	a0,a1,0x10704 <xbinGCD+208>
0x0000000000010690	174	   while (a > 0) {
=> 0x10690 <xbinGCD+92>:	j	0x10694 <xbinGCD+96>
175	      a = a >> 1;
=> 0x10694 <xbinGCD+96>:	ld	a0,-24(s0)
0x0000000000010698	175	      a = a >> 1;
=> 0x10698 <xbinGCD+100>:	srli	a0,a0,0x1
0x000000000001069c	175	      a = a >> 1;
=> 0x1069c <xbinGCD+104>:	sd	a0,-24(s0)
176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a0 <xbinGCD+108>:	lbu	a0,-72(s0)
0x00000000000106a4	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a4 <xbinGCD+112>:	andi	a0,a0,1
0x00000000000106a8	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a8 <xbinGCD+116>:	bnez	a0,0x106cc <xbinGCD+152>
182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106cc <xbinGCD+152>:	ld	a0,-72(s0)
0x00000000000106d0	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106d0 <xbinGCD+156>:	ld	a1,-64(s0)
0x00000000000106d4	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106d4 <xbinGCD+160>:	xor	a2,a0,a1
0x00000000000106d8	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106d8 <xbinGCD+164>:	srli	a2,a2,0x1
0x00000000000106dc	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106dc <xbinGCD+168>:	and	a0,a0,a1
0x00000000000106e0	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106e0 <xbinGCD+172>:	add	a0,a2,a0
0x00000000000106e4	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106e4 <xbinGCD+176>:	sd	a0,-72(s0)
183	         v = (v >> 1) + alpha;
=> 0x106e8 <xbinGCD+180>:	ld	a0,-80(s0)
0x00000000000106ec	183	         v = (v >> 1) + alpha;
=> 0x106ec <xbinGCD+184>:	srli	a0,a0,0x1
0x00000000000106f0	183	         v = (v >> 1) + alpha;
=> 0x106f0 <xbinGCD+188>:	ld	a1,-56(s0)
0x00000000000106f4	183	         v = (v >> 1) + alpha;
=> 0x106f4 <xbinGCD+192>:	add	a0,a0,a1
0x00000000000106f8	183	         v = (v >> 1) + alpha;
=> 0x106f8 <xbinGCD+196>:	sd	a0,-80(s0)
0x00000000000106fc	183	         v = (v >> 1) + alpha;
=> 0x106fc <xbinGCD+200>:	j	0x10700 <xbinGCD+204>
174	   while (a > 0) {
=> 0x10700 <xbinGCD+204>:	j	0x10684 <xbinGCD+80>
0x0000000000010684	174	   while (a > 0) {
=> 0x10684 <xbinGCD+80>:	ld	a0,-24(s0)
0x0000000000010688	174	   while (a > 0) {
=> 0x10688 <xbinGCD+84>:	li	a1,0
0x000000000001068c	174	   while (a > 0) {
=> 0x1068c <xbinGCD+88>:	beq	a0,a1,0x10704 <xbinGCD+208>
0x0000000000010690	174	   while (a > 0) {
=> 0x10690 <xbinGCD+92>:	j	0x10694 <xbinGCD+96>
175	      a = a >> 1;
=> 0x10694 <xbinGCD+96>:	ld	a0,-24(s0)
0x0000000000010698	175	      a = a >> 1;
=> 0x10698 <xbinGCD+100>:	srli	a0,a0,0x1
0x000000000001069c	175	      a = a >> 1;
=> 0x1069c <xbinGCD+104>:	sd	a0,-24(s0)
176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a0 <xbinGCD+108>:	lbu	a0,-72(s0)
0x00000000000106a4	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a4 <xbinGCD+112>:	andi	a0,a0,1
0x00000000000106a8	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a8 <xbinGCD+116>:	bnez	a0,0x106cc <xbinGCD+152>
182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106cc <xbinGCD+152>:	ld	a0,-72(s0)
0x00000000000106d0	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106d0 <xbinGCD+156>:	ld	a1,-64(s0)
0x00000000000106d4	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106d4 <xbinGCD+160>:	xor	a2,a0,a1
0x00000000000106d8	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106d8 <xbinGCD+164>:	srli	a2,a2,0x1
0x00000000000106dc	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106dc <xbinGCD+168>:	and	a0,a0,a1
0x00000000000106e0	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106e0 <xbinGCD+172>:	add	a0,a2,a0
0x00000000000106e4	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106e4 <xbinGCD+176>:	sd	a0,-72(s0)
183	         v = (v >> 1) + alpha;
=> 0x106e8 <xbinGCD+180>:	ld	a0,-80(s0)
0x00000000000106ec	183	         v = (v >> 1) + alpha;
=> 0x106ec <xbinGCD+184>:	srli	a0,a0,0x1
0x00000000000106f0	183	         v = (v >> 1) + alpha;
=> 0x106f0 <xbinGCD+188>:	ld	a1,-56(s0)
0x00000000000106f4	183	         v = (v >> 1) + alpha;
=> 0x106f4 <xbinGCD+192>:	add	a0,a0,a1
0x00000000000106f8	183	         v = (v >> 1) + alpha;
=> 0x106f8 <xbinGCD+196>:	sd	a0,-80(s0)
0x00000000000106fc	183	         v = (v >> 1) + alpha;
=> 0x106fc <xbinGCD+200>:	j	0x10700 <xbinGCD+204>
174	   while (a > 0) {
=> 0x10700 <xbinGCD+204>:	j	0x10684 <xbinGCD+80>
0x0000000000010684	174	   while (a > 0) {
=> 0x10684 <xbinGCD+80>:	ld	a0,-24(s0)
0x0000000000010688	174	   while (a > 0) {
=> 0x10688 <xbinGCD+84>:	li	a1,0
0x000000000001068c	174	   while (a > 0) {
=> 0x1068c <xbinGCD+88>:	beq	a0,a1,0x10704 <xbinGCD+208>
0x0000000000010690	174	   while (a > 0) {
=> 0x10690 <xbinGCD+92>:	j	0x10694 <xbinGCD+96>
175	      a = a >> 1;
=> 0x10694 <xbinGCD+96>:	ld	a0,-24(s0)
0x0000000000010698	175	      a = a >> 1;
=> 0x10698 <xbinGCD+100>:	srli	a0,a0,0x1
0x000000000001069c	175	      a = a >> 1;
=> 0x1069c <xbinGCD+104>:	sd	a0,-24(s0)
176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a0 <xbinGCD+108>:	lbu	a0,-72(s0)
0x00000000000106a4	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a4 <xbinGCD+112>:	andi	a0,a0,1
0x00000000000106a8	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a8 <xbinGCD+116>:	bnez	a0,0x106cc <xbinGCD+152>
182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106cc <xbinGCD+152>:	ld	a0,-72(s0)
0x00000000000106d0	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106d0 <xbinGCD+156>:	ld	a1,-64(s0)
0x00000000000106d4	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106d4 <xbinGCD+160>:	xor	a2,a0,a1
0x00000000000106d8	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106d8 <xbinGCD+164>:	srli	a2,a2,0x1
0x00000000000106dc	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106dc <xbinGCD+168>:	and	a0,a0,a1
0x00000000000106e0	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106e0 <xbinGCD+172>:	add	a0,a2,a0
0x00000000000106e4	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106e4 <xbinGCD+176>:	sd	a0,-72(s0)
183	         v = (v >> 1) + alpha;
=> 0x106e8 <xbinGCD+180>:	ld	a0,-80(s0)
0x00000000000106ec	183	         v = (v >> 1) + alpha;
=> 0x106ec <xbinGCD+184>:	srli	a0,a0,0x1
0x00000000000106f0	183	         v = (v >> 1) + alpha;
=> 0x106f0 <xbinGCD+188>:	ld	a1,-56(s0)
0x00000000000106f4	183	         v = (v >> 1) + alpha;
=> 0x106f4 <xbinGCD+192>:	add	a0,a0,a1
0x00000000000106f8	183	         v = (v >> 1) + alpha;
=> 0x106f8 <xbinGCD+196>:	sd	a0,-80(s0)
0x00000000000106fc	183	         v = (v >> 1) + alpha;
=> 0x106fc <xbinGCD+200>:	j	0x10700 <xbinGCD+204>
174	   while (a > 0) {
=> 0x10700 <xbinGCD+204>:	j	0x10684 <xbinGCD+80>
0x0000000000010684	174	   while (a > 0) {
=> 0x10684 <xbinGCD+80>:	ld	a0,-24(s0)
0x0000000000010688	174	   while (a > 0) {
=> 0x10688 <xbinGCD+84>:	li	a1,0
0x000000000001068c	174	   while (a > 0) {
=> 0x1068c <xbinGCD+88>:	beq	a0,a1,0x10704 <xbinGCD+208>
0x0000000000010690	174	   while (a > 0) {
=> 0x10690 <xbinGCD+92>:	j	0x10694 <xbinGCD+96>
175	      a = a >> 1;
=> 0x10694 <xbinGCD+96>:	ld	a0,-24(s0)
0x0000000000010698	175	      a = a >> 1;
=> 0x10698 <xbinGCD+100>:	srli	a0,a0,0x1
0x000000000001069c	175	      a = a >> 1;
=> 0x1069c <xbinGCD+104>:	sd	a0,-24(s0)
176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a0 <xbinGCD+108>:	lbu	a0,-72(s0)
0x00000000000106a4	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a4 <xbinGCD+112>:	andi	a0,a0,1
0x00000000000106a8	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a8 <xbinGCD+116>:	bnez	a0,0x106cc <xbinGCD+152>
0x00000000000106ac	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106ac <xbinGCD+120>:	j	0x106b0 <xbinGCD+124>
177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106b0 <xbinGCD+124>:	ld	a0,-72(s0)
0x00000000000106b4	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106b4 <xbinGCD+128>:	srli	a0,a0,0x1
0x00000000000106b8	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106b8 <xbinGCD+132>:	sd	a0,-72(s0)
0x00000000000106bc	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106bc <xbinGCD+136>:	ld	a0,-80(s0)
0x00000000000106c0	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106c0 <xbinGCD+140>:	srli	a0,a0,0x1
0x00000000000106c4	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106c4 <xbinGCD+144>:	sd	a0,-80(s0)
178	      }                               // u and v.
=> 0x106c8 <xbinGCD+148>:	j	0x10700 <xbinGCD+204>
174	   while (a > 0) {
=> 0x10700 <xbinGCD+204>:	j	0x10684 <xbinGCD+80>
0x0000000000010684	174	   while (a > 0) {
=> 0x10684 <xbinGCD+80>:	ld	a0,-24(s0)
0x0000000000010688	174	   while (a > 0) {
=> 0x10688 <xbinGCD+84>:	li	a1,0
0x000000000001068c	174	   while (a > 0) {
=> 0x1068c <xbinGCD+88>:	beq	a0,a1,0x10704 <xbinGCD+208>
0x0000000000010690	174	   while (a > 0) {
=> 0x10690 <xbinGCD+92>:	j	0x10694 <xbinGCD+96>
175	      a = a >> 1;
=> 0x10694 <xbinGCD+96>:	ld	a0,-24(s0)
0x0000000000010698	175	      a = a >> 1;
=> 0x10698 <xbinGCD+100>:	srli	a0,a0,0x1
0x000000000001069c	175	      a = a >> 1;
=> 0x1069c <xbinGCD+104>:	sd	a0,-24(s0)
176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a0 <xbinGCD+108>:	lbu	a0,-72(s0)
0x00000000000106a4	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a4 <xbinGCD+112>:	andi	a0,a0,1
0x00000000000106a8	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a8 <xbinGCD+116>:	bnez	a0,0x106cc <xbinGCD+152>
182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106cc <xbinGCD+152>:	ld	a0,-72(s0)
0x00000000000106d0	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106d0 <xbinGCD+156>:	ld	a1,-64(s0)
0x00000000000106d4	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106d4 <xbinGCD+160>:	xor	a2,a0,a1
0x00000000000106d8	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106d8 <xbinGCD+164>:	srli	a2,a2,0x1
0x00000000000106dc	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106dc <xbinGCD+168>:	and	a0,a0,a1
0x00000000000106e0	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106e0 <xbinGCD+172>:	add	a0,a2,a0
0x00000000000106e4	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106e4 <xbinGCD+176>:	sd	a0,-72(s0)
183	         v = (v >> 1) + alpha;
=> 0x106e8 <xbinGCD+180>:	ld	a0,-80(s0)
0x00000000000106ec	183	         v = (v >> 1) + alpha;
=> 0x106ec <xbinGCD+184>:	srli	a0,a0,0x1
0x00000000000106f0	183	         v = (v >> 1) + alpha;
=> 0x106f0 <xbinGCD+188>:	ld	a1,-56(s0)
0x00000000000106f4	183	         v = (v >> 1) + alpha;
=> 0x106f4 <xbinGCD+192>:	add	a0,a0,a1
0x00000000000106f8	183	         v = (v >> 1) + alpha;
=> 0x106f8 <xbinGCD+196>:	sd	a0,-80(s0)
0x00000000000106fc	183	         v = (v >> 1) + alpha;
=> 0x106fc <xbinGCD+200>:	j	0x10700 <xbinGCD+204>
174	   while (a > 0) {
=> 0x10700 <xbinGCD+204>:	j	0x10684 <xbinGCD+80>
0x0000000000010684	174	   while (a > 0) {
=> 0x10684 <xbinGCD+80>:	ld	a0,-24(s0)
0x0000000000010688	174	   while (a > 0) {
=> 0x10688 <xbinGCD+84>:	li	a1,0
0x000000000001068c	174	   while (a > 0) {
=> 0x1068c <xbinGCD+88>:	beq	a0,a1,0x10704 <xbinGCD+208>
0x0000000000010690	174	   while (a > 0) {
=> 0x10690 <xbinGCD+92>:	j	0x10694 <xbinGCD+96>
175	      a = a >> 1;
=> 0x10694 <xbinGCD+96>:	ld	a0,-24(s0)
0x0000000000010698	175	      a = a >> 1;
=> 0x10698 <xbinGCD+100>:	srli	a0,a0,0x1
0x000000000001069c	175	      a = a >> 1;
=> 0x1069c <xbinGCD+104>:	sd	a0,-24(s0)
176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a0 <xbinGCD+108>:	lbu	a0,-72(s0)
0x00000000000106a4	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a4 <xbinGCD+112>:	andi	a0,a0,1
0x00000000000106a8	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a8 <xbinGCD+116>:	bnez	a0,0x106cc <xbinGCD+152>
182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106cc <xbinGCD+152>:	ld	a0,-72(s0)
0x00000000000106d0	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106d0 <xbinGCD+156>:	ld	a1,-64(s0)
0x00000000000106d4	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106d4 <xbinGCD+160>:	xor	a2,a0,a1
0x00000000000106d8	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106d8 <xbinGCD+164>:	srli	a2,a2,0x1
0x00000000000106dc	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106dc <xbinGCD+168>:	and	a0,a0,a1
0x00000000000106e0	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106e0 <xbinGCD+172>:	add	a0,a2,a0
0x00000000000106e4	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106e4 <xbinGCD+176>:	sd	a0,-72(s0)
183	         v = (v >> 1) + alpha;
=> 0x106e8 <xbinGCD+180>:	ld	a0,-80(s0)
0x00000000000106ec	183	         v = (v >> 1) + alpha;
=> 0x106ec <xbinGCD+184>:	srli	a0,a0,0x1
0x00000000000106f0	183	         v = (v >> 1) + alpha;
=> 0x106f0 <xbinGCD+188>:	ld	a1,-56(s0)
0x00000000000106f4	183	         v = (v >> 1) + alpha;
=> 0x106f4 <xbinGCD+192>:	add	a0,a0,a1
0x00000000000106f8	183	         v = (v >> 1) + alpha;
=> 0x106f8 <xbinGCD+196>:	sd	a0,-80(s0)
0x00000000000106fc	183	         v = (v >> 1) + alpha;
=> 0x106fc <xbinGCD+200>:	j	0x10700 <xbinGCD+204>
174	   while (a > 0) {
=> 0x10700 <xbinGCD+204>:	j	0x10684 <xbinGCD+80>
0x0000000000010684	174	   while (a > 0) {
=> 0x10684 <xbinGCD+80>:	ld	a0,-24(s0)
0x0000000000010688	174	   while (a > 0) {
=> 0x10688 <xbinGCD+84>:	li	a1,0
0x000000000001068c	174	   while (a > 0) {
=> 0x1068c <xbinGCD+88>:	beq	a0,a1,0x10704 <xbinGCD+208>
0x0000000000010690	174	   while (a > 0) {
=> 0x10690 <xbinGCD+92>:	j	0x10694 <xbinGCD+96>
175	      a = a >> 1;
=> 0x10694 <xbinGCD+96>:	ld	a0,-24(s0)
0x0000000000010698	175	      a = a >> 1;
=> 0x10698 <xbinGCD+100>:	srli	a0,a0,0x1
0x000000000001069c	175	      a = a >> 1;
=> 0x1069c <xbinGCD+104>:	sd	a0,-24(s0)
176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a0 <xbinGCD+108>:	lbu	a0,-72(s0)
0x00000000000106a4	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a4 <xbinGCD+112>:	andi	a0,a0,1
0x00000000000106a8	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a8 <xbinGCD+116>:	bnez	a0,0x106cc <xbinGCD+152>
182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106cc <xbinGCD+152>:	ld	a0,-72(s0)
0x00000000000106d0	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106d0 <xbinGCD+156>:	ld	a1,-64(s0)
0x00000000000106d4	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106d4 <xbinGCD+160>:	xor	a2,a0,a1
0x00000000000106d8	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106d8 <xbinGCD+164>:	srli	a2,a2,0x1
0x00000000000106dc	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106dc <xbinGCD+168>:	and	a0,a0,a1
0x00000000000106e0	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106e0 <xbinGCD+172>:	add	a0,a2,a0
0x00000000000106e4	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106e4 <xbinGCD+176>:	sd	a0,-72(s0)
183	         v = (v >> 1) + alpha;
=> 0x106e8 <xbinGCD+180>:	ld	a0,-80(s0)
0x00000000000106ec	183	         v = (v >> 1) + alpha;
=> 0x106ec <xbinGCD+184>:	srli	a0,a0,0x1
0x00000000000106f0	183	         v = (v >> 1) + alpha;
=> 0x106f0 <xbinGCD+188>:	ld	a1,-56(s0)
0x00000000000106f4	183	         v = (v >> 1) + alpha;
=> 0x106f4 <xbinGCD+192>:	add	a0,a0,a1
0x00000000000106f8	183	         v = (v >> 1) + alpha;
=> 0x106f8 <xbinGCD+196>:	sd	a0,-80(s0)
0x00000000000106fc	183	         v = (v >> 1) + alpha;
=> 0x106fc <xbinGCD+200>:	j	0x10700 <xbinGCD+204>
174	   while (a > 0) {
=> 0x10700 <xbinGCD+204>:	j	0x10684 <xbinGCD+80>
0x0000000000010684	174	   while (a > 0) {
=> 0x10684 <xbinGCD+80>:	ld	a0,-24(s0)
0x0000000000010688	174	   while (a > 0) {
=> 0x10688 <xbinGCD+84>:	li	a1,0
0x000000000001068c	174	   while (a > 0) {
=> 0x1068c <xbinGCD+88>:	beq	a0,a1,0x10704 <xbinGCD+208>
0x0000000000010690	174	   while (a > 0) {
=> 0x10690 <xbinGCD+92>:	j	0x10694 <xbinGCD+96>
175	      a = a >> 1;
=> 0x10694 <xbinGCD+96>:	ld	a0,-24(s0)
0x0000000000010698	175	      a = a >> 1;
=> 0x10698 <xbinGCD+100>:	srli	a0,a0,0x1
0x000000000001069c	175	      a = a >> 1;
=> 0x1069c <xbinGCD+104>:	sd	a0,-24(s0)
176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a0 <xbinGCD+108>:	lbu	a0,-72(s0)
0x00000000000106a4	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a4 <xbinGCD+112>:	andi	a0,a0,1
0x00000000000106a8	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a8 <xbinGCD+116>:	bnez	a0,0x106cc <xbinGCD+152>
0x00000000000106ac	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106ac <xbinGCD+120>:	j	0x106b0 <xbinGCD+124>
177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106b0 <xbinGCD+124>:	ld	a0,-72(s0)
0x00000000000106b4	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106b4 <xbinGCD+128>:	srli	a0,a0,0x1
0x00000000000106b8	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106b8 <xbinGCD+132>:	sd	a0,-72(s0)
0x00000000000106bc	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106bc <xbinGCD+136>:	ld	a0,-80(s0)
0x00000000000106c0	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106c0 <xbinGCD+140>:	srli	a0,a0,0x1
0x00000000000106c4	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106c4 <xbinGCD+144>:	sd	a0,-80(s0)
178	      }                               // u and v.
=> 0x106c8 <xbinGCD+148>:	j	0x10700 <xbinGCD+204>
174	   while (a > 0) {
=> 0x10700 <xbinGCD+204>:	j	0x10684 <xbinGCD+80>
0x0000000000010684	174	   while (a > 0) {
=> 0x10684 <xbinGCD+80>:	ld	a0,-24(s0)
0x0000000000010688	174	   while (a > 0) {
=> 0x10688 <xbinGCD+84>:	li	a1,0
0x000000000001068c	174	   while (a > 0) {
=> 0x1068c <xbinGCD+88>:	beq	a0,a1,0x10704 <xbinGCD+208>
0x0000000000010690	174	   while (a > 0) {
=> 0x10690 <xbinGCD+92>:	j	0x10694 <xbinGCD+96>
175	      a = a >> 1;
=> 0x10694 <xbinGCD+96>:	ld	a0,-24(s0)
0x0000000000010698	175	      a = a >> 1;
=> 0x10698 <xbinGCD+100>:	srli	a0,a0,0x1
0x000000000001069c	175	      a = a >> 1;
=> 0x1069c <xbinGCD+104>:	sd	a0,-24(s0)
176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a0 <xbinGCD+108>:	lbu	a0,-72(s0)
0x00000000000106a4	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a4 <xbinGCD+112>:	andi	a0,a0,1
0x00000000000106a8	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a8 <xbinGCD+116>:	bnez	a0,0x106cc <xbinGCD+152>
182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106cc <xbinGCD+152>:	ld	a0,-72(s0)
0x00000000000106d0	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106d0 <xbinGCD+156>:	ld	a1,-64(s0)
0x00000000000106d4	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106d4 <xbinGCD+160>:	xor	a2,a0,a1
0x00000000000106d8	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106d8 <xbinGCD+164>:	srli	a2,a2,0x1
0x00000000000106dc	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106dc <xbinGCD+168>:	and	a0,a0,a1
0x00000000000106e0	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106e0 <xbinGCD+172>:	add	a0,a2,a0
0x00000000000106e4	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106e4 <xbinGCD+176>:	sd	a0,-72(s0)
183	         v = (v >> 1) + alpha;
=> 0x106e8 <xbinGCD+180>:	ld	a0,-80(s0)
0x00000000000106ec	183	         v = (v >> 1) + alpha;
=> 0x106ec <xbinGCD+184>:	srli	a0,a0,0x1
0x00000000000106f0	183	         v = (v >> 1) + alpha;
=> 0x106f0 <xbinGCD+188>:	ld	a1,-56(s0)
0x00000000000106f4	183	         v = (v >> 1) + alpha;
=> 0x106f4 <xbinGCD+192>:	add	a0,a0,a1
0x00000000000106f8	183	         v = (v >> 1) + alpha;
=> 0x106f8 <xbinGCD+196>:	sd	a0,-80(s0)
0x00000000000106fc	183	         v = (v >> 1) + alpha;
=> 0x106fc <xbinGCD+200>:	j	0x10700 <xbinGCD+204>
174	   while (a > 0) {
=> 0x10700 <xbinGCD+204>:	j	0x10684 <xbinGCD+80>
0x0000000000010684	174	   while (a > 0) {
=> 0x10684 <xbinGCD+80>:	ld	a0,-24(s0)
0x0000000000010688	174	   while (a > 0) {
=> 0x10688 <xbinGCD+84>:	li	a1,0
0x000000000001068c	174	   while (a > 0) {
=> 0x1068c <xbinGCD+88>:	beq	a0,a1,0x10704 <xbinGCD+208>
0x0000000000010690	174	   while (a > 0) {
=> 0x10690 <xbinGCD+92>:	j	0x10694 <xbinGCD+96>
175	      a = a >> 1;
=> 0x10694 <xbinGCD+96>:	ld	a0,-24(s0)
0x0000000000010698	175	      a = a >> 1;
=> 0x10698 <xbinGCD+100>:	srli	a0,a0,0x1
0x000000000001069c	175	      a = a >> 1;
=> 0x1069c <xbinGCD+104>:	sd	a0,-24(s0)
176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a0 <xbinGCD+108>:	lbu	a0,-72(s0)
0x00000000000106a4	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a4 <xbinGCD+112>:	andi	a0,a0,1
0x00000000000106a8	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a8 <xbinGCD+116>:	bnez	a0,0x106cc <xbinGCD+152>
182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106cc <xbinGCD+152>:	ld	a0,-72(s0)
0x00000000000106d0	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106d0 <xbinGCD+156>:	ld	a1,-64(s0)
0x00000000000106d4	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106d4 <xbinGCD+160>:	xor	a2,a0,a1
0x00000000000106d8	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106d8 <xbinGCD+164>:	srli	a2,a2,0x1
0x00000000000106dc	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106dc <xbinGCD+168>:	and	a0,a0,a1
0x00000000000106e0	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106e0 <xbinGCD+172>:	add	a0,a2,a0
0x00000000000106e4	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106e4 <xbinGCD+176>:	sd	a0,-72(s0)
183	         v = (v >> 1) + alpha;
=> 0x106e8 <xbinGCD+180>:	ld	a0,-80(s0)
0x00000000000106ec	183	         v = (v >> 1) + alpha;
=> 0x106ec <xbinGCD+184>:	srli	a0,a0,0x1
0x00000000000106f0	183	         v = (v >> 1) + alpha;
=> 0x106f0 <xbinGCD+188>:	ld	a1,-56(s0)
0x00000000000106f4	183	         v = (v >> 1) + alpha;
=> 0x106f4 <xbinGCD+192>:	add	a0,a0,a1
0x00000000000106f8	183	         v = (v >> 1) + alpha;
=> 0x106f8 <xbinGCD+196>:	sd	a0,-80(s0)
0x00000000000106fc	183	         v = (v >> 1) + alpha;
=> 0x106fc <xbinGCD+200>:	j	0x10700 <xbinGCD+204>
174	   while (a > 0) {
=> 0x10700 <xbinGCD+204>:	j	0x10684 <xbinGCD+80>
0x0000000000010684	174	   while (a > 0) {
=> 0x10684 <xbinGCD+80>:	ld	a0,-24(s0)
0x0000000000010688	174	   while (a > 0) {
=> 0x10688 <xbinGCD+84>:	li	a1,0
0x000000000001068c	174	   while (a > 0) {
=> 0x1068c <xbinGCD+88>:	beq	a0,a1,0x10704 <xbinGCD+208>
0x0000000000010690	174	   while (a > 0) {
=> 0x10690 <xbinGCD+92>:	j	0x10694 <xbinGCD+96>
175	      a = a >> 1;
=> 0x10694 <xbinGCD+96>:	ld	a0,-24(s0)
0x0000000000010698	175	      a = a >> 1;
=> 0x10698 <xbinGCD+100>:	srli	a0,a0,0x1
0x000000000001069c	175	      a = a >> 1;
=> 0x1069c <xbinGCD+104>:	sd	a0,-24(s0)
176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a0 <xbinGCD+108>:	lbu	a0,-72(s0)
0x00000000000106a4	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a4 <xbinGCD+112>:	andi	a0,a0,1
0x00000000000106a8	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a8 <xbinGCD+116>:	bnez	a0,0x106cc <xbinGCD+152>
0x00000000000106ac	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106ac <xbinGCD+120>:	j	0x106b0 <xbinGCD+124>
177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106b0 <xbinGCD+124>:	ld	a0,-72(s0)
0x00000000000106b4	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106b4 <xbinGCD+128>:	srli	a0,a0,0x1
0x00000000000106b8	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106b8 <xbinGCD+132>:	sd	a0,-72(s0)
0x00000000000106bc	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106bc <xbinGCD+136>:	ld	a0,-80(s0)
0x00000000000106c0	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106c0 <xbinGCD+140>:	srli	a0,a0,0x1
0x00000000000106c4	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106c4 <xbinGCD+144>:	sd	a0,-80(s0)
178	      }                               // u and v.
=> 0x106c8 <xbinGCD+148>:	j	0x10700 <xbinGCD+204>
174	   while (a > 0) {
=> 0x10700 <xbinGCD+204>:	j	0x10684 <xbinGCD+80>
0x0000000000010684	174	   while (a > 0) {
=> 0x10684 <xbinGCD+80>:	ld	a0,-24(s0)
0x0000000000010688	174	   while (a > 0) {
=> 0x10688 <xbinGCD+84>:	li	a1,0
0x000000000001068c	174	   while (a > 0) {
=> 0x1068c <xbinGCD+88>:	beq	a0,a1,0x10704 <xbinGCD+208>
0x0000000000010690	174	   while (a > 0) {
=> 0x10690 <xbinGCD+92>:	j	0x10694 <xbinGCD+96>
175	      a = a >> 1;
=> 0x10694 <xbinGCD+96>:	ld	a0,-24(s0)
0x0000000000010698	175	      a = a >> 1;
=> 0x10698 <xbinGCD+100>:	srli	a0,a0,0x1
0x000000000001069c	175	      a = a >> 1;
=> 0x1069c <xbinGCD+104>:	sd	a0,-24(s0)
176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a0 <xbinGCD+108>:	lbu	a0,-72(s0)
0x00000000000106a4	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a4 <xbinGCD+112>:	andi	a0,a0,1
0x00000000000106a8	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a8 <xbinGCD+116>:	bnez	a0,0x106cc <xbinGCD+152>
0x00000000000106ac	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106ac <xbinGCD+120>:	j	0x106b0 <xbinGCD+124>
177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106b0 <xbinGCD+124>:	ld	a0,-72(s0)
0x00000000000106b4	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106b4 <xbinGCD+128>:	srli	a0,a0,0x1
0x00000000000106b8	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106b8 <xbinGCD+132>:	sd	a0,-72(s0)
0x00000000000106bc	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106bc <xbinGCD+136>:	ld	a0,-80(s0)
0x00000000000106c0	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106c0 <xbinGCD+140>:	srli	a0,a0,0x1
0x00000000000106c4	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106c4 <xbinGCD+144>:	sd	a0,-80(s0)
178	      }                               // u and v.
=> 0x106c8 <xbinGCD+148>:	j	0x10700 <xbinGCD+204>
174	   while (a > 0) {
=> 0x10700 <xbinGCD+204>:	j	0x10684 <xbinGCD+80>
0x0000000000010684	174	   while (a > 0) {
=> 0x10684 <xbinGCD+80>:	ld	a0,-24(s0)
0x0000000000010688	174	   while (a > 0) {
=> 0x10688 <xbinGCD+84>:	li	a1,0
0x000000000001068c	174	   while (a > 0) {
=> 0x1068c <xbinGCD+88>:	beq	a0,a1,0x10704 <xbinGCD+208>
0x0000000000010690	174	   while (a > 0) {
=> 0x10690 <xbinGCD+92>:	j	0x10694 <xbinGCD+96>
175	      a = a >> 1;
=> 0x10694 <xbinGCD+96>:	ld	a0,-24(s0)
0x0000000000010698	175	      a = a >> 1;
=> 0x10698 <xbinGCD+100>:	srli	a0,a0,0x1
0x000000000001069c	175	      a = a >> 1;
=> 0x1069c <xbinGCD+104>:	sd	a0,-24(s0)
176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a0 <xbinGCD+108>:	lbu	a0,-72(s0)
0x00000000000106a4	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a4 <xbinGCD+112>:	andi	a0,a0,1
0x00000000000106a8	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a8 <xbinGCD+116>:	bnez	a0,0x106cc <xbinGCD+152>
0x00000000000106ac	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106ac <xbinGCD+120>:	j	0x106b0 <xbinGCD+124>
177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106b0 <xbinGCD+124>:	ld	a0,-72(s0)
0x00000000000106b4	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106b4 <xbinGCD+128>:	srli	a0,a0,0x1
0x00000000000106b8	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106b8 <xbinGCD+132>:	sd	a0,-72(s0)
0x00000000000106bc	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106bc <xbinGCD+136>:	ld	a0,-80(s0)
0x00000000000106c0	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106c0 <xbinGCD+140>:	srli	a0,a0,0x1
0x00000000000106c4	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106c4 <xbinGCD+144>:	sd	a0,-80(s0)
178	      }                               // u and v.
=> 0x106c8 <xbinGCD+148>:	j	0x10700 <xbinGCD+204>
174	   while (a > 0) {
=> 0x10700 <xbinGCD+204>:	j	0x10684 <xbinGCD+80>
0x0000000000010684	174	   while (a > 0) {
=> 0x10684 <xbinGCD+80>:	ld	a0,-24(s0)
0x0000000000010688	174	   while (a > 0) {
=> 0x10688 <xbinGCD+84>:	li	a1,0
0x000000000001068c	174	   while (a > 0) {
=> 0x1068c <xbinGCD+88>:	beq	a0,a1,0x10704 <xbinGCD+208>
0x0000000000010690	174	   while (a > 0) {
=> 0x10690 <xbinGCD+92>:	j	0x10694 <xbinGCD+96>
175	      a = a >> 1;
=> 0x10694 <xbinGCD+96>:	ld	a0,-24(s0)
0x0000000000010698	175	      a = a >> 1;
=> 0x10698 <xbinGCD+100>:	srli	a0,a0,0x1
0x000000000001069c	175	      a = a >> 1;
=> 0x1069c <xbinGCD+104>:	sd	a0,-24(s0)
176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a0 <xbinGCD+108>:	lbu	a0,-72(s0)
0x00000000000106a4	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a4 <xbinGCD+112>:	andi	a0,a0,1
0x00000000000106a8	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a8 <xbinGCD+116>:	bnez	a0,0x106cc <xbinGCD+152>
182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106cc <xbinGCD+152>:	ld	a0,-72(s0)
0x00000000000106d0	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106d0 <xbinGCD+156>:	ld	a1,-64(s0)
0x00000000000106d4	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106d4 <xbinGCD+160>:	xor	a2,a0,a1
0x00000000000106d8	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106d8 <xbinGCD+164>:	srli	a2,a2,0x1
0x00000000000106dc	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106dc <xbinGCD+168>:	and	a0,a0,a1
0x00000000000106e0	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106e0 <xbinGCD+172>:	add	a0,a2,a0
0x00000000000106e4	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106e4 <xbinGCD+176>:	sd	a0,-72(s0)
183	         v = (v >> 1) + alpha;
=> 0x106e8 <xbinGCD+180>:	ld	a0,-80(s0)
0x00000000000106ec	183	         v = (v >> 1) + alpha;
=> 0x106ec <xbinGCD+184>:	srli	a0,a0,0x1
0x00000000000106f0	183	         v = (v >> 1) + alpha;
=> 0x106f0 <xbinGCD+188>:	ld	a1,-56(s0)
0x00000000000106f4	183	         v = (v >> 1) + alpha;
=> 0x106f4 <xbinGCD+192>:	add	a0,a0,a1
0x00000000000106f8	183	         v = (v >> 1) + alpha;
=> 0x106f8 <xbinGCD+196>:	sd	a0,-80(s0)
0x00000000000106fc	183	         v = (v >> 1) + alpha;
=> 0x106fc <xbinGCD+200>:	j	0x10700 <xbinGCD+204>
174	   while (a > 0) {
=> 0x10700 <xbinGCD+204>:	j	0x10684 <xbinGCD+80>
0x0000000000010684	174	   while (a > 0) {
=> 0x10684 <xbinGCD+80>:	ld	a0,-24(s0)
0x0000000000010688	174	   while (a > 0) {
=> 0x10688 <xbinGCD+84>:	li	a1,0
0x000000000001068c	174	   while (a > 0) {
=> 0x1068c <xbinGCD+88>:	beq	a0,a1,0x10704 <xbinGCD+208>
0x0000000000010690	174	   while (a > 0) {
=> 0x10690 <xbinGCD+92>:	j	0x10694 <xbinGCD+96>
175	      a = a >> 1;
=> 0x10694 <xbinGCD+96>:	ld	a0,-24(s0)
0x0000000000010698	175	      a = a >> 1;
=> 0x10698 <xbinGCD+100>:	srli	a0,a0,0x1
0x000000000001069c	175	      a = a >> 1;
=> 0x1069c <xbinGCD+104>:	sd	a0,-24(s0)
176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a0 <xbinGCD+108>:	lbu	a0,-72(s0)
0x00000000000106a4	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a4 <xbinGCD+112>:	andi	a0,a0,1
0x00000000000106a8	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a8 <xbinGCD+116>:	bnez	a0,0x106cc <xbinGCD+152>
0x00000000000106ac	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106ac <xbinGCD+120>:	j	0x106b0 <xbinGCD+124>
177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106b0 <xbinGCD+124>:	ld	a0,-72(s0)
0x00000000000106b4	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106b4 <xbinGCD+128>:	srli	a0,a0,0x1
0x00000000000106b8	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106b8 <xbinGCD+132>:	sd	a0,-72(s0)
0x00000000000106bc	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106bc <xbinGCD+136>:	ld	a0,-80(s0)
0x00000000000106c0	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106c0 <xbinGCD+140>:	srli	a0,a0,0x1
0x00000000000106c4	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106c4 <xbinGCD+144>:	sd	a0,-80(s0)
178	      }                               // u and v.
=> 0x106c8 <xbinGCD+148>:	j	0x10700 <xbinGCD+204>
174	   while (a > 0) {
=> 0x10700 <xbinGCD+204>:	j	0x10684 <xbinGCD+80>
0x0000000000010684	174	   while (a > 0) {
=> 0x10684 <xbinGCD+80>:	ld	a0,-24(s0)
0x0000000000010688	174	   while (a > 0) {
=> 0x10688 <xbinGCD+84>:	li	a1,0
0x000000000001068c	174	   while (a > 0) {
=> 0x1068c <xbinGCD+88>:	beq	a0,a1,0x10704 <xbinGCD+208>
0x0000000000010690	174	   while (a > 0) {
=> 0x10690 <xbinGCD+92>:	j	0x10694 <xbinGCD+96>
175	      a = a >> 1;
=> 0x10694 <xbinGCD+96>:	ld	a0,-24(s0)
0x0000000000010698	175	      a = a >> 1;
=> 0x10698 <xbinGCD+100>:	srli	a0,a0,0x1
0x000000000001069c	175	      a = a >> 1;
=> 0x1069c <xbinGCD+104>:	sd	a0,-24(s0)
176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a0 <xbinGCD+108>:	lbu	a0,-72(s0)
0x00000000000106a4	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a4 <xbinGCD+112>:	andi	a0,a0,1
0x00000000000106a8	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a8 <xbinGCD+116>:	bnez	a0,0x106cc <xbinGCD+152>
0x00000000000106ac	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106ac <xbinGCD+120>:	j	0x106b0 <xbinGCD+124>
177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106b0 <xbinGCD+124>:	ld	a0,-72(s0)
0x00000000000106b4	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106b4 <xbinGCD+128>:	srli	a0,a0,0x1
0x00000000000106b8	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106b8 <xbinGCD+132>:	sd	a0,-72(s0)
0x00000000000106bc	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106bc <xbinGCD+136>:	ld	a0,-80(s0)
0x00000000000106c0	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106c0 <xbinGCD+140>:	srli	a0,a0,0x1
0x00000000000106c4	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106c4 <xbinGCD+144>:	sd	a0,-80(s0)
178	      }                               // u and v.
=> 0x106c8 <xbinGCD+148>:	j	0x10700 <xbinGCD+204>
174	   while (a > 0) {
=> 0x10700 <xbinGCD+204>:	j	0x10684 <xbinGCD+80>
0x0000000000010684	174	   while (a > 0) {
=> 0x10684 <xbinGCD+80>:	ld	a0,-24(s0)
0x0000000000010688	174	   while (a > 0) {
=> 0x10688 <xbinGCD+84>:	li	a1,0
0x000000000001068c	174	   while (a > 0) {
=> 0x1068c <xbinGCD+88>:	beq	a0,a1,0x10704 <xbinGCD+208>
0x0000000000010690	174	   while (a > 0) {
=> 0x10690 <xbinGCD+92>:	j	0x10694 <xbinGCD+96>
175	      a = a >> 1;
=> 0x10694 <xbinGCD+96>:	ld	a0,-24(s0)
0x0000000000010698	175	      a = a >> 1;
=> 0x10698 <xbinGCD+100>:	srli	a0,a0,0x1
0x000000000001069c	175	      a = a >> 1;
=> 0x1069c <xbinGCD+104>:	sd	a0,-24(s0)
176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a0 <xbinGCD+108>:	lbu	a0,-72(s0)
0x00000000000106a4	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a4 <xbinGCD+112>:	andi	a0,a0,1
0x00000000000106a8	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a8 <xbinGCD+116>:	bnez	a0,0x106cc <xbinGCD+152>
0x00000000000106ac	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106ac <xbinGCD+120>:	j	0x106b0 <xbinGCD+124>
177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106b0 <xbinGCD+124>:	ld	a0,-72(s0)
0x00000000000106b4	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106b4 <xbinGCD+128>:	srli	a0,a0,0x1
0x00000000000106b8	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106b8 <xbinGCD+132>:	sd	a0,-72(s0)
0x00000000000106bc	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106bc <xbinGCD+136>:	ld	a0,-80(s0)
0x00000000000106c0	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106c0 <xbinGCD+140>:	srli	a0,a0,0x1
0x00000000000106c4	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106c4 <xbinGCD+144>:	sd	a0,-80(s0)
178	      }                               // u and v.
=> 0x106c8 <xbinGCD+148>:	j	0x10700 <xbinGCD+204>
174	   while (a > 0) {
=> 0x10700 <xbinGCD+204>:	j	0x10684 <xbinGCD+80>
0x0000000000010684	174	   while (a > 0) {
=> 0x10684 <xbinGCD+80>:	ld	a0,-24(s0)
0x0000000000010688	174	   while (a > 0) {
=> 0x10688 <xbinGCD+84>:	li	a1,0
0x000000000001068c	174	   while (a > 0) {
=> 0x1068c <xbinGCD+88>:	beq	a0,a1,0x10704 <xbinGCD+208>
0x0000000000010690	174	   while (a > 0) {
=> 0x10690 <xbinGCD+92>:	j	0x10694 <xbinGCD+96>
175	      a = a >> 1;
=> 0x10694 <xbinGCD+96>:	ld	a0,-24(s0)
0x0000000000010698	175	      a = a >> 1;
=> 0x10698 <xbinGCD+100>:	srli	a0,a0,0x1
0x000000000001069c	175	      a = a >> 1;
=> 0x1069c <xbinGCD+104>:	sd	a0,-24(s0)
176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a0 <xbinGCD+108>:	lbu	a0,-72(s0)
0x00000000000106a4	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a4 <xbinGCD+112>:	andi	a0,a0,1
0x00000000000106a8	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a8 <xbinGCD+116>:	bnez	a0,0x106cc <xbinGCD+152>
182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106cc <xbinGCD+152>:	ld	a0,-72(s0)
0x00000000000106d0	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106d0 <xbinGCD+156>:	ld	a1,-64(s0)
0x00000000000106d4	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106d4 <xbinGCD+160>:	xor	a2,a0,a1
0x00000000000106d8	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106d8 <xbinGCD+164>:	srli	a2,a2,0x1
0x00000000000106dc	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106dc <xbinGCD+168>:	and	a0,a0,a1
0x00000000000106e0	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106e0 <xbinGCD+172>:	add	a0,a2,a0
0x00000000000106e4	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106e4 <xbinGCD+176>:	sd	a0,-72(s0)
183	         v = (v >> 1) + alpha;
=> 0x106e8 <xbinGCD+180>:	ld	a0,-80(s0)
0x00000000000106ec	183	         v = (v >> 1) + alpha;
=> 0x106ec <xbinGCD+184>:	srli	a0,a0,0x1
0x00000000000106f0	183	         v = (v >> 1) + alpha;
=> 0x106f0 <xbinGCD+188>:	ld	a1,-56(s0)
0x00000000000106f4	183	         v = (v >> 1) + alpha;
=> 0x106f4 <xbinGCD+192>:	add	a0,a0,a1
0x00000000000106f8	183	         v = (v >> 1) + alpha;
=> 0x106f8 <xbinGCD+196>:	sd	a0,-80(s0)
0x00000000000106fc	183	         v = (v >> 1) + alpha;
=> 0x106fc <xbinGCD+200>:	j	0x10700 <xbinGCD+204>
174	   while (a > 0) {
=> 0x10700 <xbinGCD+204>:	j	0x10684 <xbinGCD+80>
0x0000000000010684	174	   while (a > 0) {
=> 0x10684 <xbinGCD+80>:	ld	a0,-24(s0)
0x0000000000010688	174	   while (a > 0) {
=> 0x10688 <xbinGCD+84>:	li	a1,0
0x000000000001068c	174	   while (a > 0) {
=> 0x1068c <xbinGCD+88>:	beq	a0,a1,0x10704 <xbinGCD+208>
0x0000000000010690	174	   while (a > 0) {
=> 0x10690 <xbinGCD+92>:	j	0x10694 <xbinGCD+96>
175	      a = a >> 1;
=> 0x10694 <xbinGCD+96>:	ld	a0,-24(s0)
0x0000000000010698	175	      a = a >> 1;
=> 0x10698 <xbinGCD+100>:	srli	a0,a0,0x1
0x000000000001069c	175	      a = a >> 1;
=> 0x1069c <xbinGCD+104>:	sd	a0,-24(s0)
176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a0 <xbinGCD+108>:	lbu	a0,-72(s0)
0x00000000000106a4	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a4 <xbinGCD+112>:	andi	a0,a0,1
0x00000000000106a8	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a8 <xbinGCD+116>:	bnez	a0,0x106cc <xbinGCD+152>
182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106cc <xbinGCD+152>:	ld	a0,-72(s0)
0x00000000000106d0	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106d0 <xbinGCD+156>:	ld	a1,-64(s0)
0x00000000000106d4	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106d4 <xbinGCD+160>:	xor	a2,a0,a1
0x00000000000106d8	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106d8 <xbinGCD+164>:	srli	a2,a2,0x1
0x00000000000106dc	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106dc <xbinGCD+168>:	and	a0,a0,a1
0x00000000000106e0	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106e0 <xbinGCD+172>:	add	a0,a2,a0
0x00000000000106e4	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106e4 <xbinGCD+176>:	sd	a0,-72(s0)
183	         v = (v >> 1) + alpha;
=> 0x106e8 <xbinGCD+180>:	ld	a0,-80(s0)
0x00000000000106ec	183	         v = (v >> 1) + alpha;
=> 0x106ec <xbinGCD+184>:	srli	a0,a0,0x1
0x00000000000106f0	183	         v = (v >> 1) + alpha;
=> 0x106f0 <xbinGCD+188>:	ld	a1,-56(s0)
0x00000000000106f4	183	         v = (v >> 1) + alpha;
=> 0x106f4 <xbinGCD+192>:	add	a0,a0,a1
0x00000000000106f8	183	         v = (v >> 1) + alpha;
=> 0x106f8 <xbinGCD+196>:	sd	a0,-80(s0)
0x00000000000106fc	183	         v = (v >> 1) + alpha;
=> 0x106fc <xbinGCD+200>:	j	0x10700 <xbinGCD+204>
174	   while (a > 0) {
=> 0x10700 <xbinGCD+204>:	j	0x10684 <xbinGCD+80>
0x0000000000010684	174	   while (a > 0) {
=> 0x10684 <xbinGCD+80>:	ld	a0,-24(s0)
0x0000000000010688	174	   while (a > 0) {
=> 0x10688 <xbinGCD+84>:	li	a1,0
0x000000000001068c	174	   while (a > 0) {
=> 0x1068c <xbinGCD+88>:	beq	a0,a1,0x10704 <xbinGCD+208>
0x0000000000010690	174	   while (a > 0) {
=> 0x10690 <xbinGCD+92>:	j	0x10694 <xbinGCD+96>
175	      a = a >> 1;
=> 0x10694 <xbinGCD+96>:	ld	a0,-24(s0)
0x0000000000010698	175	      a = a >> 1;
=> 0x10698 <xbinGCD+100>:	srli	a0,a0,0x1
0x000000000001069c	175	      a = a >> 1;
=> 0x1069c <xbinGCD+104>:	sd	a0,-24(s0)
176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a0 <xbinGCD+108>:	lbu	a0,-72(s0)
0x00000000000106a4	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a4 <xbinGCD+112>:	andi	a0,a0,1
0x00000000000106a8	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a8 <xbinGCD+116>:	bnez	a0,0x106cc <xbinGCD+152>
0x00000000000106ac	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106ac <xbinGCD+120>:	j	0x106b0 <xbinGCD+124>
177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106b0 <xbinGCD+124>:	ld	a0,-72(s0)
0x00000000000106b4	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106b4 <xbinGCD+128>:	srli	a0,a0,0x1
0x00000000000106b8	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106b8 <xbinGCD+132>:	sd	a0,-72(s0)
0x00000000000106bc	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106bc <xbinGCD+136>:	ld	a0,-80(s0)
0x00000000000106c0	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106c0 <xbinGCD+140>:	srli	a0,a0,0x1
0x00000000000106c4	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106c4 <xbinGCD+144>:	sd	a0,-80(s0)
178	      }                               // u and v.
=> 0x106c8 <xbinGCD+148>:	j	0x10700 <xbinGCD+204>
174	   while (a > 0) {
=> 0x10700 <xbinGCD+204>:	j	0x10684 <xbinGCD+80>
0x0000000000010684	174	   while (a > 0) {
=> 0x10684 <xbinGCD+80>:	ld	a0,-24(s0)
0x0000000000010688	174	   while (a > 0) {
=> 0x10688 <xbinGCD+84>:	li	a1,0
0x000000000001068c	174	   while (a > 0) {
=> 0x1068c <xbinGCD+88>:	beq	a0,a1,0x10704 <xbinGCD+208>
0x0000000000010690	174	   while (a > 0) {
=> 0x10690 <xbinGCD+92>:	j	0x10694 <xbinGCD+96>
175	      a = a >> 1;
=> 0x10694 <xbinGCD+96>:	ld	a0,-24(s0)
0x0000000000010698	175	      a = a >> 1;
=> 0x10698 <xbinGCD+100>:	srli	a0,a0,0x1
0x000000000001069c	175	      a = a >> 1;
=> 0x1069c <xbinGCD+104>:	sd	a0,-24(s0)
176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a0 <xbinGCD+108>:	lbu	a0,-72(s0)
0x00000000000106a4	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a4 <xbinGCD+112>:	andi	a0,a0,1
0x00000000000106a8	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a8 <xbinGCD+116>:	bnez	a0,0x106cc <xbinGCD+152>
0x00000000000106ac	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106ac <xbinGCD+120>:	j	0x106b0 <xbinGCD+124>
177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106b0 <xbinGCD+124>:	ld	a0,-72(s0)
0x00000000000106b4	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106b4 <xbinGCD+128>:	srli	a0,a0,0x1
0x00000000000106b8	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106b8 <xbinGCD+132>:	sd	a0,-72(s0)
0x00000000000106bc	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106bc <xbinGCD+136>:	ld	a0,-80(s0)
0x00000000000106c0	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106c0 <xbinGCD+140>:	srli	a0,a0,0x1
0x00000000000106c4	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106c4 <xbinGCD+144>:	sd	a0,-80(s0)
178	      }                               // u and v.
=> 0x106c8 <xbinGCD+148>:	j	0x10700 <xbinGCD+204>
174	   while (a > 0) {
=> 0x10700 <xbinGCD+204>:	j	0x10684 <xbinGCD+80>
0x0000000000010684	174	   while (a > 0) {
=> 0x10684 <xbinGCD+80>:	ld	a0,-24(s0)
0x0000000000010688	174	   while (a > 0) {
=> 0x10688 <xbinGCD+84>:	li	a1,0
0x000000000001068c	174	   while (a > 0) {
=> 0x1068c <xbinGCD+88>:	beq	a0,a1,0x10704 <xbinGCD+208>
0x0000000000010690	174	   while (a > 0) {
=> 0x10690 <xbinGCD+92>:	j	0x10694 <xbinGCD+96>
175	      a = a >> 1;
=> 0x10694 <xbinGCD+96>:	ld	a0,-24(s0)
0x0000000000010698	175	      a = a >> 1;
=> 0x10698 <xbinGCD+100>:	srli	a0,a0,0x1
0x000000000001069c	175	      a = a >> 1;
=> 0x1069c <xbinGCD+104>:	sd	a0,-24(s0)
176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a0 <xbinGCD+108>:	lbu	a0,-72(s0)
0x00000000000106a4	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a4 <xbinGCD+112>:	andi	a0,a0,1
0x00000000000106a8	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a8 <xbinGCD+116>:	bnez	a0,0x106cc <xbinGCD+152>
0x00000000000106ac	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106ac <xbinGCD+120>:	j	0x106b0 <xbinGCD+124>
177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106b0 <xbinGCD+124>:	ld	a0,-72(s0)
0x00000000000106b4	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106b4 <xbinGCD+128>:	srli	a0,a0,0x1
0x00000000000106b8	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106b8 <xbinGCD+132>:	sd	a0,-72(s0)
0x00000000000106bc	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106bc <xbinGCD+136>:	ld	a0,-80(s0)
0x00000000000106c0	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106c0 <xbinGCD+140>:	srli	a0,a0,0x1
0x00000000000106c4	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106c4 <xbinGCD+144>:	sd	a0,-80(s0)
178	      }                               // u and v.
=> 0x106c8 <xbinGCD+148>:	j	0x10700 <xbinGCD+204>
174	   while (a > 0) {
=> 0x10700 <xbinGCD+204>:	j	0x10684 <xbinGCD+80>
0x0000000000010684	174	   while (a > 0) {
=> 0x10684 <xbinGCD+80>:	ld	a0,-24(s0)
0x0000000000010688	174	   while (a > 0) {
=> 0x10688 <xbinGCD+84>:	li	a1,0
0x000000000001068c	174	   while (a > 0) {
=> 0x1068c <xbinGCD+88>:	beq	a0,a1,0x10704 <xbinGCD+208>
0x0000000000010690	174	   while (a > 0) {
=> 0x10690 <xbinGCD+92>:	j	0x10694 <xbinGCD+96>
175	      a = a >> 1;
=> 0x10694 <xbinGCD+96>:	ld	a0,-24(s0)
0x0000000000010698	175	      a = a >> 1;
=> 0x10698 <xbinGCD+100>:	srli	a0,a0,0x1
0x000000000001069c	175	      a = a >> 1;
=> 0x1069c <xbinGCD+104>:	sd	a0,-24(s0)
176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a0 <xbinGCD+108>:	lbu	a0,-72(s0)
0x00000000000106a4	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a4 <xbinGCD+112>:	andi	a0,a0,1
0x00000000000106a8	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a8 <xbinGCD+116>:	bnez	a0,0x106cc <xbinGCD+152>
0x00000000000106ac	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106ac <xbinGCD+120>:	j	0x106b0 <xbinGCD+124>
177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106b0 <xbinGCD+124>:	ld	a0,-72(s0)
0x00000000000106b4	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106b4 <xbinGCD+128>:	srli	a0,a0,0x1
0x00000000000106b8	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106b8 <xbinGCD+132>:	sd	a0,-72(s0)
0x00000000000106bc	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106bc <xbinGCD+136>:	ld	a0,-80(s0)
0x00000000000106c0	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106c0 <xbinGCD+140>:	srli	a0,a0,0x1
0x00000000000106c4	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106c4 <xbinGCD+144>:	sd	a0,-80(s0)
178	      }                               // u and v.
=> 0x106c8 <xbinGCD+148>:	j	0x10700 <xbinGCD+204>
174	   while (a > 0) {
=> 0x10700 <xbinGCD+204>:	j	0x10684 <xbinGCD+80>
0x0000000000010684	174	   while (a > 0) {
=> 0x10684 <xbinGCD+80>:	ld	a0,-24(s0)
0x0000000000010688	174	   while (a > 0) {
=> 0x10688 <xbinGCD+84>:	li	a1,0
0x000000000001068c	174	   while (a > 0) {
=> 0x1068c <xbinGCD+88>:	beq	a0,a1,0x10704 <xbinGCD+208>
0x0000000000010690	174	   while (a > 0) {
=> 0x10690 <xbinGCD+92>:	j	0x10694 <xbinGCD+96>
175	      a = a >> 1;
=> 0x10694 <xbinGCD+96>:	ld	a0,-24(s0)
0x0000000000010698	175	      a = a >> 1;
=> 0x10698 <xbinGCD+100>:	srli	a0,a0,0x1
0x000000000001069c	175	      a = a >> 1;
=> 0x1069c <xbinGCD+104>:	sd	a0,-24(s0)
176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a0 <xbinGCD+108>:	lbu	a0,-72(s0)
0x00000000000106a4	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a4 <xbinGCD+112>:	andi	a0,a0,1
0x00000000000106a8	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a8 <xbinGCD+116>:	bnez	a0,0x106cc <xbinGCD+152>
182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106cc <xbinGCD+152>:	ld	a0,-72(s0)
0x00000000000106d0	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106d0 <xbinGCD+156>:	ld	a1,-64(s0)
0x00000000000106d4	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106d4 <xbinGCD+160>:	xor	a2,a0,a1
0x00000000000106d8	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106d8 <xbinGCD+164>:	srli	a2,a2,0x1
0x00000000000106dc	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106dc <xbinGCD+168>:	and	a0,a0,a1
0x00000000000106e0	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106e0 <xbinGCD+172>:	add	a0,a2,a0
0x00000000000106e4	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106e4 <xbinGCD+176>:	sd	a0,-72(s0)
183	         v = (v >> 1) + alpha;
=> 0x106e8 <xbinGCD+180>:	ld	a0,-80(s0)
0x00000000000106ec	183	         v = (v >> 1) + alpha;
=> 0x106ec <xbinGCD+184>:	srli	a0,a0,0x1
0x00000000000106f0	183	         v = (v >> 1) + alpha;
=> 0x106f0 <xbinGCD+188>:	ld	a1,-56(s0)
0x00000000000106f4	183	         v = (v >> 1) + alpha;
=> 0x106f4 <xbinGCD+192>:	add	a0,a0,a1
0x00000000000106f8	183	         v = (v >> 1) + alpha;
=> 0x106f8 <xbinGCD+196>:	sd	a0,-80(s0)
0x00000000000106fc	183	         v = (v >> 1) + alpha;
=> 0x106fc <xbinGCD+200>:	j	0x10700 <xbinGCD+204>
174	   while (a > 0) {
=> 0x10700 <xbinGCD+204>:	j	0x10684 <xbinGCD+80>
0x0000000000010684	174	   while (a > 0) {
=> 0x10684 <xbinGCD+80>:	ld	a0,-24(s0)
0x0000000000010688	174	   while (a > 0) {
=> 0x10688 <xbinGCD+84>:	li	a1,0
0x000000000001068c	174	   while (a > 0) {
=> 0x1068c <xbinGCD+88>:	beq	a0,a1,0x10704 <xbinGCD+208>
0x0000000000010690	174	   while (a > 0) {
=> 0x10690 <xbinGCD+92>:	j	0x10694 <xbinGCD+96>
175	      a = a >> 1;
=> 0x10694 <xbinGCD+96>:	ld	a0,-24(s0)
0x0000000000010698	175	      a = a >> 1;
=> 0x10698 <xbinGCD+100>:	srli	a0,a0,0x1
0x000000000001069c	175	      a = a >> 1;
=> 0x1069c <xbinGCD+104>:	sd	a0,-24(s0)
176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a0 <xbinGCD+108>:	lbu	a0,-72(s0)
0x00000000000106a4	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a4 <xbinGCD+112>:	andi	a0,a0,1
0x00000000000106a8	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a8 <xbinGCD+116>:	bnez	a0,0x106cc <xbinGCD+152>
0x00000000000106ac	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106ac <xbinGCD+120>:	j	0x106b0 <xbinGCD+124>
177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106b0 <xbinGCD+124>:	ld	a0,-72(s0)
0x00000000000106b4	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106b4 <xbinGCD+128>:	srli	a0,a0,0x1
0x00000000000106b8	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106b8 <xbinGCD+132>:	sd	a0,-72(s0)
0x00000000000106bc	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106bc <xbinGCD+136>:	ld	a0,-80(s0)
0x00000000000106c0	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106c0 <xbinGCD+140>:	srli	a0,a0,0x1
0x00000000000106c4	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106c4 <xbinGCD+144>:	sd	a0,-80(s0)
178	      }                               // u and v.
=> 0x106c8 <xbinGCD+148>:	j	0x10700 <xbinGCD+204>
174	   while (a > 0) {
=> 0x10700 <xbinGCD+204>:	j	0x10684 <xbinGCD+80>
0x0000000000010684	174	   while (a > 0) {
=> 0x10684 <xbinGCD+80>:	ld	a0,-24(s0)
0x0000000000010688	174	   while (a > 0) {
=> 0x10688 <xbinGCD+84>:	li	a1,0
0x000000000001068c	174	   while (a > 0) {
=> 0x1068c <xbinGCD+88>:	beq	a0,a1,0x10704 <xbinGCD+208>
0x0000000000010690	174	   while (a > 0) {
=> 0x10690 <xbinGCD+92>:	j	0x10694 <xbinGCD+96>
175	      a = a >> 1;
=> 0x10694 <xbinGCD+96>:	ld	a0,-24(s0)
0x0000000000010698	175	      a = a >> 1;
=> 0x10698 <xbinGCD+100>:	srli	a0,a0,0x1
0x000000000001069c	175	      a = a >> 1;
=> 0x1069c <xbinGCD+104>:	sd	a0,-24(s0)
176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a0 <xbinGCD+108>:	lbu	a0,-72(s0)
0x00000000000106a4	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a4 <xbinGCD+112>:	andi	a0,a0,1
0x00000000000106a8	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a8 <xbinGCD+116>:	bnez	a0,0x106cc <xbinGCD+152>
182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106cc <xbinGCD+152>:	ld	a0,-72(s0)
0x00000000000106d0	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106d0 <xbinGCD+156>:	ld	a1,-64(s0)
0x00000000000106d4	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106d4 <xbinGCD+160>:	xor	a2,a0,a1
0x00000000000106d8	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106d8 <xbinGCD+164>:	srli	a2,a2,0x1
0x00000000000106dc	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106dc <xbinGCD+168>:	and	a0,a0,a1
0x00000000000106e0	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106e0 <xbinGCD+172>:	add	a0,a2,a0
0x00000000000106e4	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106e4 <xbinGCD+176>:	sd	a0,-72(s0)
183	         v = (v >> 1) + alpha;
=> 0x106e8 <xbinGCD+180>:	ld	a0,-80(s0)
0x00000000000106ec	183	         v = (v >> 1) + alpha;
=> 0x106ec <xbinGCD+184>:	srli	a0,a0,0x1
0x00000000000106f0	183	         v = (v >> 1) + alpha;
=> 0x106f0 <xbinGCD+188>:	ld	a1,-56(s0)
0x00000000000106f4	183	         v = (v >> 1) + alpha;
=> 0x106f4 <xbinGCD+192>:	add	a0,a0,a1
0x00000000000106f8	183	         v = (v >> 1) + alpha;
=> 0x106f8 <xbinGCD+196>:	sd	a0,-80(s0)
0x00000000000106fc	183	         v = (v >> 1) + alpha;
=> 0x106fc <xbinGCD+200>:	j	0x10700 <xbinGCD+204>
174	   while (a > 0) {
=> 0x10700 <xbinGCD+204>:	j	0x10684 <xbinGCD+80>
0x0000000000010684	174	   while (a > 0) {
=> 0x10684 <xbinGCD+80>:	ld	a0,-24(s0)
0x0000000000010688	174	   while (a > 0) {
=> 0x10688 <xbinGCD+84>:	li	a1,0
0x000000000001068c	174	   while (a > 0) {
=> 0x1068c <xbinGCD+88>:	beq	a0,a1,0x10704 <xbinGCD+208>
0x0000000000010690	174	   while (a > 0) {
=> 0x10690 <xbinGCD+92>:	j	0x10694 <xbinGCD+96>
175	      a = a >> 1;
=> 0x10694 <xbinGCD+96>:	ld	a0,-24(s0)
0x0000000000010698	175	      a = a >> 1;
=> 0x10698 <xbinGCD+100>:	srli	a0,a0,0x1
0x000000000001069c	175	      a = a >> 1;
=> 0x1069c <xbinGCD+104>:	sd	a0,-24(s0)
176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a0 <xbinGCD+108>:	lbu	a0,-72(s0)
0x00000000000106a4	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a4 <xbinGCD+112>:	andi	a0,a0,1
0x00000000000106a8	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a8 <xbinGCD+116>:	bnez	a0,0x106cc <xbinGCD+152>
0x00000000000106ac	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106ac <xbinGCD+120>:	j	0x106b0 <xbinGCD+124>
177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106b0 <xbinGCD+124>:	ld	a0,-72(s0)
0x00000000000106b4	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106b4 <xbinGCD+128>:	srli	a0,a0,0x1
0x00000000000106b8	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106b8 <xbinGCD+132>:	sd	a0,-72(s0)
0x00000000000106bc	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106bc <xbinGCD+136>:	ld	a0,-80(s0)
0x00000000000106c0	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106c0 <xbinGCD+140>:	srli	a0,a0,0x1
0x00000000000106c4	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106c4 <xbinGCD+144>:	sd	a0,-80(s0)
178	      }                               // u and v.
=> 0x106c8 <xbinGCD+148>:	j	0x10700 <xbinGCD+204>
174	   while (a > 0) {
=> 0x10700 <xbinGCD+204>:	j	0x10684 <xbinGCD+80>
0x0000000000010684	174	   while (a > 0) {
=> 0x10684 <xbinGCD+80>:	ld	a0,-24(s0)
0x0000000000010688	174	   while (a > 0) {
=> 0x10688 <xbinGCD+84>:	li	a1,0
0x000000000001068c	174	   while (a > 0) {
=> 0x1068c <xbinGCD+88>:	beq	a0,a1,0x10704 <xbinGCD+208>
0x0000000000010690	174	   while (a > 0) {
=> 0x10690 <xbinGCD+92>:	j	0x10694 <xbinGCD+96>
175	      a = a >> 1;
=> 0x10694 <xbinGCD+96>:	ld	a0,-24(s0)
0x0000000000010698	175	      a = a >> 1;
=> 0x10698 <xbinGCD+100>:	srli	a0,a0,0x1
0x000000000001069c	175	      a = a >> 1;
=> 0x1069c <xbinGCD+104>:	sd	a0,-24(s0)
176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a0 <xbinGCD+108>:	lbu	a0,-72(s0)
0x00000000000106a4	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a4 <xbinGCD+112>:	andi	a0,a0,1
0x00000000000106a8	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a8 <xbinGCD+116>:	bnez	a0,0x106cc <xbinGCD+152>
182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106cc <xbinGCD+152>:	ld	a0,-72(s0)
0x00000000000106d0	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106d0 <xbinGCD+156>:	ld	a1,-64(s0)
0x00000000000106d4	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106d4 <xbinGCD+160>:	xor	a2,a0,a1
0x00000000000106d8	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106d8 <xbinGCD+164>:	srli	a2,a2,0x1
0x00000000000106dc	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106dc <xbinGCD+168>:	and	a0,a0,a1
0x00000000000106e0	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106e0 <xbinGCD+172>:	add	a0,a2,a0
0x00000000000106e4	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106e4 <xbinGCD+176>:	sd	a0,-72(s0)
183	         v = (v >> 1) + alpha;
=> 0x106e8 <xbinGCD+180>:	ld	a0,-80(s0)
0x00000000000106ec	183	         v = (v >> 1) + alpha;
=> 0x106ec <xbinGCD+184>:	srli	a0,a0,0x1
0x00000000000106f0	183	         v = (v >> 1) + alpha;
=> 0x106f0 <xbinGCD+188>:	ld	a1,-56(s0)
0x00000000000106f4	183	         v = (v >> 1) + alpha;
=> 0x106f4 <xbinGCD+192>:	add	a0,a0,a1
0x00000000000106f8	183	         v = (v >> 1) + alpha;
=> 0x106f8 <xbinGCD+196>:	sd	a0,-80(s0)
0x00000000000106fc	183	         v = (v >> 1) + alpha;
=> 0x106fc <xbinGCD+200>:	j	0x10700 <xbinGCD+204>
174	   while (a > 0) {
=> 0x10700 <xbinGCD+204>:	j	0x10684 <xbinGCD+80>
0x0000000000010684	174	   while (a > 0) {
=> 0x10684 <xbinGCD+80>:	ld	a0,-24(s0)
0x0000000000010688	174	   while (a > 0) {
=> 0x10688 <xbinGCD+84>:	li	a1,0
0x000000000001068c	174	   while (a > 0) {
=> 0x1068c <xbinGCD+88>:	beq	a0,a1,0x10704 <xbinGCD+208>
0x0000000000010690	174	   while (a > 0) {
=> 0x10690 <xbinGCD+92>:	j	0x10694 <xbinGCD+96>
175	      a = a >> 1;
=> 0x10694 <xbinGCD+96>:	ld	a0,-24(s0)
0x0000000000010698	175	      a = a >> 1;
=> 0x10698 <xbinGCD+100>:	srli	a0,a0,0x1
0x000000000001069c	175	      a = a >> 1;
=> 0x1069c <xbinGCD+104>:	sd	a0,-24(s0)
176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a0 <xbinGCD+108>:	lbu	a0,-72(s0)
0x00000000000106a4	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a4 <xbinGCD+112>:	andi	a0,a0,1
0x00000000000106a8	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a8 <xbinGCD+116>:	bnez	a0,0x106cc <xbinGCD+152>
182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106cc <xbinGCD+152>:	ld	a0,-72(s0)
0x00000000000106d0	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106d0 <xbinGCD+156>:	ld	a1,-64(s0)
0x00000000000106d4	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106d4 <xbinGCD+160>:	xor	a2,a0,a1
0x00000000000106d8	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106d8 <xbinGCD+164>:	srli	a2,a2,0x1
0x00000000000106dc	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106dc <xbinGCD+168>:	and	a0,a0,a1
0x00000000000106e0	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106e0 <xbinGCD+172>:	add	a0,a2,a0
0x00000000000106e4	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106e4 <xbinGCD+176>:	sd	a0,-72(s0)
183	         v = (v >> 1) + alpha;
=> 0x106e8 <xbinGCD+180>:	ld	a0,-80(s0)
0x00000000000106ec	183	         v = (v >> 1) + alpha;
=> 0x106ec <xbinGCD+184>:	srli	a0,a0,0x1
0x00000000000106f0	183	         v = (v >> 1) + alpha;
=> 0x106f0 <xbinGCD+188>:	ld	a1,-56(s0)
0x00000000000106f4	183	         v = (v >> 1) + alpha;
=> 0x106f4 <xbinGCD+192>:	add	a0,a0,a1
0x00000000000106f8	183	         v = (v >> 1) + alpha;
=> 0x106f8 <xbinGCD+196>:	sd	a0,-80(s0)
0x00000000000106fc	183	         v = (v >> 1) + alpha;
=> 0x106fc <xbinGCD+200>:	j	0x10700 <xbinGCD+204>
174	   while (a > 0) {
=> 0x10700 <xbinGCD+204>:	j	0x10684 <xbinGCD+80>
0x0000000000010684	174	   while (a > 0) {
=> 0x10684 <xbinGCD+80>:	ld	a0,-24(s0)
0x0000000000010688	174	   while (a > 0) {
=> 0x10688 <xbinGCD+84>:	li	a1,0
0x000000000001068c	174	   while (a > 0) {
=> 0x1068c <xbinGCD+88>:	beq	a0,a1,0x10704 <xbinGCD+208>
0x0000000000010690	174	   while (a > 0) {
=> 0x10690 <xbinGCD+92>:	j	0x10694 <xbinGCD+96>
175	      a = a >> 1;
=> 0x10694 <xbinGCD+96>:	ld	a0,-24(s0)
0x0000000000010698	175	      a = a >> 1;
=> 0x10698 <xbinGCD+100>:	srli	a0,a0,0x1
0x000000000001069c	175	      a = a >> 1;
=> 0x1069c <xbinGCD+104>:	sd	a0,-24(s0)
176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a0 <xbinGCD+108>:	lbu	a0,-72(s0)
0x00000000000106a4	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a4 <xbinGCD+112>:	andi	a0,a0,1
0x00000000000106a8	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a8 <xbinGCD+116>:	bnez	a0,0x106cc <xbinGCD+152>
182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106cc <xbinGCD+152>:	ld	a0,-72(s0)
0x00000000000106d0	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106d0 <xbinGCD+156>:	ld	a1,-64(s0)
0x00000000000106d4	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106d4 <xbinGCD+160>:	xor	a2,a0,a1
0x00000000000106d8	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106d8 <xbinGCD+164>:	srli	a2,a2,0x1
0x00000000000106dc	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106dc <xbinGCD+168>:	and	a0,a0,a1
0x00000000000106e0	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106e0 <xbinGCD+172>:	add	a0,a2,a0
0x00000000000106e4	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106e4 <xbinGCD+176>:	sd	a0,-72(s0)
183	         v = (v >> 1) + alpha;
=> 0x106e8 <xbinGCD+180>:	ld	a0,-80(s0)
0x00000000000106ec	183	         v = (v >> 1) + alpha;
=> 0x106ec <xbinGCD+184>:	srli	a0,a0,0x1
0x00000000000106f0	183	         v = (v >> 1) + alpha;
=> 0x106f0 <xbinGCD+188>:	ld	a1,-56(s0)
0x00000000000106f4	183	         v = (v >> 1) + alpha;
=> 0x106f4 <xbinGCD+192>:	add	a0,a0,a1
0x00000000000106f8	183	         v = (v >> 1) + alpha;
=> 0x106f8 <xbinGCD+196>:	sd	a0,-80(s0)
0x00000000000106fc	183	         v = (v >> 1) + alpha;
=> 0x106fc <xbinGCD+200>:	j	0x10700 <xbinGCD+204>
174	   while (a > 0) {
=> 0x10700 <xbinGCD+204>:	j	0x10684 <xbinGCD+80>
0x0000000000010684	174	   while (a > 0) {
=> 0x10684 <xbinGCD+80>:	ld	a0,-24(s0)
0x0000000000010688	174	   while (a > 0) {
=> 0x10688 <xbinGCD+84>:	li	a1,0
0x000000000001068c	174	   while (a > 0) {
=> 0x1068c <xbinGCD+88>:	beq	a0,a1,0x10704 <xbinGCD+208>
0x0000000000010690	174	   while (a > 0) {
=> 0x10690 <xbinGCD+92>:	j	0x10694 <xbinGCD+96>
175	      a = a >> 1;
=> 0x10694 <xbinGCD+96>:	ld	a0,-24(s0)
0x0000000000010698	175	      a = a >> 1;
=> 0x10698 <xbinGCD+100>:	srli	a0,a0,0x1
0x000000000001069c	175	      a = a >> 1;
=> 0x1069c <xbinGCD+104>:	sd	a0,-24(s0)
176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a0 <xbinGCD+108>:	lbu	a0,-72(s0)
0x00000000000106a4	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a4 <xbinGCD+112>:	andi	a0,a0,1
0x00000000000106a8	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a8 <xbinGCD+116>:	bnez	a0,0x106cc <xbinGCD+152>
182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106cc <xbinGCD+152>:	ld	a0,-72(s0)
0x00000000000106d0	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106d0 <xbinGCD+156>:	ld	a1,-64(s0)
0x00000000000106d4	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106d4 <xbinGCD+160>:	xor	a2,a0,a1
0x00000000000106d8	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106d8 <xbinGCD+164>:	srli	a2,a2,0x1
0x00000000000106dc	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106dc <xbinGCD+168>:	and	a0,a0,a1
0x00000000000106e0	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106e0 <xbinGCD+172>:	add	a0,a2,a0
0x00000000000106e4	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106e4 <xbinGCD+176>:	sd	a0,-72(s0)
183	         v = (v >> 1) + alpha;
=> 0x106e8 <xbinGCD+180>:	ld	a0,-80(s0)
0x00000000000106ec	183	         v = (v >> 1) + alpha;
=> 0x106ec <xbinGCD+184>:	srli	a0,a0,0x1
0x00000000000106f0	183	         v = (v >> 1) + alpha;
=> 0x106f0 <xbinGCD+188>:	ld	a1,-56(s0)
0x00000000000106f4	183	         v = (v >> 1) + alpha;
=> 0x106f4 <xbinGCD+192>:	add	a0,a0,a1
0x00000000000106f8	183	         v = (v >> 1) + alpha;
=> 0x106f8 <xbinGCD+196>:	sd	a0,-80(s0)
0x00000000000106fc	183	         v = (v >> 1) + alpha;
=> 0x106fc <xbinGCD+200>:	j	0x10700 <xbinGCD+204>
174	   while (a > 0) {
=> 0x10700 <xbinGCD+204>:	j	0x10684 <xbinGCD+80>
0x0000000000010684	174	   while (a > 0) {
=> 0x10684 <xbinGCD+80>:	ld	a0,-24(s0)
0x0000000000010688	174	   while (a > 0) {
=> 0x10688 <xbinGCD+84>:	li	a1,0
0x000000000001068c	174	   while (a > 0) {
=> 0x1068c <xbinGCD+88>:	beq	a0,a1,0x10704 <xbinGCD+208>
0x0000000000010690	174	   while (a > 0) {
=> 0x10690 <xbinGCD+92>:	j	0x10694 <xbinGCD+96>
175	      a = a >> 1;
=> 0x10694 <xbinGCD+96>:	ld	a0,-24(s0)
0x0000000000010698	175	      a = a >> 1;
=> 0x10698 <xbinGCD+100>:	srli	a0,a0,0x1
0x000000000001069c	175	      a = a >> 1;
=> 0x1069c <xbinGCD+104>:	sd	a0,-24(s0)
176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a0 <xbinGCD+108>:	lbu	a0,-72(s0)
0x00000000000106a4	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a4 <xbinGCD+112>:	andi	a0,a0,1
0x00000000000106a8	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a8 <xbinGCD+116>:	bnez	a0,0x106cc <xbinGCD+152>
182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106cc <xbinGCD+152>:	ld	a0,-72(s0)
0x00000000000106d0	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106d0 <xbinGCD+156>:	ld	a1,-64(s0)
0x00000000000106d4	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106d4 <xbinGCD+160>:	xor	a2,a0,a1
0x00000000000106d8	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106d8 <xbinGCD+164>:	srli	a2,a2,0x1
0x00000000000106dc	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106dc <xbinGCD+168>:	and	a0,a0,a1
0x00000000000106e0	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106e0 <xbinGCD+172>:	add	a0,a2,a0
0x00000000000106e4	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106e4 <xbinGCD+176>:	sd	a0,-72(s0)
183	         v = (v >> 1) + alpha;
=> 0x106e8 <xbinGCD+180>:	ld	a0,-80(s0)
0x00000000000106ec	183	         v = (v >> 1) + alpha;
=> 0x106ec <xbinGCD+184>:	srli	a0,a0,0x1
0x00000000000106f0	183	         v = (v >> 1) + alpha;
=> 0x106f0 <xbinGCD+188>:	ld	a1,-56(s0)
0x00000000000106f4	183	         v = (v >> 1) + alpha;
=> 0x106f4 <xbinGCD+192>:	add	a0,a0,a1
0x00000000000106f8	183	         v = (v >> 1) + alpha;
=> 0x106f8 <xbinGCD+196>:	sd	a0,-80(s0)
0x00000000000106fc	183	         v = (v >> 1) + alpha;
=> 0x106fc <xbinGCD+200>:	j	0x10700 <xbinGCD+204>
174	   while (a > 0) {
=> 0x10700 <xbinGCD+204>:	j	0x10684 <xbinGCD+80>
0x0000000000010684	174	   while (a > 0) {
=> 0x10684 <xbinGCD+80>:	ld	a0,-24(s0)
0x0000000000010688	174	   while (a > 0) {
=> 0x10688 <xbinGCD+84>:	li	a1,0
0x000000000001068c	174	   while (a > 0) {
=> 0x1068c <xbinGCD+88>:	beq	a0,a1,0x10704 <xbinGCD+208>
0x0000000000010690	174	   while (a > 0) {
=> 0x10690 <xbinGCD+92>:	j	0x10694 <xbinGCD+96>
175	      a = a >> 1;
=> 0x10694 <xbinGCD+96>:	ld	a0,-24(s0)
0x0000000000010698	175	      a = a >> 1;
=> 0x10698 <xbinGCD+100>:	srli	a0,a0,0x1
0x000000000001069c	175	      a = a >> 1;
=> 0x1069c <xbinGCD+104>:	sd	a0,-24(s0)
176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a0 <xbinGCD+108>:	lbu	a0,-72(s0)
0x00000000000106a4	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a4 <xbinGCD+112>:	andi	a0,a0,1
0x00000000000106a8	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a8 <xbinGCD+116>:	bnez	a0,0x106cc <xbinGCD+152>
0x00000000000106ac	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106ac <xbinGCD+120>:	j	0x106b0 <xbinGCD+124>
177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106b0 <xbinGCD+124>:	ld	a0,-72(s0)
0x00000000000106b4	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106b4 <xbinGCD+128>:	srli	a0,a0,0x1
0x00000000000106b8	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106b8 <xbinGCD+132>:	sd	a0,-72(s0)
0x00000000000106bc	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106bc <xbinGCD+136>:	ld	a0,-80(s0)
0x00000000000106c0	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106c0 <xbinGCD+140>:	srli	a0,a0,0x1
0x00000000000106c4	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106c4 <xbinGCD+144>:	sd	a0,-80(s0)
178	      }                               // u and v.
=> 0x106c8 <xbinGCD+148>:	j	0x10700 <xbinGCD+204>
174	   while (a > 0) {
=> 0x10700 <xbinGCD+204>:	j	0x10684 <xbinGCD+80>
0x0000000000010684	174	   while (a > 0) {
=> 0x10684 <xbinGCD+80>:	ld	a0,-24(s0)
0x0000000000010688	174	   while (a > 0) {
=> 0x10688 <xbinGCD+84>:	li	a1,0
0x000000000001068c	174	   while (a > 0) {
=> 0x1068c <xbinGCD+88>:	beq	a0,a1,0x10704 <xbinGCD+208>
0x0000000000010690	174	   while (a > 0) {
=> 0x10690 <xbinGCD+92>:	j	0x10694 <xbinGCD+96>
175	      a = a >> 1;
=> 0x10694 <xbinGCD+96>:	ld	a0,-24(s0)
0x0000000000010698	175	      a = a >> 1;
=> 0x10698 <xbinGCD+100>:	srli	a0,a0,0x1
0x000000000001069c	175	      a = a >> 1;
=> 0x1069c <xbinGCD+104>:	sd	a0,-24(s0)
176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a0 <xbinGCD+108>:	lbu	a0,-72(s0)
0x00000000000106a4	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a4 <xbinGCD+112>:	andi	a0,a0,1
0x00000000000106a8	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a8 <xbinGCD+116>:	bnez	a0,0x106cc <xbinGCD+152>
182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106cc <xbinGCD+152>:	ld	a0,-72(s0)
0x00000000000106d0	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106d0 <xbinGCD+156>:	ld	a1,-64(s0)
0x00000000000106d4	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106d4 <xbinGCD+160>:	xor	a2,a0,a1
0x00000000000106d8	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106d8 <xbinGCD+164>:	srli	a2,a2,0x1
0x00000000000106dc	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106dc <xbinGCD+168>:	and	a0,a0,a1
0x00000000000106e0	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106e0 <xbinGCD+172>:	add	a0,a2,a0
0x00000000000106e4	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106e4 <xbinGCD+176>:	sd	a0,-72(s0)
183	         v = (v >> 1) + alpha;
=> 0x106e8 <xbinGCD+180>:	ld	a0,-80(s0)
0x00000000000106ec	183	         v = (v >> 1) + alpha;
=> 0x106ec <xbinGCD+184>:	srli	a0,a0,0x1
0x00000000000106f0	183	         v = (v >> 1) + alpha;
=> 0x106f0 <xbinGCD+188>:	ld	a1,-56(s0)
0x00000000000106f4	183	         v = (v >> 1) + alpha;
=> 0x106f4 <xbinGCD+192>:	add	a0,a0,a1
0x00000000000106f8	183	         v = (v >> 1) + alpha;
=> 0x106f8 <xbinGCD+196>:	sd	a0,-80(s0)
0x00000000000106fc	183	         v = (v >> 1) + alpha;
=> 0x106fc <xbinGCD+200>:	j	0x10700 <xbinGCD+204>
174	   while (a > 0) {
=> 0x10700 <xbinGCD+204>:	j	0x10684 <xbinGCD+80>
0x0000000000010684	174	   while (a > 0) {
=> 0x10684 <xbinGCD+80>:	ld	a0,-24(s0)
0x0000000000010688	174	   while (a > 0) {
=> 0x10688 <xbinGCD+84>:	li	a1,0
0x000000000001068c	174	   while (a > 0) {
=> 0x1068c <xbinGCD+88>:	beq	a0,a1,0x10704 <xbinGCD+208>
0x0000000000010690	174	   while (a > 0) {
=> 0x10690 <xbinGCD+92>:	j	0x10694 <xbinGCD+96>
175	      a = a >> 1;
=> 0x10694 <xbinGCD+96>:	ld	a0,-24(s0)
0x0000000000010698	175	      a = a >> 1;
=> 0x10698 <xbinGCD+100>:	srli	a0,a0,0x1
0x000000000001069c	175	      a = a >> 1;
=> 0x1069c <xbinGCD+104>:	sd	a0,-24(s0)
176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a0 <xbinGCD+108>:	lbu	a0,-72(s0)
0x00000000000106a4	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a4 <xbinGCD+112>:	andi	a0,a0,1
0x00000000000106a8	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a8 <xbinGCD+116>:	bnez	a0,0x106cc <xbinGCD+152>
0x00000000000106ac	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106ac <xbinGCD+120>:	j	0x106b0 <xbinGCD+124>
177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106b0 <xbinGCD+124>:	ld	a0,-72(s0)
0x00000000000106b4	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106b4 <xbinGCD+128>:	srli	a0,a0,0x1
0x00000000000106b8	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106b8 <xbinGCD+132>:	sd	a0,-72(s0)
0x00000000000106bc	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106bc <xbinGCD+136>:	ld	a0,-80(s0)
0x00000000000106c0	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106c0 <xbinGCD+140>:	srli	a0,a0,0x1
0x00000000000106c4	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106c4 <xbinGCD+144>:	sd	a0,-80(s0)
178	      }                               // u and v.
=> 0x106c8 <xbinGCD+148>:	j	0x10700 <xbinGCD+204>
174	   while (a > 0) {
=> 0x10700 <xbinGCD+204>:	j	0x10684 <xbinGCD+80>
0x0000000000010684	174	   while (a > 0) {
=> 0x10684 <xbinGCD+80>:	ld	a0,-24(s0)
0x0000000000010688	174	   while (a > 0) {
=> 0x10688 <xbinGCD+84>:	li	a1,0
0x000000000001068c	174	   while (a > 0) {
=> 0x1068c <xbinGCD+88>:	beq	a0,a1,0x10704 <xbinGCD+208>
0x0000000000010690	174	   while (a > 0) {
=> 0x10690 <xbinGCD+92>:	j	0x10694 <xbinGCD+96>
175	      a = a >> 1;
=> 0x10694 <xbinGCD+96>:	ld	a0,-24(s0)
0x0000000000010698	175	      a = a >> 1;
=> 0x10698 <xbinGCD+100>:	srli	a0,a0,0x1
0x000000000001069c	175	      a = a >> 1;
=> 0x1069c <xbinGCD+104>:	sd	a0,-24(s0)
176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a0 <xbinGCD+108>:	lbu	a0,-72(s0)
0x00000000000106a4	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a4 <xbinGCD+112>:	andi	a0,a0,1
0x00000000000106a8	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a8 <xbinGCD+116>:	bnez	a0,0x106cc <xbinGCD+152>
182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106cc <xbinGCD+152>:	ld	a0,-72(s0)
0x00000000000106d0	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106d0 <xbinGCD+156>:	ld	a1,-64(s0)
0x00000000000106d4	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106d4 <xbinGCD+160>:	xor	a2,a0,a1
0x00000000000106d8	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106d8 <xbinGCD+164>:	srli	a2,a2,0x1
0x00000000000106dc	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106dc <xbinGCD+168>:	and	a0,a0,a1
0x00000000000106e0	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106e0 <xbinGCD+172>:	add	a0,a2,a0
0x00000000000106e4	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106e4 <xbinGCD+176>:	sd	a0,-72(s0)
183	         v = (v >> 1) + alpha;
=> 0x106e8 <xbinGCD+180>:	ld	a0,-80(s0)
0x00000000000106ec	183	         v = (v >> 1) + alpha;
=> 0x106ec <xbinGCD+184>:	srli	a0,a0,0x1
0x00000000000106f0	183	         v = (v >> 1) + alpha;
=> 0x106f0 <xbinGCD+188>:	ld	a1,-56(s0)
0x00000000000106f4	183	         v = (v >> 1) + alpha;
=> 0x106f4 <xbinGCD+192>:	add	a0,a0,a1
0x00000000000106f8	183	         v = (v >> 1) + alpha;
=> 0x106f8 <xbinGCD+196>:	sd	a0,-80(s0)
0x00000000000106fc	183	         v = (v >> 1) + alpha;
=> 0x106fc <xbinGCD+200>:	j	0x10700 <xbinGCD+204>
174	   while (a > 0) {
=> 0x10700 <xbinGCD+204>:	j	0x10684 <xbinGCD+80>
0x0000000000010684	174	   while (a > 0) {
=> 0x10684 <xbinGCD+80>:	ld	a0,-24(s0)
0x0000000000010688	174	   while (a > 0) {
=> 0x10688 <xbinGCD+84>:	li	a1,0
0x000000000001068c	174	   while (a > 0) {
=> 0x1068c <xbinGCD+88>:	beq	a0,a1,0x10704 <xbinGCD+208>
0x0000000000010690	174	   while (a > 0) {
=> 0x10690 <xbinGCD+92>:	j	0x10694 <xbinGCD+96>
175	      a = a >> 1;
=> 0x10694 <xbinGCD+96>:	ld	a0,-24(s0)
0x0000000000010698	175	      a = a >> 1;
=> 0x10698 <xbinGCD+100>:	srli	a0,a0,0x1
0x000000000001069c	175	      a = a >> 1;
=> 0x1069c <xbinGCD+104>:	sd	a0,-24(s0)
176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a0 <xbinGCD+108>:	lbu	a0,-72(s0)
0x00000000000106a4	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a4 <xbinGCD+112>:	andi	a0,a0,1
0x00000000000106a8	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a8 <xbinGCD+116>:	bnez	a0,0x106cc <xbinGCD+152>
0x00000000000106ac	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106ac <xbinGCD+120>:	j	0x106b0 <xbinGCD+124>
177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106b0 <xbinGCD+124>:	ld	a0,-72(s0)
0x00000000000106b4	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106b4 <xbinGCD+128>:	srli	a0,a0,0x1
0x00000000000106b8	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106b8 <xbinGCD+132>:	sd	a0,-72(s0)
0x00000000000106bc	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106bc <xbinGCD+136>:	ld	a0,-80(s0)
0x00000000000106c0	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106c0 <xbinGCD+140>:	srli	a0,a0,0x1
0x00000000000106c4	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106c4 <xbinGCD+144>:	sd	a0,-80(s0)
178	      }                               // u and v.
=> 0x106c8 <xbinGCD+148>:	j	0x10700 <xbinGCD+204>
174	   while (a > 0) {
=> 0x10700 <xbinGCD+204>:	j	0x10684 <xbinGCD+80>
0x0000000000010684	174	   while (a > 0) {
=> 0x10684 <xbinGCD+80>:	ld	a0,-24(s0)
0x0000000000010688	174	   while (a > 0) {
=> 0x10688 <xbinGCD+84>:	li	a1,0
0x000000000001068c	174	   while (a > 0) {
=> 0x1068c <xbinGCD+88>:	beq	a0,a1,0x10704 <xbinGCD+208>
0x0000000000010690	174	   while (a > 0) {
=> 0x10690 <xbinGCD+92>:	j	0x10694 <xbinGCD+96>
175	      a = a >> 1;
=> 0x10694 <xbinGCD+96>:	ld	a0,-24(s0)
0x0000000000010698	175	      a = a >> 1;
=> 0x10698 <xbinGCD+100>:	srli	a0,a0,0x1
0x000000000001069c	175	      a = a >> 1;
=> 0x1069c <xbinGCD+104>:	sd	a0,-24(s0)
176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a0 <xbinGCD+108>:	lbu	a0,-72(s0)
0x00000000000106a4	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a4 <xbinGCD+112>:	andi	a0,a0,1
0x00000000000106a8	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a8 <xbinGCD+116>:	bnez	a0,0x106cc <xbinGCD+152>
0x00000000000106ac	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106ac <xbinGCD+120>:	j	0x106b0 <xbinGCD+124>
177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106b0 <xbinGCD+124>:	ld	a0,-72(s0)
0x00000000000106b4	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106b4 <xbinGCD+128>:	srli	a0,a0,0x1
0x00000000000106b8	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106b8 <xbinGCD+132>:	sd	a0,-72(s0)
0x00000000000106bc	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106bc <xbinGCD+136>:	ld	a0,-80(s0)
0x00000000000106c0	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106c0 <xbinGCD+140>:	srli	a0,a0,0x1
0x00000000000106c4	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106c4 <xbinGCD+144>:	sd	a0,-80(s0)
178	      }                               // u and v.
=> 0x106c8 <xbinGCD+148>:	j	0x10700 <xbinGCD+204>
174	   while (a > 0) {
=> 0x10700 <xbinGCD+204>:	j	0x10684 <xbinGCD+80>
0x0000000000010684	174	   while (a > 0) {
=> 0x10684 <xbinGCD+80>:	ld	a0,-24(s0)
0x0000000000010688	174	   while (a > 0) {
=> 0x10688 <xbinGCD+84>:	li	a1,0
0x000000000001068c	174	   while (a > 0) {
=> 0x1068c <xbinGCD+88>:	beq	a0,a1,0x10704 <xbinGCD+208>
0x0000000000010690	174	   while (a > 0) {
=> 0x10690 <xbinGCD+92>:	j	0x10694 <xbinGCD+96>
175	      a = a >> 1;
=> 0x10694 <xbinGCD+96>:	ld	a0,-24(s0)
0x0000000000010698	175	      a = a >> 1;
=> 0x10698 <xbinGCD+100>:	srli	a0,a0,0x1
0x000000000001069c	175	      a = a >> 1;
=> 0x1069c <xbinGCD+104>:	sd	a0,-24(s0)
176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a0 <xbinGCD+108>:	lbu	a0,-72(s0)
0x00000000000106a4	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a4 <xbinGCD+112>:	andi	a0,a0,1
0x00000000000106a8	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a8 <xbinGCD+116>:	bnez	a0,0x106cc <xbinGCD+152>
0x00000000000106ac	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106ac <xbinGCD+120>:	j	0x106b0 <xbinGCD+124>
177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106b0 <xbinGCD+124>:	ld	a0,-72(s0)
0x00000000000106b4	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106b4 <xbinGCD+128>:	srli	a0,a0,0x1
0x00000000000106b8	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106b8 <xbinGCD+132>:	sd	a0,-72(s0)
0x00000000000106bc	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106bc <xbinGCD+136>:	ld	a0,-80(s0)
0x00000000000106c0	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106c0 <xbinGCD+140>:	srli	a0,a0,0x1
0x00000000000106c4	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106c4 <xbinGCD+144>:	sd	a0,-80(s0)
178	      }                               // u and v.
=> 0x106c8 <xbinGCD+148>:	j	0x10700 <xbinGCD+204>
174	   while (a > 0) {
=> 0x10700 <xbinGCD+204>:	j	0x10684 <xbinGCD+80>
0x0000000000010684	174	   while (a > 0) {
=> 0x10684 <xbinGCD+80>:	ld	a0,-24(s0)
0x0000000000010688	174	   while (a > 0) {
=> 0x10688 <xbinGCD+84>:	li	a1,0
0x000000000001068c	174	   while (a > 0) {
=> 0x1068c <xbinGCD+88>:	beq	a0,a1,0x10704 <xbinGCD+208>
0x0000000000010690	174	   while (a > 0) {
=> 0x10690 <xbinGCD+92>:	j	0x10694 <xbinGCD+96>
175	      a = a >> 1;
=> 0x10694 <xbinGCD+96>:	ld	a0,-24(s0)
0x0000000000010698	175	      a = a >> 1;
=> 0x10698 <xbinGCD+100>:	srli	a0,a0,0x1
0x000000000001069c	175	      a = a >> 1;
=> 0x1069c <xbinGCD+104>:	sd	a0,-24(s0)
176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a0 <xbinGCD+108>:	lbu	a0,-72(s0)
0x00000000000106a4	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a4 <xbinGCD+112>:	andi	a0,a0,1
0x00000000000106a8	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a8 <xbinGCD+116>:	bnez	a0,0x106cc <xbinGCD+152>
0x00000000000106ac	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106ac <xbinGCD+120>:	j	0x106b0 <xbinGCD+124>
177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106b0 <xbinGCD+124>:	ld	a0,-72(s0)
0x00000000000106b4	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106b4 <xbinGCD+128>:	srli	a0,a0,0x1
0x00000000000106b8	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106b8 <xbinGCD+132>:	sd	a0,-72(s0)
0x00000000000106bc	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106bc <xbinGCD+136>:	ld	a0,-80(s0)
0x00000000000106c0	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106c0 <xbinGCD+140>:	srli	a0,a0,0x1
0x00000000000106c4	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106c4 <xbinGCD+144>:	sd	a0,-80(s0)
178	      }                               // u and v.
=> 0x106c8 <xbinGCD+148>:	j	0x10700 <xbinGCD+204>
174	   while (a > 0) {
=> 0x10700 <xbinGCD+204>:	j	0x10684 <xbinGCD+80>
0x0000000000010684	174	   while (a > 0) {
=> 0x10684 <xbinGCD+80>:	ld	a0,-24(s0)
0x0000000000010688	174	   while (a > 0) {
=> 0x10688 <xbinGCD+84>:	li	a1,0
0x000000000001068c	174	   while (a > 0) {
=> 0x1068c <xbinGCD+88>:	beq	a0,a1,0x10704 <xbinGCD+208>
0x0000000000010690	174	   while (a > 0) {
=> 0x10690 <xbinGCD+92>:	j	0x10694 <xbinGCD+96>
175	      a = a >> 1;
=> 0x10694 <xbinGCD+96>:	ld	a0,-24(s0)
0x0000000000010698	175	      a = a >> 1;
=> 0x10698 <xbinGCD+100>:	srli	a0,a0,0x1
0x000000000001069c	175	      a = a >> 1;
=> 0x1069c <xbinGCD+104>:	sd	a0,-24(s0)
176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a0 <xbinGCD+108>:	lbu	a0,-72(s0)
0x00000000000106a4	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a4 <xbinGCD+112>:	andi	a0,a0,1
0x00000000000106a8	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a8 <xbinGCD+116>:	bnez	a0,0x106cc <xbinGCD+152>
0x00000000000106ac	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106ac <xbinGCD+120>:	j	0x106b0 <xbinGCD+124>
177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106b0 <xbinGCD+124>:	ld	a0,-72(s0)
0x00000000000106b4	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106b4 <xbinGCD+128>:	srli	a0,a0,0x1
0x00000000000106b8	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106b8 <xbinGCD+132>:	sd	a0,-72(s0)
0x00000000000106bc	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106bc <xbinGCD+136>:	ld	a0,-80(s0)
0x00000000000106c0	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106c0 <xbinGCD+140>:	srli	a0,a0,0x1
0x00000000000106c4	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106c4 <xbinGCD+144>:	sd	a0,-80(s0)
178	      }                               // u and v.
=> 0x106c8 <xbinGCD+148>:	j	0x10700 <xbinGCD+204>
174	   while (a > 0) {
=> 0x10700 <xbinGCD+204>:	j	0x10684 <xbinGCD+80>
0x0000000000010684	174	   while (a > 0) {
=> 0x10684 <xbinGCD+80>:	ld	a0,-24(s0)
0x0000000000010688	174	   while (a > 0) {
=> 0x10688 <xbinGCD+84>:	li	a1,0
0x000000000001068c	174	   while (a > 0) {
=> 0x1068c <xbinGCD+88>:	beq	a0,a1,0x10704 <xbinGCD+208>
0x0000000000010690	174	   while (a > 0) {
=> 0x10690 <xbinGCD+92>:	j	0x10694 <xbinGCD+96>
175	      a = a >> 1;
=> 0x10694 <xbinGCD+96>:	ld	a0,-24(s0)
0x0000000000010698	175	      a = a >> 1;
=> 0x10698 <xbinGCD+100>:	srli	a0,a0,0x1
0x000000000001069c	175	      a = a >> 1;
=> 0x1069c <xbinGCD+104>:	sd	a0,-24(s0)
176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a0 <xbinGCD+108>:	lbu	a0,-72(s0)
0x00000000000106a4	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a4 <xbinGCD+112>:	andi	a0,a0,1
0x00000000000106a8	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a8 <xbinGCD+116>:	bnez	a0,0x106cc <xbinGCD+152>
0x00000000000106ac	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106ac <xbinGCD+120>:	j	0x106b0 <xbinGCD+124>
177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106b0 <xbinGCD+124>:	ld	a0,-72(s0)
0x00000000000106b4	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106b4 <xbinGCD+128>:	srli	a0,a0,0x1
0x00000000000106b8	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106b8 <xbinGCD+132>:	sd	a0,-72(s0)
0x00000000000106bc	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106bc <xbinGCD+136>:	ld	a0,-80(s0)
0x00000000000106c0	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106c0 <xbinGCD+140>:	srli	a0,a0,0x1
0x00000000000106c4	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106c4 <xbinGCD+144>:	sd	a0,-80(s0)
178	      }                               // u and v.
=> 0x106c8 <xbinGCD+148>:	j	0x10700 <xbinGCD+204>
174	   while (a > 0) {
=> 0x10700 <xbinGCD+204>:	j	0x10684 <xbinGCD+80>
0x0000000000010684	174	   while (a > 0) {
=> 0x10684 <xbinGCD+80>:	ld	a0,-24(s0)
0x0000000000010688	174	   while (a > 0) {
=> 0x10688 <xbinGCD+84>:	li	a1,0
0x000000000001068c	174	   while (a > 0) {
=> 0x1068c <xbinGCD+88>:	beq	a0,a1,0x10704 <xbinGCD+208>
0x0000000000010690	174	   while (a > 0) {
=> 0x10690 <xbinGCD+92>:	j	0x10694 <xbinGCD+96>
175	      a = a >> 1;
=> 0x10694 <xbinGCD+96>:	ld	a0,-24(s0)
0x0000000000010698	175	      a = a >> 1;
=> 0x10698 <xbinGCD+100>:	srli	a0,a0,0x1
0x000000000001069c	175	      a = a >> 1;
=> 0x1069c <xbinGCD+104>:	sd	a0,-24(s0)
176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a0 <xbinGCD+108>:	lbu	a0,-72(s0)
0x00000000000106a4	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a4 <xbinGCD+112>:	andi	a0,a0,1
0x00000000000106a8	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a8 <xbinGCD+116>:	bnez	a0,0x106cc <xbinGCD+152>
0x00000000000106ac	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106ac <xbinGCD+120>:	j	0x106b0 <xbinGCD+124>
177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106b0 <xbinGCD+124>:	ld	a0,-72(s0)
0x00000000000106b4	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106b4 <xbinGCD+128>:	srli	a0,a0,0x1
0x00000000000106b8	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106b8 <xbinGCD+132>:	sd	a0,-72(s0)
0x00000000000106bc	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106bc <xbinGCD+136>:	ld	a0,-80(s0)
0x00000000000106c0	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106c0 <xbinGCD+140>:	srli	a0,a0,0x1
0x00000000000106c4	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106c4 <xbinGCD+144>:	sd	a0,-80(s0)
178	      }                               // u and v.
=> 0x106c8 <xbinGCD+148>:	j	0x10700 <xbinGCD+204>
174	   while (a > 0) {
=> 0x10700 <xbinGCD+204>:	j	0x10684 <xbinGCD+80>
0x0000000000010684	174	   while (a > 0) {
=> 0x10684 <xbinGCD+80>:	ld	a0,-24(s0)
0x0000000000010688	174	   while (a > 0) {
=> 0x10688 <xbinGCD+84>:	li	a1,0
0x000000000001068c	174	   while (a > 0) {
=> 0x1068c <xbinGCD+88>:	beq	a0,a1,0x10704 <xbinGCD+208>
0x0000000000010690	174	   while (a > 0) {
=> 0x10690 <xbinGCD+92>:	j	0x10694 <xbinGCD+96>
175	      a = a >> 1;
=> 0x10694 <xbinGCD+96>:	ld	a0,-24(s0)
0x0000000000010698	175	      a = a >> 1;
=> 0x10698 <xbinGCD+100>:	srli	a0,a0,0x1
0x000000000001069c	175	      a = a >> 1;
=> 0x1069c <xbinGCD+104>:	sd	a0,-24(s0)
176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a0 <xbinGCD+108>:	lbu	a0,-72(s0)
0x00000000000106a4	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a4 <xbinGCD+112>:	andi	a0,a0,1
0x00000000000106a8	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a8 <xbinGCD+116>:	bnez	a0,0x106cc <xbinGCD+152>
182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106cc <xbinGCD+152>:	ld	a0,-72(s0)
0x00000000000106d0	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106d0 <xbinGCD+156>:	ld	a1,-64(s0)
0x00000000000106d4	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106d4 <xbinGCD+160>:	xor	a2,a0,a1
0x00000000000106d8	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106d8 <xbinGCD+164>:	srli	a2,a2,0x1
0x00000000000106dc	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106dc <xbinGCD+168>:	and	a0,a0,a1
0x00000000000106e0	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106e0 <xbinGCD+172>:	add	a0,a2,a0
0x00000000000106e4	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106e4 <xbinGCD+176>:	sd	a0,-72(s0)
183	         v = (v >> 1) + alpha;
=> 0x106e8 <xbinGCD+180>:	ld	a0,-80(s0)
0x00000000000106ec	183	         v = (v >> 1) + alpha;
=> 0x106ec <xbinGCD+184>:	srli	a0,a0,0x1
0x00000000000106f0	183	         v = (v >> 1) + alpha;
=> 0x106f0 <xbinGCD+188>:	ld	a1,-56(s0)
0x00000000000106f4	183	         v = (v >> 1) + alpha;
=> 0x106f4 <xbinGCD+192>:	add	a0,a0,a1
0x00000000000106f8	183	         v = (v >> 1) + alpha;
=> 0x106f8 <xbinGCD+196>:	sd	a0,-80(s0)
0x00000000000106fc	183	         v = (v >> 1) + alpha;
=> 0x106fc <xbinGCD+200>:	j	0x10700 <xbinGCD+204>
174	   while (a > 0) {
=> 0x10700 <xbinGCD+204>:	j	0x10684 <xbinGCD+80>
0x0000000000010684	174	   while (a > 0) {
=> 0x10684 <xbinGCD+80>:	ld	a0,-24(s0)
0x0000000000010688	174	   while (a > 0) {
=> 0x10688 <xbinGCD+84>:	li	a1,0
0x000000000001068c	174	   while (a > 0) {
=> 0x1068c <xbinGCD+88>:	beq	a0,a1,0x10704 <xbinGCD+208>
0x0000000000010690	174	   while (a > 0) {
=> 0x10690 <xbinGCD+92>:	j	0x10694 <xbinGCD+96>
175	      a = a >> 1;
=> 0x10694 <xbinGCD+96>:	ld	a0,-24(s0)
0x0000000000010698	175	      a = a >> 1;
=> 0x10698 <xbinGCD+100>:	srli	a0,a0,0x1
0x000000000001069c	175	      a = a >> 1;
=> 0x1069c <xbinGCD+104>:	sd	a0,-24(s0)
176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a0 <xbinGCD+108>:	lbu	a0,-72(s0)
0x00000000000106a4	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a4 <xbinGCD+112>:	andi	a0,a0,1
0x00000000000106a8	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a8 <xbinGCD+116>:	bnez	a0,0x106cc <xbinGCD+152>
0x00000000000106ac	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106ac <xbinGCD+120>:	j	0x106b0 <xbinGCD+124>
177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106b0 <xbinGCD+124>:	ld	a0,-72(s0)
0x00000000000106b4	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106b4 <xbinGCD+128>:	srli	a0,a0,0x1
0x00000000000106b8	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106b8 <xbinGCD+132>:	sd	a0,-72(s0)
0x00000000000106bc	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106bc <xbinGCD+136>:	ld	a0,-80(s0)
0x00000000000106c0	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106c0 <xbinGCD+140>:	srli	a0,a0,0x1
0x00000000000106c4	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106c4 <xbinGCD+144>:	sd	a0,-80(s0)
178	      }                               // u and v.
=> 0x106c8 <xbinGCD+148>:	j	0x10700 <xbinGCD+204>
174	   while (a > 0) {
=> 0x10700 <xbinGCD+204>:	j	0x10684 <xbinGCD+80>
0x0000000000010684	174	   while (a > 0) {
=> 0x10684 <xbinGCD+80>:	ld	a0,-24(s0)
0x0000000000010688	174	   while (a > 0) {
=> 0x10688 <xbinGCD+84>:	li	a1,0
0x000000000001068c	174	   while (a > 0) {
=> 0x1068c <xbinGCD+88>:	beq	a0,a1,0x10704 <xbinGCD+208>
0x0000000000010690	174	   while (a > 0) {
=> 0x10690 <xbinGCD+92>:	j	0x10694 <xbinGCD+96>
175	      a = a >> 1;
=> 0x10694 <xbinGCD+96>:	ld	a0,-24(s0)
0x0000000000010698	175	      a = a >> 1;
=> 0x10698 <xbinGCD+100>:	srli	a0,a0,0x1
0x000000000001069c	175	      a = a >> 1;
=> 0x1069c <xbinGCD+104>:	sd	a0,-24(s0)
176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a0 <xbinGCD+108>:	lbu	a0,-72(s0)
0x00000000000106a4	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a4 <xbinGCD+112>:	andi	a0,a0,1
0x00000000000106a8	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a8 <xbinGCD+116>:	bnez	a0,0x106cc <xbinGCD+152>
0x00000000000106ac	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106ac <xbinGCD+120>:	j	0x106b0 <xbinGCD+124>
177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106b0 <xbinGCD+124>:	ld	a0,-72(s0)
0x00000000000106b4	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106b4 <xbinGCD+128>:	srli	a0,a0,0x1
0x00000000000106b8	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106b8 <xbinGCD+132>:	sd	a0,-72(s0)
0x00000000000106bc	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106bc <xbinGCD+136>:	ld	a0,-80(s0)
0x00000000000106c0	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106c0 <xbinGCD+140>:	srli	a0,a0,0x1
0x00000000000106c4	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106c4 <xbinGCD+144>:	sd	a0,-80(s0)
178	      }                               // u and v.
=> 0x106c8 <xbinGCD+148>:	j	0x10700 <xbinGCD+204>
174	   while (a > 0) {
=> 0x10700 <xbinGCD+204>:	j	0x10684 <xbinGCD+80>
0x0000000000010684	174	   while (a > 0) {
=> 0x10684 <xbinGCD+80>:	ld	a0,-24(s0)
0x0000000000010688	174	   while (a > 0) {
=> 0x10688 <xbinGCD+84>:	li	a1,0
0x000000000001068c	174	   while (a > 0) {
=> 0x1068c <xbinGCD+88>:	beq	a0,a1,0x10704 <xbinGCD+208>
0x0000000000010690	174	   while (a > 0) {
=> 0x10690 <xbinGCD+92>:	j	0x10694 <xbinGCD+96>
175	      a = a >> 1;
=> 0x10694 <xbinGCD+96>:	ld	a0,-24(s0)
0x0000000000010698	175	      a = a >> 1;
=> 0x10698 <xbinGCD+100>:	srli	a0,a0,0x1
0x000000000001069c	175	      a = a >> 1;
=> 0x1069c <xbinGCD+104>:	sd	a0,-24(s0)
176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a0 <xbinGCD+108>:	lbu	a0,-72(s0)
0x00000000000106a4	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a4 <xbinGCD+112>:	andi	a0,a0,1
0x00000000000106a8	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a8 <xbinGCD+116>:	bnez	a0,0x106cc <xbinGCD+152>
0x00000000000106ac	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106ac <xbinGCD+120>:	j	0x106b0 <xbinGCD+124>
177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106b0 <xbinGCD+124>:	ld	a0,-72(s0)
0x00000000000106b4	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106b4 <xbinGCD+128>:	srli	a0,a0,0x1
0x00000000000106b8	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106b8 <xbinGCD+132>:	sd	a0,-72(s0)
0x00000000000106bc	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106bc <xbinGCD+136>:	ld	a0,-80(s0)
0x00000000000106c0	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106c0 <xbinGCD+140>:	srli	a0,a0,0x1
0x00000000000106c4	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106c4 <xbinGCD+144>:	sd	a0,-80(s0)
178	      }                               // u and v.
=> 0x106c8 <xbinGCD+148>:	j	0x10700 <xbinGCD+204>
174	   while (a > 0) {
=> 0x10700 <xbinGCD+204>:	j	0x10684 <xbinGCD+80>
0x0000000000010684	174	   while (a > 0) {
=> 0x10684 <xbinGCD+80>:	ld	a0,-24(s0)
0x0000000000010688	174	   while (a > 0) {
=> 0x10688 <xbinGCD+84>:	li	a1,0
0x000000000001068c	174	   while (a > 0) {
=> 0x1068c <xbinGCD+88>:	beq	a0,a1,0x10704 <xbinGCD+208>
0x0000000000010690	174	   while (a > 0) {
=> 0x10690 <xbinGCD+92>:	j	0x10694 <xbinGCD+96>
175	      a = a >> 1;
=> 0x10694 <xbinGCD+96>:	ld	a0,-24(s0)
0x0000000000010698	175	      a = a >> 1;
=> 0x10698 <xbinGCD+100>:	srli	a0,a0,0x1
0x000000000001069c	175	      a = a >> 1;
=> 0x1069c <xbinGCD+104>:	sd	a0,-24(s0)
176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a0 <xbinGCD+108>:	lbu	a0,-72(s0)
0x00000000000106a4	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a4 <xbinGCD+112>:	andi	a0,a0,1
0x00000000000106a8	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a8 <xbinGCD+116>:	bnez	a0,0x106cc <xbinGCD+152>
0x00000000000106ac	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106ac <xbinGCD+120>:	j	0x106b0 <xbinGCD+124>
177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106b0 <xbinGCD+124>:	ld	a0,-72(s0)
0x00000000000106b4	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106b4 <xbinGCD+128>:	srli	a0,a0,0x1
0x00000000000106b8	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106b8 <xbinGCD+132>:	sd	a0,-72(s0)
0x00000000000106bc	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106bc <xbinGCD+136>:	ld	a0,-80(s0)
0x00000000000106c0	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106c0 <xbinGCD+140>:	srli	a0,a0,0x1
0x00000000000106c4	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106c4 <xbinGCD+144>:	sd	a0,-80(s0)
178	      }                               // u and v.
=> 0x106c8 <xbinGCD+148>:	j	0x10700 <xbinGCD+204>
174	   while (a > 0) {
=> 0x10700 <xbinGCD+204>:	j	0x10684 <xbinGCD+80>
0x0000000000010684	174	   while (a > 0) {
=> 0x10684 <xbinGCD+80>:	ld	a0,-24(s0)
0x0000000000010688	174	   while (a > 0) {
=> 0x10688 <xbinGCD+84>:	li	a1,0
0x000000000001068c	174	   while (a > 0) {
=> 0x1068c <xbinGCD+88>:	beq	a0,a1,0x10704 <xbinGCD+208>
0x0000000000010690	174	   while (a > 0) {
=> 0x10690 <xbinGCD+92>:	j	0x10694 <xbinGCD+96>
175	      a = a >> 1;
=> 0x10694 <xbinGCD+96>:	ld	a0,-24(s0)
0x0000000000010698	175	      a = a >> 1;
=> 0x10698 <xbinGCD+100>:	srli	a0,a0,0x1
0x000000000001069c	175	      a = a >> 1;
=> 0x1069c <xbinGCD+104>:	sd	a0,-24(s0)
176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a0 <xbinGCD+108>:	lbu	a0,-72(s0)
0x00000000000106a4	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a4 <xbinGCD+112>:	andi	a0,a0,1
0x00000000000106a8	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a8 <xbinGCD+116>:	bnez	a0,0x106cc <xbinGCD+152>
0x00000000000106ac	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106ac <xbinGCD+120>:	j	0x106b0 <xbinGCD+124>
177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106b0 <xbinGCD+124>:	ld	a0,-72(s0)
0x00000000000106b4	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106b4 <xbinGCD+128>:	srli	a0,a0,0x1
0x00000000000106b8	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106b8 <xbinGCD+132>:	sd	a0,-72(s0)
0x00000000000106bc	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106bc <xbinGCD+136>:	ld	a0,-80(s0)
0x00000000000106c0	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106c0 <xbinGCD+140>:	srli	a0,a0,0x1
0x00000000000106c4	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106c4 <xbinGCD+144>:	sd	a0,-80(s0)
178	      }                               // u and v.
=> 0x106c8 <xbinGCD+148>:	j	0x10700 <xbinGCD+204>
174	   while (a > 0) {
=> 0x10700 <xbinGCD+204>:	j	0x10684 <xbinGCD+80>
0x0000000000010684	174	   while (a > 0) {
=> 0x10684 <xbinGCD+80>:	ld	a0,-24(s0)
0x0000000000010688	174	   while (a > 0) {
=> 0x10688 <xbinGCD+84>:	li	a1,0
0x000000000001068c	174	   while (a > 0) {
=> 0x1068c <xbinGCD+88>:	beq	a0,a1,0x10704 <xbinGCD+208>
0x0000000000010690	174	   while (a > 0) {
=> 0x10690 <xbinGCD+92>:	j	0x10694 <xbinGCD+96>
175	      a = a >> 1;
=> 0x10694 <xbinGCD+96>:	ld	a0,-24(s0)
0x0000000000010698	175	      a = a >> 1;
=> 0x10698 <xbinGCD+100>:	srli	a0,a0,0x1
0x000000000001069c	175	      a = a >> 1;
=> 0x1069c <xbinGCD+104>:	sd	a0,-24(s0)
176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a0 <xbinGCD+108>:	lbu	a0,-72(s0)
0x00000000000106a4	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a4 <xbinGCD+112>:	andi	a0,a0,1
0x00000000000106a8	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a8 <xbinGCD+116>:	bnez	a0,0x106cc <xbinGCD+152>
182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106cc <xbinGCD+152>:	ld	a0,-72(s0)
0x00000000000106d0	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106d0 <xbinGCD+156>:	ld	a1,-64(s0)
0x00000000000106d4	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106d4 <xbinGCD+160>:	xor	a2,a0,a1
0x00000000000106d8	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106d8 <xbinGCD+164>:	srli	a2,a2,0x1
0x00000000000106dc	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106dc <xbinGCD+168>:	and	a0,a0,a1
0x00000000000106e0	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106e0 <xbinGCD+172>:	add	a0,a2,a0
0x00000000000106e4	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106e4 <xbinGCD+176>:	sd	a0,-72(s0)
183	         v = (v >> 1) + alpha;
=> 0x106e8 <xbinGCD+180>:	ld	a0,-80(s0)
0x00000000000106ec	183	         v = (v >> 1) + alpha;
=> 0x106ec <xbinGCD+184>:	srli	a0,a0,0x1
0x00000000000106f0	183	         v = (v >> 1) + alpha;
=> 0x106f0 <xbinGCD+188>:	ld	a1,-56(s0)
0x00000000000106f4	183	         v = (v >> 1) + alpha;
=> 0x106f4 <xbinGCD+192>:	add	a0,a0,a1
0x00000000000106f8	183	         v = (v >> 1) + alpha;
=> 0x106f8 <xbinGCD+196>:	sd	a0,-80(s0)
0x00000000000106fc	183	         v = (v >> 1) + alpha;
=> 0x106fc <xbinGCD+200>:	j	0x10700 <xbinGCD+204>
174	   while (a > 0) {
=> 0x10700 <xbinGCD+204>:	j	0x10684 <xbinGCD+80>
0x0000000000010684	174	   while (a > 0) {
=> 0x10684 <xbinGCD+80>:	ld	a0,-24(s0)
0x0000000000010688	174	   while (a > 0) {
=> 0x10688 <xbinGCD+84>:	li	a1,0
0x000000000001068c	174	   while (a > 0) {
=> 0x1068c <xbinGCD+88>:	beq	a0,a1,0x10704 <xbinGCD+208>
0x0000000000010690	174	   while (a > 0) {
=> 0x10690 <xbinGCD+92>:	j	0x10694 <xbinGCD+96>
175	      a = a >> 1;
=> 0x10694 <xbinGCD+96>:	ld	a0,-24(s0)
0x0000000000010698	175	      a = a >> 1;
=> 0x10698 <xbinGCD+100>:	srli	a0,a0,0x1
0x000000000001069c	175	      a = a >> 1;
=> 0x1069c <xbinGCD+104>:	sd	a0,-24(s0)
176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a0 <xbinGCD+108>:	lbu	a0,-72(s0)
0x00000000000106a4	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a4 <xbinGCD+112>:	andi	a0,a0,1
0x00000000000106a8	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a8 <xbinGCD+116>:	bnez	a0,0x106cc <xbinGCD+152>
182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106cc <xbinGCD+152>:	ld	a0,-72(s0)
0x00000000000106d0	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106d0 <xbinGCD+156>:	ld	a1,-64(s0)
0x00000000000106d4	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106d4 <xbinGCD+160>:	xor	a2,a0,a1
0x00000000000106d8	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106d8 <xbinGCD+164>:	srli	a2,a2,0x1
0x00000000000106dc	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106dc <xbinGCD+168>:	and	a0,a0,a1
0x00000000000106e0	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106e0 <xbinGCD+172>:	add	a0,a2,a0
0x00000000000106e4	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106e4 <xbinGCD+176>:	sd	a0,-72(s0)
183	         v = (v >> 1) + alpha;
=> 0x106e8 <xbinGCD+180>:	ld	a0,-80(s0)
0x00000000000106ec	183	         v = (v >> 1) + alpha;
=> 0x106ec <xbinGCD+184>:	srli	a0,a0,0x1
0x00000000000106f0	183	         v = (v >> 1) + alpha;
=> 0x106f0 <xbinGCD+188>:	ld	a1,-56(s0)
0x00000000000106f4	183	         v = (v >> 1) + alpha;
=> 0x106f4 <xbinGCD+192>:	add	a0,a0,a1
0x00000000000106f8	183	         v = (v >> 1) + alpha;
=> 0x106f8 <xbinGCD+196>:	sd	a0,-80(s0)
0x00000000000106fc	183	         v = (v >> 1) + alpha;
=> 0x106fc <xbinGCD+200>:	j	0x10700 <xbinGCD+204>
174	   while (a > 0) {
=> 0x10700 <xbinGCD+204>:	j	0x10684 <xbinGCD+80>
0x0000000000010684	174	   while (a > 0) {
=> 0x10684 <xbinGCD+80>:	ld	a0,-24(s0)
0x0000000000010688	174	   while (a > 0) {
=> 0x10688 <xbinGCD+84>:	li	a1,0
0x000000000001068c	174	   while (a > 0) {
=> 0x1068c <xbinGCD+88>:	beq	a0,a1,0x10704 <xbinGCD+208>
0x0000000000010690	174	   while (a > 0) {
=> 0x10690 <xbinGCD+92>:	j	0x10694 <xbinGCD+96>
175	      a = a >> 1;
=> 0x10694 <xbinGCD+96>:	ld	a0,-24(s0)
0x0000000000010698	175	      a = a >> 1;
=> 0x10698 <xbinGCD+100>:	srli	a0,a0,0x1
0x000000000001069c	175	      a = a >> 1;
=> 0x1069c <xbinGCD+104>:	sd	a0,-24(s0)
176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a0 <xbinGCD+108>:	lbu	a0,-72(s0)
0x00000000000106a4	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a4 <xbinGCD+112>:	andi	a0,a0,1
0x00000000000106a8	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a8 <xbinGCD+116>:	bnez	a0,0x106cc <xbinGCD+152>
0x00000000000106ac	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106ac <xbinGCD+120>:	j	0x106b0 <xbinGCD+124>
177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106b0 <xbinGCD+124>:	ld	a0,-72(s0)
0x00000000000106b4	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106b4 <xbinGCD+128>:	srli	a0,a0,0x1
0x00000000000106b8	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106b8 <xbinGCD+132>:	sd	a0,-72(s0)
0x00000000000106bc	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106bc <xbinGCD+136>:	ld	a0,-80(s0)
0x00000000000106c0	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106c0 <xbinGCD+140>:	srli	a0,a0,0x1
0x00000000000106c4	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106c4 <xbinGCD+144>:	sd	a0,-80(s0)
178	      }                               // u and v.
=> 0x106c8 <xbinGCD+148>:	j	0x10700 <xbinGCD+204>
174	   while (a > 0) {
=> 0x10700 <xbinGCD+204>:	j	0x10684 <xbinGCD+80>
0x0000000000010684	174	   while (a > 0) {
=> 0x10684 <xbinGCD+80>:	ld	a0,-24(s0)
0x0000000000010688	174	   while (a > 0) {
=> 0x10688 <xbinGCD+84>:	li	a1,0
0x000000000001068c	174	   while (a > 0) {
=> 0x1068c <xbinGCD+88>:	beq	a0,a1,0x10704 <xbinGCD+208>
0x0000000000010690	174	   while (a > 0) {
=> 0x10690 <xbinGCD+92>:	j	0x10694 <xbinGCD+96>
175	      a = a >> 1;
=> 0x10694 <xbinGCD+96>:	ld	a0,-24(s0)
0x0000000000010698	175	      a = a >> 1;
=> 0x10698 <xbinGCD+100>:	srli	a0,a0,0x1
0x000000000001069c	175	      a = a >> 1;
=> 0x1069c <xbinGCD+104>:	sd	a0,-24(s0)
176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a0 <xbinGCD+108>:	lbu	a0,-72(s0)
0x00000000000106a4	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a4 <xbinGCD+112>:	andi	a0,a0,1
0x00000000000106a8	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a8 <xbinGCD+116>:	bnez	a0,0x106cc <xbinGCD+152>
0x00000000000106ac	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106ac <xbinGCD+120>:	j	0x106b0 <xbinGCD+124>
177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106b0 <xbinGCD+124>:	ld	a0,-72(s0)
0x00000000000106b4	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106b4 <xbinGCD+128>:	srli	a0,a0,0x1
0x00000000000106b8	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106b8 <xbinGCD+132>:	sd	a0,-72(s0)
0x00000000000106bc	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106bc <xbinGCD+136>:	ld	a0,-80(s0)
0x00000000000106c0	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106c0 <xbinGCD+140>:	srli	a0,a0,0x1
0x00000000000106c4	177	         u = u >> 1; v = v >> 1;      // factor of 2 in
=> 0x106c4 <xbinGCD+144>:	sd	a0,-80(s0)
178	      }                               // u and v.
=> 0x106c8 <xbinGCD+148>:	j	0x10700 <xbinGCD+204>
174	   while (a > 0) {
=> 0x10700 <xbinGCD+204>:	j	0x10684 <xbinGCD+80>
0x0000000000010684	174	   while (a > 0) {
=> 0x10684 <xbinGCD+80>:	ld	a0,-24(s0)
0x0000000000010688	174	   while (a > 0) {
=> 0x10688 <xbinGCD+84>:	li	a1,0
0x000000000001068c	174	   while (a > 0) {
=> 0x1068c <xbinGCD+88>:	beq	a0,a1,0x10704 <xbinGCD+208>
0x0000000000010690	174	   while (a > 0) {
=> 0x10690 <xbinGCD+92>:	j	0x10694 <xbinGCD+96>
175	      a = a >> 1;
=> 0x10694 <xbinGCD+96>:	ld	a0,-24(s0)
0x0000000000010698	175	      a = a >> 1;
=> 0x10698 <xbinGCD+100>:	srli	a0,a0,0x1
0x000000000001069c	175	      a = a >> 1;
=> 0x1069c <xbinGCD+104>:	sd	a0,-24(s0)
176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a0 <xbinGCD+108>:	lbu	a0,-72(s0)
0x00000000000106a4	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a4 <xbinGCD+112>:	andi	a0,a0,1
0x00000000000106a8	176	      if ((u & 1) == 0) {             // Delete a common
=> 0x106a8 <xbinGCD+116>:	bnez	a0,0x106cc <xbinGCD+152>
182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106cc <xbinGCD+152>:	ld	a0,-72(s0)
0x00000000000106d0	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106d0 <xbinGCD+156>:	ld	a1,-64(s0)
0x00000000000106d4	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106d4 <xbinGCD+160>:	xor	a2,a0,a1
0x00000000000106d8	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106d8 <xbinGCD+164>:	srli	a2,a2,0x1
0x00000000000106dc	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106dc <xbinGCD+168>:	and	a0,a0,a1
0x00000000000106e0	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106e0 <xbinGCD+172>:	add	a0,a2,a0
0x00000000000106e4	182	         u = ((u ^ beta) >> 1) + (u & beta);
=> 0x106e4 <xbinGCD+176>:	sd	a0,-72(s0)
183	         v = (v >> 1) + alpha;
=> 0x106e8 <xbinGCD+180>:	ld	a0,-80(s0)
0x00000000000106ec	183	         v = (v >> 1) + alpha;
=> 0x106ec <xbinGCD+184>:	srli	a0,a0,0x1
0x00000000000106f0	183	         v = (v >> 1) + alpha;
=> 0x106f0 <xbinGCD+188>:	ld	a1,-56(s0)
0x00000000000106f4	183	         v = (v >> 1) + alpha;
=> 0x106f4 <xbinGCD+192>:	add	a0,a0,a1
0x00000000000106f8	183	         v = (v >> 1) + alpha;
=> 0x106f8 <xbinGCD+196>:	sd	a0,-80(s0)
0x00000000000106fc	183	         v = (v >> 1) + alpha;
=> 0x106fc <xbinGCD+200>:	j	0x10700 <xbinGCD+204>
174	   while (a > 0) {
=> 0x10700 <xbinGCD+204>:	j	0x10684 <xbinGCD+80>
0x0000000000010684	174	   while (a > 0) {
=> 0x10684 <xbinGCD+80>:	ld	a0,-24(s0)
0x0000000000010688	174	   while (a > 0) {
=> 0x10688 <xbinGCD+84>:	li	a1,0
0x000000000001068c	174	   while (a > 0) {
=> 0x1068c <xbinGCD+88>:	beq	a0,a1,0x10704 <xbinGCD+208>
189	   *pu = u;
=> 0x10704 <xbinGCD+208>:	ld	a0,-72(s0)
0x0000000000010708	189	   *pu = u;
=> 0x10708 <xbinGCD+212>:	ld	a1,-40(s0)
0x000000000001070c	189	   *pu = u;
=> 0x1070c <xbinGCD+216>:	sd	a0,0(a1)
190	   *pv = v;
=> 0x10710 <xbinGCD+220>:	ld	a0,-80(s0)
0x0000000000010714	190	   *pv = v;
=> 0x10714 <xbinGCD+224>:	ld	a1,-48(s0)
0x0000000000010718	190	   *pv = v;
=> 0x10718 <xbinGCD+228>:	sd	a0,0(a1)
191	   return;
=> 0x1071c <xbinGCD+232>:	ld	s0,64(sp)
0x0000000000010720 in xbinGCD (a=380896260630216687, b=1473642379452024179, pu=0xfae849273928f89f, pv=0x8000000000000000) at mont64.c:191
191	   return;
=> 0x10720 <xbinGCD+236>:	ld	ra,72(sp)
0x0000000000010724	191	   return;
=> 0x10724 <xbinGCD+240>:	addi	sp,sp,80
0x0000000000010728	191	   return;
=> 0x10728 <xbinGCD+244>:	ld	ra,0(t6)
0x000000000001072c	191	   return;
=> 0x1072c <xbinGCD+248>:	addi	t6,t6,16
0x0000000000010730	191	   return;
=> 0x10730 <xbinGCD+252>:	ret
benchmark () at mont64.c:249
249	   if (2*hr*rinv - m*mprime != 1) {
=> 0x10818 <benchmark+228>:	ld	a0,-48(s0)
0x000000000001081c	249	   if (2*hr*rinv - m*mprime != 1) {
=> 0x1081c <benchmark+232>:	ld	a1,-120(s0)
0x0000000000010820	249	   if (2*hr*rinv - m*mprime != 1) {
=> 0x10820 <benchmark+236>:	mul	a0,a0,a1
0x0000000000010824	249	   if (2*hr*rinv - m*mprime != 1) {
=> 0x10824 <benchmark+240>:	slli	a0,a0,0x1
0x0000000000010828	249	   if (2*hr*rinv - m*mprime != 1) {
=> 0x10828 <benchmark+244>:	ld	a1,-40(s0)
0x000000000001082c	249	   if (2*hr*rinv - m*mprime != 1) {
=> 0x1082c <benchmark+248>:	ld	a2,-128(s0)
0x0000000000010830	249	   if (2*hr*rinv - m*mprime != 1) {
=> 0x10830 <benchmark+252>:	mul	a1,a1,a2
0x0000000000010834	249	   if (2*hr*rinv - m*mprime != 1) {
=> 0x10834 <benchmark+256>:	sub	a0,a0,a1
0x0000000000010838	249	   if (2*hr*rinv - m*mprime != 1) {
=> 0x10838 <benchmark+260>:	li	a1,1
0x000000000001083c	249	   if (2*hr*rinv - m*mprime != 1) {
=> 0x1083c <benchmark+264>:	beq	a0,a1,0x10850 <benchmark+284>
256	   abar = modul64(a, 0, m);
=> 0x10850 <benchmark+284>:	ld	a0,-24(s0)
0x0000000000010854	256	   abar = modul64(a, 0, m);
=> 0x10854 <benchmark+288>:	ld	a2,-40(s0)
0x0000000000010858	256	   abar = modul64(a, 0, m);
=> 0x10858 <benchmark+292>:	li	a1,0
0x000000000001085c	256	   abar = modul64(a, 0, m);
=> 0x1085c <benchmark+296>:	sd	a1,-176(s0)
0x0000000000010860	256	   abar = modul64(a, 0, m);
=> 0x10860 <benchmark+300>:	jal	ra,0x10434 <modul64>
modul64 (x=380896260630216687, y=1473642379452024179, z=18079781136890394783) at mont64.c:80
80	uint64 modul64(uint64 x, uint64 y, uint64 z) {
=> 0x10434 <modul64>:	addi	t6,t6,-16
0x0000000000010438	80	uint64 modul64(uint64 x, uint64 y, uint64 z) {
=> 0x10438 <modul64+4>:	sd	ra,0(t6)
0x000000000001043c	80	uint64 modul64(uint64 x, uint64 y, uint64 z) {
=> 0x1043c <modul64+8>:	st	zero,0(t6)
0x0000000000010440	80	uint64 modul64(uint64 x, uint64 y, uint64 z) {
=> 0x10440 <modul64+12>:	addi	sp,sp,-64
0x0000000000010444	80	uint64 modul64(uint64 x, uint64 y, uint64 z) {
=> 0x10444 <modul64+16>:	sd	ra,56(sp)
0x0000000000010448	80	uint64 modul64(uint64 x, uint64 y, uint64 z) {
=> 0x10448 <modul64+20>:	sd	s0,48(sp)
0x000000000001044c	80	uint64 modul64(uint64 x, uint64 y, uint64 z) {
=> 0x1044c <modul64+24>:	addi	s0,sp,64
0x0000000000010450	80	uint64 modul64(uint64 x, uint64 y, uint64 z) {
=> 0x10450 <modul64+28>:	sd	a0,-24(s0)
0x0000000000010454	80	uint64 modul64(uint64 x, uint64 y, uint64 z) {
=> 0x10454 <modul64+32>:	sd	a1,-32(s0)
0x0000000000010458	80	uint64 modul64(uint64 x, uint64 y, uint64 z) {
=> 0x10458 <modul64+36>:	sd	a2,-40(s0)
0x000000000001045c	80	uint64 modul64(uint64 x, uint64 y, uint64 z) {
=> 0x1045c <modul64+40>:	li	a0,1
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10460 <modul64+44>:	sd	a0,-48(s0)
0x0000000000010464	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10464 <modul64+48>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
98	   return x;                    // Quotient is y.
=> 0x104f4 <modul64+192>:	ld	a0,-24(s0)
0x00000000000104f8	98	   return x;                    // Quotient is y.
=> 0x104f8 <modul64+196>:	ld	s0,48(sp)
0x00000000000104fc in modul64 (x=380896260630216687, y=1473642379452024179, z=18079781136890394783) at mont64.c:98
98	   return x;                    // Quotient is y.
=> 0x104fc <modul64+200>:	ld	ra,56(sp)
0x0000000000010500	98	   return x;                    // Quotient is y.
=> 0x10500 <modul64+204>:	addi	sp,sp,64
0x0000000000010504	98	   return x;                    // Quotient is y.
=> 0x10504 <modul64+208>:	ld	ra,0(t6)
0x0000000000010508	98	   return x;                    // Quotient is y.
=> 0x10508 <modul64+212>:	addi	t6,t6,16
0x000000000001050c	98	   return x;                    // Quotient is y.
=> 0x1050c <modul64+216>:	ret
0x0000000000010864 in benchmark () at mont64.c:256
256	   abar = modul64(a, 0, m);
=> 0x10864 <benchmark+304>:	sd	a0,-88(s0)
257	   bbar = modul64(b, 0, m);
=> 0x10868 <benchmark+308>:	ld	a0,-32(s0)
0x000000000001086c	257	   bbar = modul64(b, 0, m);
=> 0x1086c <benchmark+312>:	ld	a2,-40(s0)
0x0000000000010870	257	   bbar = modul64(b, 0, m);
=> 0x10870 <benchmark+316>:	ld	a1,-176(s0)
0x0000000000010874	257	   bbar = modul64(b, 0, m);
=> 0x10874 <benchmark+320>:	jal	ra,0x10434 <modul64>
modul64 (x=380896260630216687, y=1473642379452024179, z=18079781136890394783) at mont64.c:80
80	uint64 modul64(uint64 x, uint64 y, uint64 z) {
=> 0x10434 <modul64>:	addi	t6,t6,-16
0x0000000000010438	80	uint64 modul64(uint64 x, uint64 y, uint64 z) {
=> 0x10438 <modul64+4>:	sd	ra,0(t6)
0x000000000001043c	80	uint64 modul64(uint64 x, uint64 y, uint64 z) {
=> 0x1043c <modul64+8>:	st	zero,0(t6)
0x0000000000010440	80	uint64 modul64(uint64 x, uint64 y, uint64 z) {
=> 0x10440 <modul64+12>:	addi	sp,sp,-64
0x0000000000010444	80	uint64 modul64(uint64 x, uint64 y, uint64 z) {
=> 0x10444 <modul64+16>:	sd	ra,56(sp)
0x0000000000010448	80	uint64 modul64(uint64 x, uint64 y, uint64 z) {
=> 0x10448 <modul64+20>:	sd	s0,48(sp)
0x000000000001044c	80	uint64 modul64(uint64 x, uint64 y, uint64 z) {
=> 0x1044c <modul64+24>:	addi	s0,sp,64
0x0000000000010450	80	uint64 modul64(uint64 x, uint64 y, uint64 z) {
=> 0x10450 <modul64+28>:	sd	a0,-24(s0)
0x0000000000010454	80	uint64 modul64(uint64 x, uint64 y, uint64 z) {
=> 0x10454 <modul64+32>:	sd	a1,-32(s0)
0x0000000000010458	80	uint64 modul64(uint64 x, uint64 y, uint64 z) {
=> 0x10458 <modul64+36>:	sd	a2,-40(s0)
0x000000000001045c	80	uint64 modul64(uint64 x, uint64 y, uint64 z) {
=> 0x1045c <modul64+40>:	li	a0,1
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10460 <modul64+44>:	sd	a0,-48(s0)
0x0000000000010464	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10464 <modul64+48>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
98	   return x;                    // Quotient is y.
=> 0x104f4 <modul64+192>:	ld	a0,-24(s0)
0x00000000000104f8	98	   return x;                    // Quotient is y.
=> 0x104f8 <modul64+196>:	ld	s0,48(sp)
0x00000000000104fc in modul64 (x=380896260630216687, y=1473642379452024179, z=18079781136890394783) at mont64.c:98
98	   return x;                    // Quotient is y.
=> 0x104fc <modul64+200>:	ld	ra,56(sp)
0x0000000000010500	98	   return x;                    // Quotient is y.
=> 0x10500 <modul64+204>:	addi	sp,sp,64
0x0000000000010504	98	   return x;                    // Quotient is y.
=> 0x10504 <modul64+208>:	ld	ra,0(t6)
0x0000000000010508	98	   return x;                    // Quotient is y.
=> 0x10508 <modul64+212>:	addi	t6,t6,16
0x000000000001050c	98	   return x;                    // Quotient is y.
=> 0x1050c <modul64+216>:	ret
0x0000000000010878 in benchmark () at mont64.c:257
257	   bbar = modul64(b, 0, m);
=> 0x10878 <benchmark+324>:	sd	a0,-96(s0)
259	   p = montmul(abar, bbar, m, mprime); /* Compute a*b (mod m). */
=> 0x1087c <benchmark+328>:	ld	a0,-88(s0)
0x0000000000010880	259	   p = montmul(abar, bbar, m, mprime); /* Compute a*b (mod m). */
=> 0x10880 <benchmark+332>:	ld	a1,-96(s0)
0x0000000000010884	259	   p = montmul(abar, bbar, m, mprime); /* Compute a*b (mod m). */
=> 0x10884 <benchmark+336>:	ld	a2,-40(s0)
0x0000000000010888	259	   p = montmul(abar, bbar, m, mprime); /* Compute a*b (mod m). */
=> 0x10888 <benchmark+340>:	ld	a3,-128(s0)
0x000000000001088c	259	   p = montmul(abar, bbar, m, mprime); /* Compute a*b (mod m). */
=> 0x1088c <benchmark+344>:	jal	ra,0x10510 <montmul>
montmul (abar=380896260630216687, bbar=1473642379452024179, m=18079781136890394783, mprime=9223372036854775808) at mont64.c:104
104	               uint64 mprime) {
=> 0x10510 <montmul>:	addi	t6,t6,-16
0x0000000000010514	104	               uint64 mprime) {
=> 0x10514 <montmul+4>:	sd	ra,0(t6)
0x0000000000010518	104	               uint64 mprime) {
=> 0x10518 <montmul+8>:	st	zero,0(t6)
0x000000000001051c	104	               uint64 mprime) {
=> 0x1051c <montmul+12>:	addi	sp,sp,-112
0x0000000000010520	104	               uint64 mprime) {
=> 0x10520 <montmul+16>:	sd	ra,104(sp)
0x0000000000010524	104	               uint64 mprime) {
=> 0x10524 <montmul+20>:	sd	s0,96(sp)
0x0000000000010528	104	               uint64 mprime) {
=> 0x10528 <montmul+24>:	addi	s0,sp,112
0x000000000001052c	104	               uint64 mprime) {
=> 0x1052c <montmul+28>:	sd	a0,-24(s0)
0x0000000000010530	104	               uint64 mprime) {
=> 0x10530 <montmul+32>:	sd	a1,-32(s0)
0x0000000000010534	104	               uint64 mprime) {
=> 0x10534 <montmul+36>:	sd	a2,-40(s0)
0x0000000000010538	104	               uint64 mprime) {
=> 0x10538 <montmul+40>:	sd	a3,-48(s0)
110	   mulul64(abar, bbar, &thi, &tlo);  // t = abar*bbar.
=> 0x1053c <montmul+44>:	ld	a0,-24(s0)
0x0000000000010540	110	   mulul64(abar, bbar, &thi, &tlo);  // t = abar*bbar.
=> 0x10540 <montmul+48>:	ld	a1,-32(s0)
0x0000000000010544	110	   mulul64(abar, bbar, &thi, &tlo);  // t = abar*bbar.
=> 0x10544 <montmul+52>:	addi	a2,s0,-56
0x0000000000010548	110	   mulul64(abar, bbar, &thi, &tlo);  // t = abar*bbar.
=> 0x10548 <montmul+56>:	addi	a3,s0,-64
0x000000000001054c	110	   mulul64(abar, bbar, &thi, &tlo);  // t = abar*bbar.
=> 0x1054c <montmul+60>:	jal	ra,0x1032c <mulul64>
mulul64 (u=4860306812313529839, v=185057023379481524, whi=0xfae849273928f89f, wlo=0x98202bea188ddca1) at mont64.c:54
54	   {
=> 0x1032c <mulul64>:	addi	t6,t6,-16
0x0000000000010330	54	   {
=> 0x10330 <mulul64+4>:	sd	ra,0(t6)
0x0000000000010334	54	   {
=> 0x10334 <mulul64+8>:	st	zero,0(t6)
0x0000000000010338	54	   {
=> 0x10338 <mulul64+12>:	addi	sp,sp,-128
0x000000000001033c	54	   {
=> 0x1033c <mulul64+16>:	sd	ra,120(sp)
0x0000000000010340	54	   {
=> 0x10340 <mulul64+20>:	sd	s0,112(sp)
0x0000000000010344	54	   {
=> 0x10344 <mulul64+24>:	addi	s0,sp,128
0x0000000000010348	54	   {
=> 0x10348 <mulul64+28>:	sd	a0,-24(s0)
0x000000000001034c	54	   {
=> 0x1034c <mulul64+32>:	sd	a1,-32(s0)
0x0000000000010350	54	   {
=> 0x10350 <mulul64+36>:	sd	a2,-40(s0)
0x0000000000010354	54	   {
=> 0x10354 <mulul64+40>:	sd	a3,-48(s0)
58	   u1 = u >> 32; u0 = u & 0xFFFFFFFF;
=> 0x10358 <mulul64+44>:	lwu	a0,-20(s0)
0x000000000001035c	58	   u1 = u >> 32; u0 = u & 0xFFFFFFFF;
=> 0x1035c <mulul64+48>:	sd	a0,-64(s0)
0x0000000000010360	58	   u1 = u >> 32; u0 = u & 0xFFFFFFFF;
=> 0x10360 <mulul64+52>:	lwu	a0,-24(s0)
0x0000000000010364	58	   u1 = u >> 32; u0 = u & 0xFFFFFFFF;
=> 0x10364 <mulul64+56>:	sd	a0,-56(s0)
59	   v1 = v >> 32; v0 = v & 0xFFFFFFFF;
=> 0x10368 <mulul64+60>:	lwu	a0,-28(s0)
0x000000000001036c	59	   v1 = v >> 32; v0 = v & 0xFFFFFFFF;
=> 0x1036c <mulul64+64>:	sd	a0,-80(s0)
0x0000000000010370	59	   v1 = v >> 32; v0 = v & 0xFFFFFFFF;
=> 0x10370 <mulul64+68>:	lwu	a0,-32(s0)
0x0000000000010374	59	   v1 = v >> 32; v0 = v & 0xFFFFFFFF;
=> 0x10374 <mulul64+72>:	sd	a0,-72(s0)
61	   t = u0*v0;
=> 0x10378 <mulul64+76>:	ld	a0,-56(s0)
0x000000000001037c	61	   t = u0*v0;
=> 0x1037c <mulul64+80>:	ld	a1,-72(s0)
0x0000000000010380	61	   t = u0*v0;
=> 0x10380 <mulul64+84>:	mul	a0,a0,a1
0x0000000000010384	61	   t = u0*v0;
=> 0x10384 <mulul64+88>:	sd	a0,-96(s0)
62	   w0 = t & 0xFFFFFFFF;
=> 0x10388 <mulul64+92>:	lwu	a0,-96(s0)
0x000000000001038c	62	   w0 = t & 0xFFFFFFFF;
=> 0x1038c <mulul64+96>:	sd	a0,-104(s0)
63	   k = t >> 32;
=> 0x10390 <mulul64+100>:	lwu	a0,-92(s0)
0x0000000000010394	63	   k = t >> 32;
=> 0x10394 <mulul64+104>:	sd	a0,-88(s0)
65	   t = u1*v0 + k;
=> 0x10398 <mulul64+108>:	ld	a0,-64(s0)
0x000000000001039c	65	   t = u1*v0 + k;
=> 0x1039c <mulul64+112>:	ld	a1,-72(s0)
0x00000000000103a0	65	   t = u1*v0 + k;
=> 0x103a0 <mulul64+116>:	mul	a0,a0,a1
0x00000000000103a4	65	   t = u1*v0 + k;
=> 0x103a4 <mulul64+120>:	ld	a1,-88(s0)
0x00000000000103a8	65	   t = u1*v0 + k;
=> 0x103a8 <mulul64+124>:	add	a0,a0,a1
0x00000000000103ac	65	   t = u1*v0 + k;
=> 0x103ac <mulul64+128>:	sd	a0,-96(s0)
66	   w1 = t & 0xFFFFFFFF;
=> 0x103b0 <mulul64+132>:	lwu	a0,-96(s0)
0x00000000000103b4	66	   w1 = t & 0xFFFFFFFF;
=> 0x103b4 <mulul64+136>:	sd	a0,-112(s0)
67	   w2 = t >> 32;
=> 0x103b8 <mulul64+140>:	lwu	a0,-92(s0)
0x00000000000103bc	67	   w2 = t >> 32;
=> 0x103bc <mulul64+144>:	sd	a0,-120(s0)
69	   t = u0*v1 + w1;
=> 0x103c0 <mulul64+148>:	ld	a0,-56(s0)
0x00000000000103c4	69	   t = u0*v1 + w1;
=> 0x103c4 <mulul64+152>:	ld	a1,-80(s0)
0x00000000000103c8	69	   t = u0*v1 + w1;
=> 0x103c8 <mulul64+156>:	mul	a0,a0,a1
0x00000000000103cc	69	   t = u0*v1 + w1;
=> 0x103cc <mulul64+160>:	ld	a1,-112(s0)
0x00000000000103d0	69	   t = u0*v1 + w1;
=> 0x103d0 <mulul64+164>:	add	a0,a0,a1
0x00000000000103d4	69	   t = u0*v1 + w1;
=> 0x103d4 <mulul64+168>:	sd	a0,-96(s0)
70	   k = t >> 32;
=> 0x103d8 <mulul64+172>:	lwu	a0,-92(s0)
0x00000000000103dc	70	   k = t >> 32;
=> 0x103dc <mulul64+176>:	sd	a0,-88(s0)
72	   *wlo = (t << 32) + w0;
=> 0x103e0 <mulul64+180>:	ld	a0,-96(s0)
0x00000000000103e4	72	   *wlo = (t << 32) + w0;
=> 0x103e4 <mulul64+184>:	slli	a0,a0,0x20
0x00000000000103e8	72	   *wlo = (t << 32) + w0;
=> 0x103e8 <mulul64+188>:	ld	a1,-104(s0)
0x00000000000103ec	72	   *wlo = (t << 32) + w0;
=> 0x103ec <mulul64+192>:	add	a0,a0,a1
0x00000000000103f0	72	   *wlo = (t << 32) + w0;
=> 0x103f0 <mulul64+196>:	ld	a1,-48(s0)
0x00000000000103f4	72	   *wlo = (t << 32) + w0;
=> 0x103f4 <mulul64+200>:	sd	a0,0(a1)
73	   *whi = u1*v1 + w2 + k;
=> 0x103f8 <mulul64+204>:	ld	a0,-64(s0)
0x00000000000103fc	73	   *whi = u1*v1 + w2 + k;
=> 0x103fc <mulul64+208>:	ld	a1,-80(s0)
0x0000000000010400	73	   *whi = u1*v1 + w2 + k;
=> 0x10400 <mulul64+212>:	mul	a0,a0,a1
0x0000000000010404	73	   *whi = u1*v1 + w2 + k;
=> 0x10404 <mulul64+216>:	ld	a1,-120(s0)
0x0000000000010408	73	   *whi = u1*v1 + w2 + k;
=> 0x10408 <mulul64+220>:	add	a0,a0,a1
0x000000000001040c	73	   *whi = u1*v1 + w2 + k;
=> 0x1040c <mulul64+224>:	ld	a1,-88(s0)
0x0000000000010410	73	   *whi = u1*v1 + w2 + k;
=> 0x10410 <mulul64+228>:	add	a0,a0,a1
0x0000000000010414	73	   *whi = u1*v1 + w2 + k;
=> 0x10414 <mulul64+232>:	ld	a1,-40(s0)
0x0000000000010418	73	   *whi = u1*v1 + w2 + k;
=> 0x10418 <mulul64+236>:	sd	a0,0(a1)
75	   return;
=> 0x1041c <mulul64+240>:	ld	s0,112(sp)
0x0000000000010420 in mulul64 (u=4860306812313529839, v=185057023379481524, whi=0xfae849273928f89f, wlo=0x98202bea188ddca1) at mont64.c:75
75	   return;
=> 0x10420 <mulul64+244>:	ld	ra,120(sp)
0x0000000000010424	75	   return;
=> 0x10424 <mulul64+248>:	addi	sp,sp,128
0x0000000000010428	75	   return;
=> 0x10428 <mulul64+252>:	ld	ra,0(t6)
0x000000000001042c	75	   return;
=> 0x1042c <mulul64+256>:	addi	t6,t6,16
0x0000000000010430	75	   return;
=> 0x10430 <mulul64+260>:	ret
montmul (abar=4860306812313529839, bbar=185057023379481524, m=18079781136890394783, mprime=10961809777454079137) at mont64.c:117
117	   tm = tlo*mprime;
=> 0x10550 <montmul+64>:	ld	a0,-64(s0)
0x0000000000010554	117	   tm = tlo*mprime;
=> 0x10554 <montmul+68>:	ld	a1,-48(s0)
0x0000000000010558	117	   tm = tlo*mprime;
=> 0x10558 <montmul+72>:	mul	a0,a0,a1
0x000000000001055c	117	   tm = tlo*mprime;
=> 0x1055c <montmul+76>:	sd	a0,-72(s0)
119	   mulul64(tm, m, &tmmhi, &tmmlo);   // tmm = tm*m.
=> 0x10560 <montmul+80>:	ld	a0,-72(s0)
0x0000000000010564	119	   mulul64(tm, m, &tmmhi, &tmmlo);   // tmm = tm*m.
=> 0x10564 <montmul+84>:	ld	a1,-40(s0)
0x0000000000010568	119	   mulul64(tm, m, &tmmhi, &tmmlo);   // tmm = tm*m.
=> 0x10568 <montmul+88>:	addi	a2,s0,-80
0x000000000001056c	119	   mulul64(tm, m, &tmmhi, &tmmlo);   // tmm = tm*m.
=> 0x1056c <montmul+92>:	addi	a3,s0,-88
0x0000000000010570	119	   mulul64(tm, m, &tmmhi, &tmmlo);   // tmm = tm*m.
=> 0x10570 <montmul+96>:	jal	ra,0x1032c <mulul64>
mulul64 (u=4860306812313529839, v=185057023379481524, whi=0xfae849273928f89f, wlo=0x98202bea188ddca1) at mont64.c:54
54	   {
=> 0x1032c <mulul64>:	addi	t6,t6,-16
0x0000000000010330	54	   {
=> 0x10330 <mulul64+4>:	sd	ra,0(t6)
0x0000000000010334	54	   {
=> 0x10334 <mulul64+8>:	st	zero,0(t6)
0x0000000000010338	54	   {
=> 0x10338 <mulul64+12>:	addi	sp,sp,-128
0x000000000001033c	54	   {
=> 0x1033c <mulul64+16>:	sd	ra,120(sp)
0x0000000000010340	54	   {
=> 0x10340 <mulul64+20>:	sd	s0,112(sp)
0x0000000000010344	54	   {
=> 0x10344 <mulul64+24>:	addi	s0,sp,128
0x0000000000010348	54	   {
=> 0x10348 <mulul64+28>:	sd	a0,-24(s0)
0x000000000001034c	54	   {
=> 0x1034c <mulul64+32>:	sd	a1,-32(s0)
0x0000000000010350	54	   {
=> 0x10350 <mulul64+36>:	sd	a2,-40(s0)
0x0000000000010354	54	   {
=> 0x10354 <mulul64+40>:	sd	a3,-48(s0)
58	   u1 = u >> 32; u0 = u & 0xFFFFFFFF;
=> 0x10358 <mulul64+44>:	lwu	a0,-20(s0)
0x000000000001035c	58	   u1 = u >> 32; u0 = u & 0xFFFFFFFF;
=> 0x1035c <mulul64+48>:	sd	a0,-64(s0)
0x0000000000010360	58	   u1 = u >> 32; u0 = u & 0xFFFFFFFF;
=> 0x10360 <mulul64+52>:	lwu	a0,-24(s0)
0x0000000000010364	58	   u1 = u >> 32; u0 = u & 0xFFFFFFFF;
=> 0x10364 <mulul64+56>:	sd	a0,-56(s0)
59	   v1 = v >> 32; v0 = v & 0xFFFFFFFF;
=> 0x10368 <mulul64+60>:	lwu	a0,-28(s0)
0x000000000001036c	59	   v1 = v >> 32; v0 = v & 0xFFFFFFFF;
=> 0x1036c <mulul64+64>:	sd	a0,-80(s0)
0x0000000000010370	59	   v1 = v >> 32; v0 = v & 0xFFFFFFFF;
=> 0x10370 <mulul64+68>:	lwu	a0,-32(s0)
0x0000000000010374	59	   v1 = v >> 32; v0 = v & 0xFFFFFFFF;
=> 0x10374 <mulul64+72>:	sd	a0,-72(s0)
61	   t = u0*v0;
=> 0x10378 <mulul64+76>:	ld	a0,-56(s0)
0x000000000001037c	61	   t = u0*v0;
=> 0x1037c <mulul64+80>:	ld	a1,-72(s0)
0x0000000000010380	61	   t = u0*v0;
=> 0x10380 <mulul64+84>:	mul	a0,a0,a1
0x0000000000010384	61	   t = u0*v0;
=> 0x10384 <mulul64+88>:	sd	a0,-96(s0)
62	   w0 = t & 0xFFFFFFFF;
=> 0x10388 <mulul64+92>:	lwu	a0,-96(s0)
0x000000000001038c	62	   w0 = t & 0xFFFFFFFF;
=> 0x1038c <mulul64+96>:	sd	a0,-104(s0)
63	   k = t >> 32;
=> 0x10390 <mulul64+100>:	lwu	a0,-92(s0)
0x0000000000010394	63	   k = t >> 32;
=> 0x10394 <mulul64+104>:	sd	a0,-88(s0)
65	   t = u1*v0 + k;
=> 0x10398 <mulul64+108>:	ld	a0,-64(s0)
0x000000000001039c	65	   t = u1*v0 + k;
=> 0x1039c <mulul64+112>:	ld	a1,-72(s0)
0x00000000000103a0	65	   t = u1*v0 + k;
=> 0x103a0 <mulul64+116>:	mul	a0,a0,a1
0x00000000000103a4	65	   t = u1*v0 + k;
=> 0x103a4 <mulul64+120>:	ld	a1,-88(s0)
0x00000000000103a8	65	   t = u1*v0 + k;
=> 0x103a8 <mulul64+124>:	add	a0,a0,a1
0x00000000000103ac	65	   t = u1*v0 + k;
=> 0x103ac <mulul64+128>:	sd	a0,-96(s0)
66	   w1 = t & 0xFFFFFFFF;
=> 0x103b0 <mulul64+132>:	lwu	a0,-96(s0)
0x00000000000103b4	66	   w1 = t & 0xFFFFFFFF;
=> 0x103b4 <mulul64+136>:	sd	a0,-112(s0)
67	   w2 = t >> 32;
=> 0x103b8 <mulul64+140>:	lwu	a0,-92(s0)
0x00000000000103bc	67	   w2 = t >> 32;
=> 0x103bc <mulul64+144>:	sd	a0,-120(s0)
69	   t = u0*v1 + w1;
=> 0x103c0 <mulul64+148>:	ld	a0,-56(s0)
0x00000000000103c4	69	   t = u0*v1 + w1;
=> 0x103c4 <mulul64+152>:	ld	a1,-80(s0)
0x00000000000103c8	69	   t = u0*v1 + w1;
=> 0x103c8 <mulul64+156>:	mul	a0,a0,a1
0x00000000000103cc	69	   t = u0*v1 + w1;
=> 0x103cc <mulul64+160>:	ld	a1,-112(s0)
0x00000000000103d0	69	   t = u0*v1 + w1;
=> 0x103d0 <mulul64+164>:	add	a0,a0,a1
0x00000000000103d4	69	   t = u0*v1 + w1;
=> 0x103d4 <mulul64+168>:	sd	a0,-96(s0)
70	   k = t >> 32;
=> 0x103d8 <mulul64+172>:	lwu	a0,-92(s0)
0x00000000000103dc	70	   k = t >> 32;
=> 0x103dc <mulul64+176>:	sd	a0,-88(s0)
72	   *wlo = (t << 32) + w0;
=> 0x103e0 <mulul64+180>:	ld	a0,-96(s0)
0x00000000000103e4	72	   *wlo = (t << 32) + w0;
=> 0x103e4 <mulul64+184>:	slli	a0,a0,0x20
0x00000000000103e8	72	   *wlo = (t << 32) + w0;
=> 0x103e8 <mulul64+188>:	ld	a1,-104(s0)
0x00000000000103ec	72	   *wlo = (t << 32) + w0;
=> 0x103ec <mulul64+192>:	add	a0,a0,a1
0x00000000000103f0	72	   *wlo = (t << 32) + w0;
=> 0x103f0 <mulul64+196>:	ld	a1,-48(s0)
0x00000000000103f4	72	   *wlo = (t << 32) + w0;
=> 0x103f4 <mulul64+200>:	sd	a0,0(a1)
73	   *whi = u1*v1 + w2 + k;
=> 0x103f8 <mulul64+204>:	ld	a0,-64(s0)
0x00000000000103fc	73	   *whi = u1*v1 + w2 + k;
=> 0x103fc <mulul64+208>:	ld	a1,-80(s0)
0x0000000000010400	73	   *whi = u1*v1 + w2 + k;
=> 0x10400 <mulul64+212>:	mul	a0,a0,a1
0x0000000000010404	73	   *whi = u1*v1 + w2 + k;
=> 0x10404 <mulul64+216>:	ld	a1,-120(s0)
0x0000000000010408	73	   *whi = u1*v1 + w2 + k;
=> 0x10408 <mulul64+220>:	add	a0,a0,a1
0x000000000001040c	73	   *whi = u1*v1 + w2 + k;
=> 0x1040c <mulul64+224>:	ld	a1,-88(s0)
0x0000000000010410	73	   *whi = u1*v1 + w2 + k;
=> 0x10410 <mulul64+228>:	add	a0,a0,a1
0x0000000000010414	73	   *whi = u1*v1 + w2 + k;
=> 0x10414 <mulul64+232>:	ld	a1,-40(s0)
0x0000000000010418	73	   *whi = u1*v1 + w2 + k;
=> 0x10418 <mulul64+236>:	sd	a0,0(a1)
75	   return;
=> 0x1041c <mulul64+240>:	ld	s0,112(sp)
0x0000000000010420 in mulul64 (u=4860306812313529839, v=185057023379481524, whi=0xfae849273928f89f, wlo=0x98202bea188ddca1) at mont64.c:75
75	   return;
=> 0x10420 <mulul64+244>:	ld	ra,120(sp)
0x0000000000010424	75	   return;
=> 0x10424 <mulul64+248>:	addi	sp,sp,128
0x0000000000010428	75	   return;
=> 0x10428 <mulul64+252>:	ld	ra,0(t6)
0x000000000001042c	75	   return;
=> 0x1042c <mulul64+256>:	addi	t6,t6,16
0x0000000000010430	75	   return;
=> 0x10430 <mulul64+260>:	ret
montmul (abar=4860306812313529839, bbar=185057023379481524, m=18079781136890394783, mprime=10961809777454079137) at mont64.c:121
121	   ulo = tlo + tmmlo;                // Add t to tmm
=> 0x10574 <montmul+100>:	ld	a0,-64(s0)
0x0000000000010578	121	   ulo = tlo + tmmlo;                // Add t to tmm
=> 0x10578 <montmul+104>:	ld	a1,-88(s0)
0x000000000001057c	121	   ulo = tlo + tmmlo;                // Add t to tmm
=> 0x1057c <montmul+108>:	add	a0,a0,a1
0x0000000000010580	121	   ulo = tlo + tmmlo;                // Add t to tmm
=> 0x10580 <montmul+112>:	sd	a0,-104(s0)
122	   uhi = thi + tmmhi;                // (128-bit add).
=> 0x10584 <montmul+116>:	ld	a0,-56(s0)
0x0000000000010588	122	   uhi = thi + tmmhi;                // (128-bit add).
=> 0x10588 <montmul+120>:	ld	a1,-80(s0)
0x000000000001058c	122	   uhi = thi + tmmhi;                // (128-bit add).
=> 0x1058c <montmul+124>:	add	a0,a0,a1
0x0000000000010590	122	   uhi = thi + tmmhi;                // (128-bit add).
=> 0x10590 <montmul+128>:	sd	a0,-96(s0)
123	   if (ulo < tlo) uhi = uhi + 1;     // Allow for a carry.
=> 0x10594 <montmul+132>:	ld	a0,-104(s0)
0x0000000000010598	123	   if (ulo < tlo) uhi = uhi + 1;     // Allow for a carry.
=> 0x10598 <montmul+136>:	ld	a1,-64(s0)
0x000000000001059c	123	   if (ulo < tlo) uhi = uhi + 1;     // Allow for a carry.
=> 0x1059c <montmul+140>:	bgeu	a0,a1,0x105b4 <montmul+164>
0x00000000000105a0	123	   if (ulo < tlo) uhi = uhi + 1;     // Allow for a carry.
=> 0x105a0 <montmul+144>:	j	0x105a4 <montmul+148>
0x00000000000105a4	123	   if (ulo < tlo) uhi = uhi + 1;     // Allow for a carry.
=> 0x105a4 <montmul+148>:	ld	a0,-96(s0)
0x00000000000105a8	123	   if (ulo < tlo) uhi = uhi + 1;     // Allow for a carry.
=> 0x105a8 <montmul+152>:	addi	a0,a0,1
0x00000000000105ac	123	   if (ulo < tlo) uhi = uhi + 1;     // Allow for a carry.
=> 0x105ac <montmul+156>:	sd	a0,-96(s0)
0x00000000000105b0	123	   if (ulo < tlo) uhi = uhi + 1;     // Allow for a carry.
=> 0x105b0 <montmul+160>:	j	0x105b4 <montmul+164>
127	   ov = (uhi < thi) | ((uhi == thi) & (ulo < tlo));
=> 0x105b4 <montmul+164>:	ld	a0,-96(s0)
0x00000000000105b8	127	   ov = (uhi < thi) | ((uhi == thi) & (ulo < tlo));
=> 0x105b8 <montmul+168>:	ld	a1,-56(s0)
0x00000000000105bc	127	   ov = (uhi < thi) | ((uhi == thi) & (ulo < tlo));
=> 0x105bc <montmul+172>:	sltu	a2,a0,a1
0x00000000000105c0	127	   ov = (uhi < thi) | ((uhi == thi) & (ulo < tlo));
=> 0x105c0 <montmul+176>:	xor	a0,a0,a1
0x00000000000105c4	127	   ov = (uhi < thi) | ((uhi == thi) & (ulo < tlo));
=> 0x105c4 <montmul+180>:	seqz	a0,a0
0x00000000000105c8	127	   ov = (uhi < thi) | ((uhi == thi) & (ulo < tlo));
=> 0x105c8 <montmul+184>:	ld	a1,-104(s0)
0x00000000000105cc	127	   ov = (uhi < thi) | ((uhi == thi) & (ulo < tlo));
=> 0x105cc <montmul+188>:	ld	a3,-64(s0)
0x00000000000105d0	127	   ov = (uhi < thi) | ((uhi == thi) & (ulo < tlo));
=> 0x105d0 <montmul+192>:	sltu	a1,a1,a3
0x00000000000105d4	127	   ov = (uhi < thi) | ((uhi == thi) & (ulo < tlo));
=> 0x105d4 <montmul+196>:	and	a0,a0,a1
0x00000000000105d8	127	   ov = (uhi < thi) | ((uhi == thi) & (ulo < tlo));
=> 0x105d8 <montmul+200>:	or	a0,a2,a0
0x00000000000105dc	127	   ov = (uhi < thi) | ((uhi == thi) & (ulo < tlo));
=> 0x105dc <montmul+204>:	sd	a0,-112(s0)
129	   ulo = uhi;                   // Shift u right
=> 0x105e0 <montmul+208>:	ld	a0,-96(s0)
0x00000000000105e4	129	   ulo = uhi;                   // Shift u right
=> 0x105e4 <montmul+212>:	sd	a0,-104(s0)
0x00000000000105e8	129	   ulo = uhi;                   // Shift u right
=> 0x105e8 <montmul+216>:	li	a0,0
130	   uhi = 0;                     // 64 bit positions.
=> 0x105ec <montmul+220>:	sd	a0,-96(s0)
134	   ulo = ulo - (m & -(ov | (ulo >= m))); // Alternative
=> 0x105f0 <montmul+224>:	ld	a1,-104(s0)
0x00000000000105f4	134	   ulo = ulo - (m & -(ov | (ulo >= m))); // Alternative
=> 0x105f4 <montmul+228>:	ld	a2,-40(s0)
0x00000000000105f8	134	   ulo = ulo - (m & -(ov | (ulo >= m))); // Alternative
=> 0x105f8 <montmul+232>:	ld	a3,-112(s0)
0x00000000000105fc	134	   ulo = ulo - (m & -(ov | (ulo >= m))); // Alternative
=> 0x105fc <montmul+236>:	sltu	a4,a1,a2
0x0000000000010600	134	   ulo = ulo - (m & -(ov | (ulo >= m))); // Alternative
=> 0x10600 <montmul+240>:	xori	a4,a4,1
0x0000000000010604	134	   ulo = ulo - (m & -(ov | (ulo >= m))); // Alternative
=> 0x10604 <montmul+244>:	or	a3,a3,a4
0x0000000000010608	134	   ulo = ulo - (m & -(ov | (ulo >= m))); // Alternative
=> 0x10608 <montmul+248>:	sub	a0,a0,a3
0x000000000001060c	134	   ulo = ulo - (m & -(ov | (ulo >= m))); // Alternative
=> 0x1060c <montmul+252>:	and	a0,a2,a0
0x0000000000010610	134	   ulo = ulo - (m & -(ov | (ulo >= m))); // Alternative
=> 0x10610 <montmul+256>:	sub	a0,a1,a0
0x0000000000010614	134	   ulo = ulo - (m & -(ov | (ulo >= m))); // Alternative
=> 0x10614 <montmul+260>:	sd	a0,-104(s0)
137	   return ulo;
=> 0x10618 <montmul+264>:	ld	a0,-104(s0)
0x000000000001061c	137	   return ulo;
=> 0x1061c <montmul+268>:	ld	s0,96(sp)
0x0000000000010620 in montmul (abar=380896260630216687, bbar=1473642379452024179, m=18079781136890394783, mprime=9223372036854775808) at mont64.c:137
137	   return ulo;
=> 0x10620 <montmul+272>:	ld	ra,104(sp)
0x0000000000010624	137	   return ulo;
=> 0x10624 <montmul+276>:	addi	sp,sp,112
0x0000000000010628	137	   return ulo;
=> 0x10628 <montmul+280>:	ld	ra,0(t6)
0x000000000001062c	137	   return ulo;
=> 0x1062c <montmul+284>:	addi	t6,t6,16
0x0000000000010630	137	   return ulo;
=> 0x10630 <montmul+288>:	ret
0x0000000000010890 in benchmark () at mont64.c:259
259	   p = montmul(abar, bbar, m, mprime); /* Compute a*b (mod m). */
=> 0x10890 <benchmark+348>:	sd	a0,-80(s0)
260	   p = montmul(p, p, m, mprime);       /* Compute (a*b)**2 (mod m). */
=> 0x10894 <benchmark+352>:	ld	a0,-80(s0)
0x0000000000010898	260	   p = montmul(p, p, m, mprime);       /* Compute (a*b)**2 (mod m). */
=> 0x10898 <benchmark+356>:	ld	a2,-40(s0)
0x000000000001089c	260	   p = montmul(p, p, m, mprime);       /* Compute (a*b)**2 (mod m). */
=> 0x1089c <benchmark+360>:	ld	a3,-128(s0)
0x00000000000108a0	260	   p = montmul(p, p, m, mprime);       /* Compute (a*b)**2 (mod m). */
=> 0x108a0 <benchmark+364>:	sd	a0,-184(s0)
0x00000000000108a4	260	   p = montmul(p, p, m, mprime);       /* Compute (a*b)**2 (mod m). */
=> 0x108a4 <benchmark+368>:	ld	a1,-184(s0)
0x00000000000108a8	260	   p = montmul(p, p, m, mprime);       /* Compute (a*b)**2 (mod m). */
=> 0x108a8 <benchmark+372>:	jal	ra,0x10510 <montmul>
montmul (abar=380896260630216687, bbar=1473642379452024179, m=18079781136890394783, mprime=9223372036854775808) at mont64.c:104
104	               uint64 mprime) {
=> 0x10510 <montmul>:	addi	t6,t6,-16
0x0000000000010514	104	               uint64 mprime) {
=> 0x10514 <montmul+4>:	sd	ra,0(t6)
0x0000000000010518	104	               uint64 mprime) {
=> 0x10518 <montmul+8>:	st	zero,0(t6)
0x000000000001051c	104	               uint64 mprime) {
=> 0x1051c <montmul+12>:	addi	sp,sp,-112
0x0000000000010520	104	               uint64 mprime) {
=> 0x10520 <montmul+16>:	sd	ra,104(sp)
0x0000000000010524	104	               uint64 mprime) {
=> 0x10524 <montmul+20>:	sd	s0,96(sp)
0x0000000000010528	104	               uint64 mprime) {
=> 0x10528 <montmul+24>:	addi	s0,sp,112
0x000000000001052c	104	               uint64 mprime) {
=> 0x1052c <montmul+28>:	sd	a0,-24(s0)
0x0000000000010530	104	               uint64 mprime) {
=> 0x10530 <montmul+32>:	sd	a1,-32(s0)
0x0000000000010534	104	               uint64 mprime) {
=> 0x10534 <montmul+36>:	sd	a2,-40(s0)
0x0000000000010538	104	               uint64 mprime) {
=> 0x10538 <montmul+40>:	sd	a3,-48(s0)
110	   mulul64(abar, bbar, &thi, &tlo);  // t = abar*bbar.
=> 0x1053c <montmul+44>:	ld	a0,-24(s0)
0x0000000000010540	110	   mulul64(abar, bbar, &thi, &tlo);  // t = abar*bbar.
=> 0x10540 <montmul+48>:	ld	a1,-32(s0)
0x0000000000010544	110	   mulul64(abar, bbar, &thi, &tlo);  // t = abar*bbar.
=> 0x10544 <montmul+52>:	addi	a2,s0,-56
0x0000000000010548	110	   mulul64(abar, bbar, &thi, &tlo);  // t = abar*bbar.
=> 0x10548 <montmul+56>:	addi	a3,s0,-64
0x000000000001054c	110	   mulul64(abar, bbar, &thi, &tlo);  // t = abar*bbar.
=> 0x1054c <montmul+60>:	jal	ra,0x1032c <mulul64>
mulul64 (u=2516087340705735576, v=2516087340705735576, whi=0xfae849273928f89f, wlo=0x98202bea188ddca1) at mont64.c:54
54	   {
=> 0x1032c <mulul64>:	addi	t6,t6,-16
0x0000000000010330	54	   {
=> 0x10330 <mulul64+4>:	sd	ra,0(t6)
0x0000000000010334	54	   {
=> 0x10334 <mulul64+8>:	st	zero,0(t6)
0x0000000000010338	54	   {
=> 0x10338 <mulul64+12>:	addi	sp,sp,-128
0x000000000001033c	54	   {
=> 0x1033c <mulul64+16>:	sd	ra,120(sp)
0x0000000000010340	54	   {
=> 0x10340 <mulul64+20>:	sd	s0,112(sp)
0x0000000000010344	54	   {
=> 0x10344 <mulul64+24>:	addi	s0,sp,128
0x0000000000010348	54	   {
=> 0x10348 <mulul64+28>:	sd	a0,-24(s0)
0x000000000001034c	54	   {
=> 0x1034c <mulul64+32>:	sd	a1,-32(s0)
0x0000000000010350	54	   {
=> 0x10350 <mulul64+36>:	sd	a2,-40(s0)
0x0000000000010354	54	   {
=> 0x10354 <mulul64+40>:	sd	a3,-48(s0)
58	   u1 = u >> 32; u0 = u & 0xFFFFFFFF;
=> 0x10358 <mulul64+44>:	lwu	a0,-20(s0)
0x000000000001035c	58	   u1 = u >> 32; u0 = u & 0xFFFFFFFF;
=> 0x1035c <mulul64+48>:	sd	a0,-64(s0)
0x0000000000010360	58	   u1 = u >> 32; u0 = u & 0xFFFFFFFF;
=> 0x10360 <mulul64+52>:	lwu	a0,-24(s0)
0x0000000000010364	58	   u1 = u >> 32; u0 = u & 0xFFFFFFFF;
=> 0x10364 <mulul64+56>:	sd	a0,-56(s0)
59	   v1 = v >> 32; v0 = v & 0xFFFFFFFF;
=> 0x10368 <mulul64+60>:	lwu	a0,-28(s0)
0x000000000001036c	59	   v1 = v >> 32; v0 = v & 0xFFFFFFFF;
=> 0x1036c <mulul64+64>:	sd	a0,-80(s0)
0x0000000000010370	59	   v1 = v >> 32; v0 = v & 0xFFFFFFFF;
=> 0x10370 <mulul64+68>:	lwu	a0,-32(s0)
0x0000000000010374	59	   v1 = v >> 32; v0 = v & 0xFFFFFFFF;
=> 0x10374 <mulul64+72>:	sd	a0,-72(s0)
61	   t = u0*v0;
=> 0x10378 <mulul64+76>:	ld	a0,-56(s0)
0x000000000001037c	61	   t = u0*v0;
=> 0x1037c <mulul64+80>:	ld	a1,-72(s0)
0x0000000000010380	61	   t = u0*v0;
=> 0x10380 <mulul64+84>:	mul	a0,a0,a1
0x0000000000010384	61	   t = u0*v0;
=> 0x10384 <mulul64+88>:	sd	a0,-96(s0)
62	   w0 = t & 0xFFFFFFFF;
=> 0x10388 <mulul64+92>:	lwu	a0,-96(s0)
0x000000000001038c	62	   w0 = t & 0xFFFFFFFF;
=> 0x1038c <mulul64+96>:	sd	a0,-104(s0)
63	   k = t >> 32;
=> 0x10390 <mulul64+100>:	lwu	a0,-92(s0)
0x0000000000010394	63	   k = t >> 32;
=> 0x10394 <mulul64+104>:	sd	a0,-88(s0)
65	   t = u1*v0 + k;
=> 0x10398 <mulul64+108>:	ld	a0,-64(s0)
0x000000000001039c	65	   t = u1*v0 + k;
=> 0x1039c <mulul64+112>:	ld	a1,-72(s0)
0x00000000000103a0	65	   t = u1*v0 + k;
=> 0x103a0 <mulul64+116>:	mul	a0,a0,a1
0x00000000000103a4	65	   t = u1*v0 + k;
=> 0x103a4 <mulul64+120>:	ld	a1,-88(s0)
0x00000000000103a8	65	   t = u1*v0 + k;
=> 0x103a8 <mulul64+124>:	add	a0,a0,a1
0x00000000000103ac	65	   t = u1*v0 + k;
=> 0x103ac <mulul64+128>:	sd	a0,-96(s0)
66	   w1 = t & 0xFFFFFFFF;
=> 0x103b0 <mulul64+132>:	lwu	a0,-96(s0)
0x00000000000103b4	66	   w1 = t & 0xFFFFFFFF;
=> 0x103b4 <mulul64+136>:	sd	a0,-112(s0)
67	   w2 = t >> 32;
=> 0x103b8 <mulul64+140>:	lwu	a0,-92(s0)
0x00000000000103bc	67	   w2 = t >> 32;
=> 0x103bc <mulul64+144>:	sd	a0,-120(s0)
69	   t = u0*v1 + w1;
=> 0x103c0 <mulul64+148>:	ld	a0,-56(s0)
0x00000000000103c4	69	   t = u0*v1 + w1;
=> 0x103c4 <mulul64+152>:	ld	a1,-80(s0)
0x00000000000103c8	69	   t = u0*v1 + w1;
=> 0x103c8 <mulul64+156>:	mul	a0,a0,a1
0x00000000000103cc	69	   t = u0*v1 + w1;
=> 0x103cc <mulul64+160>:	ld	a1,-112(s0)
0x00000000000103d0	69	   t = u0*v1 + w1;
=> 0x103d0 <mulul64+164>:	add	a0,a0,a1
0x00000000000103d4	69	   t = u0*v1 + w1;
=> 0x103d4 <mulul64+168>:	sd	a0,-96(s0)
70	   k = t >> 32;
=> 0x103d8 <mulul64+172>:	lwu	a0,-92(s0)
0x00000000000103dc	70	   k = t >> 32;
=> 0x103dc <mulul64+176>:	sd	a0,-88(s0)
72	   *wlo = (t << 32) + w0;
=> 0x103e0 <mulul64+180>:	ld	a0,-96(s0)
0x00000000000103e4	72	   *wlo = (t << 32) + w0;
=> 0x103e4 <mulul64+184>:	slli	a0,a0,0x20
0x00000000000103e8	72	   *wlo = (t << 32) + w0;
=> 0x103e8 <mulul64+188>:	ld	a1,-104(s0)
0x00000000000103ec	72	   *wlo = (t << 32) + w0;
=> 0x103ec <mulul64+192>:	add	a0,a0,a1
0x00000000000103f0	72	   *wlo = (t << 32) + w0;
=> 0x103f0 <mulul64+196>:	ld	a1,-48(s0)
0x00000000000103f4	72	   *wlo = (t << 32) + w0;
=> 0x103f4 <mulul64+200>:	sd	a0,0(a1)
73	   *whi = u1*v1 + w2 + k;
=> 0x103f8 <mulul64+204>:	ld	a0,-64(s0)
0x00000000000103fc	73	   *whi = u1*v1 + w2 + k;
=> 0x103fc <mulul64+208>:	ld	a1,-80(s0)
0x0000000000010400	73	   *whi = u1*v1 + w2 + k;
=> 0x10400 <mulul64+212>:	mul	a0,a0,a1
0x0000000000010404	73	   *whi = u1*v1 + w2 + k;
=> 0x10404 <mulul64+216>:	ld	a1,-120(s0)
0x0000000000010408	73	   *whi = u1*v1 + w2 + k;
=> 0x10408 <mulul64+220>:	add	a0,a0,a1
0x000000000001040c	73	   *whi = u1*v1 + w2 + k;
=> 0x1040c <mulul64+224>:	ld	a1,-88(s0)
0x0000000000010410	73	   *whi = u1*v1 + w2 + k;
=> 0x10410 <mulul64+228>:	add	a0,a0,a1
0x0000000000010414	73	   *whi = u1*v1 + w2 + k;
=> 0x10414 <mulul64+232>:	ld	a1,-40(s0)
0x0000000000010418	73	   *whi = u1*v1 + w2 + k;
=> 0x10418 <mulul64+236>:	sd	a0,0(a1)
75	   return;
=> 0x1041c <mulul64+240>:	ld	s0,112(sp)
0x0000000000010420 in mulul64 (u=2516087340705735576, v=2516087340705735576, whi=0xfae849273928f89f, wlo=0x98202bea188ddca1) at mont64.c:75
75	   return;
=> 0x10420 <mulul64+244>:	ld	ra,120(sp)
0x0000000000010424	75	   return;
=> 0x10424 <mulul64+248>:	addi	sp,sp,128
0x0000000000010428	75	   return;
=> 0x10428 <mulul64+252>:	ld	ra,0(t6)
0x000000000001042c	75	   return;
=> 0x1042c <mulul64+256>:	addi	t6,t6,16
0x0000000000010430	75	   return;
=> 0x10430 <mulul64+260>:	ret
montmul (abar=2516087340705735576, bbar=2516087340705735576, m=18079781136890394783, mprime=10961809777454079137) at mont64.c:117
117	   tm = tlo*mprime;
=> 0x10550 <montmul+64>:	ld	a0,-64(s0)
0x0000000000010554	117	   tm = tlo*mprime;
=> 0x10554 <montmul+68>:	ld	a1,-48(s0)
0x0000000000010558	117	   tm = tlo*mprime;
=> 0x10558 <montmul+72>:	mul	a0,a0,a1
0x000000000001055c	117	   tm = tlo*mprime;
=> 0x1055c <montmul+76>:	sd	a0,-72(s0)
119	   mulul64(tm, m, &tmmhi, &tmmlo);   // tmm = tm*m.
=> 0x10560 <montmul+80>:	ld	a0,-72(s0)
0x0000000000010564	119	   mulul64(tm, m, &tmmhi, &tmmlo);   // tmm = tm*m.
=> 0x10564 <montmul+84>:	ld	a1,-40(s0)
0x0000000000010568	119	   mulul64(tm, m, &tmmhi, &tmmlo);   // tmm = tm*m.
=> 0x10568 <montmul+88>:	addi	a2,s0,-80
0x000000000001056c	119	   mulul64(tm, m, &tmmhi, &tmmlo);   // tmm = tm*m.
=> 0x1056c <montmul+92>:	addi	a3,s0,-88
0x0000000000010570	119	   mulul64(tm, m, &tmmhi, &tmmlo);   // tmm = tm*m.
=> 0x10570 <montmul+96>:	jal	ra,0x1032c <mulul64>
mulul64 (u=2516087340705735576, v=2516087340705735576, whi=0xfae849273928f89f, wlo=0x98202bea188ddca1) at mont64.c:54
54	   {
=> 0x1032c <mulul64>:	addi	t6,t6,-16
0x0000000000010330	54	   {
=> 0x10330 <mulul64+4>:	sd	ra,0(t6)
0x0000000000010334	54	   {
=> 0x10334 <mulul64+8>:	st	zero,0(t6)
0x0000000000010338	54	   {
=> 0x10338 <mulul64+12>:	addi	sp,sp,-128
0x000000000001033c	54	   {
=> 0x1033c <mulul64+16>:	sd	ra,120(sp)
0x0000000000010340	54	   {
=> 0x10340 <mulul64+20>:	sd	s0,112(sp)
0x0000000000010344	54	   {
=> 0x10344 <mulul64+24>:	addi	s0,sp,128
0x0000000000010348	54	   {
=> 0x10348 <mulul64+28>:	sd	a0,-24(s0)
0x000000000001034c	54	   {
=> 0x1034c <mulul64+32>:	sd	a1,-32(s0)
0x0000000000010350	54	   {
=> 0x10350 <mulul64+36>:	sd	a2,-40(s0)
0x0000000000010354	54	   {
=> 0x10354 <mulul64+40>:	sd	a3,-48(s0)
58	   u1 = u >> 32; u0 = u & 0xFFFFFFFF;
=> 0x10358 <mulul64+44>:	lwu	a0,-20(s0)
0x000000000001035c	58	   u1 = u >> 32; u0 = u & 0xFFFFFFFF;
=> 0x1035c <mulul64+48>:	sd	a0,-64(s0)
0x0000000000010360	58	   u1 = u >> 32; u0 = u & 0xFFFFFFFF;
=> 0x10360 <mulul64+52>:	lwu	a0,-24(s0)
0x0000000000010364	58	   u1 = u >> 32; u0 = u & 0xFFFFFFFF;
=> 0x10364 <mulul64+56>:	sd	a0,-56(s0)
59	   v1 = v >> 32; v0 = v & 0xFFFFFFFF;
=> 0x10368 <mulul64+60>:	lwu	a0,-28(s0)
0x000000000001036c	59	   v1 = v >> 32; v0 = v & 0xFFFFFFFF;
=> 0x1036c <mulul64+64>:	sd	a0,-80(s0)
0x0000000000010370	59	   v1 = v >> 32; v0 = v & 0xFFFFFFFF;
=> 0x10370 <mulul64+68>:	lwu	a0,-32(s0)
0x0000000000010374	59	   v1 = v >> 32; v0 = v & 0xFFFFFFFF;
=> 0x10374 <mulul64+72>:	sd	a0,-72(s0)
61	   t = u0*v0;
=> 0x10378 <mulul64+76>:	ld	a0,-56(s0)
0x000000000001037c	61	   t = u0*v0;
=> 0x1037c <mulul64+80>:	ld	a1,-72(s0)
0x0000000000010380	61	   t = u0*v0;
=> 0x10380 <mulul64+84>:	mul	a0,a0,a1
0x0000000000010384	61	   t = u0*v0;
=> 0x10384 <mulul64+88>:	sd	a0,-96(s0)
62	   w0 = t & 0xFFFFFFFF;
=> 0x10388 <mulul64+92>:	lwu	a0,-96(s0)
0x000000000001038c	62	   w0 = t & 0xFFFFFFFF;
=> 0x1038c <mulul64+96>:	sd	a0,-104(s0)
63	   k = t >> 32;
=> 0x10390 <mulul64+100>:	lwu	a0,-92(s0)
0x0000000000010394	63	   k = t >> 32;
=> 0x10394 <mulul64+104>:	sd	a0,-88(s0)
65	   t = u1*v0 + k;
=> 0x10398 <mulul64+108>:	ld	a0,-64(s0)
0x000000000001039c	65	   t = u1*v0 + k;
=> 0x1039c <mulul64+112>:	ld	a1,-72(s0)
0x00000000000103a0	65	   t = u1*v0 + k;
=> 0x103a0 <mulul64+116>:	mul	a0,a0,a1
0x00000000000103a4	65	   t = u1*v0 + k;
=> 0x103a4 <mulul64+120>:	ld	a1,-88(s0)
0x00000000000103a8	65	   t = u1*v0 + k;
=> 0x103a8 <mulul64+124>:	add	a0,a0,a1
0x00000000000103ac	65	   t = u1*v0 + k;
=> 0x103ac <mulul64+128>:	sd	a0,-96(s0)
66	   w1 = t & 0xFFFFFFFF;
=> 0x103b0 <mulul64+132>:	lwu	a0,-96(s0)
0x00000000000103b4	66	   w1 = t & 0xFFFFFFFF;
=> 0x103b4 <mulul64+136>:	sd	a0,-112(s0)
67	   w2 = t >> 32;
=> 0x103b8 <mulul64+140>:	lwu	a0,-92(s0)
0x00000000000103bc	67	   w2 = t >> 32;
=> 0x103bc <mulul64+144>:	sd	a0,-120(s0)
69	   t = u0*v1 + w1;
=> 0x103c0 <mulul64+148>:	ld	a0,-56(s0)
0x00000000000103c4	69	   t = u0*v1 + w1;
=> 0x103c4 <mulul64+152>:	ld	a1,-80(s0)
0x00000000000103c8	69	   t = u0*v1 + w1;
=> 0x103c8 <mulul64+156>:	mul	a0,a0,a1
0x00000000000103cc	69	   t = u0*v1 + w1;
=> 0x103cc <mulul64+160>:	ld	a1,-112(s0)
0x00000000000103d0	69	   t = u0*v1 + w1;
=> 0x103d0 <mulul64+164>:	add	a0,a0,a1
0x00000000000103d4	69	   t = u0*v1 + w1;
=> 0x103d4 <mulul64+168>:	sd	a0,-96(s0)
70	   k = t >> 32;
=> 0x103d8 <mulul64+172>:	lwu	a0,-92(s0)
0x00000000000103dc	70	   k = t >> 32;
=> 0x103dc <mulul64+176>:	sd	a0,-88(s0)
72	   *wlo = (t << 32) + w0;
=> 0x103e0 <mulul64+180>:	ld	a0,-96(s0)
0x00000000000103e4	72	   *wlo = (t << 32) + w0;
=> 0x103e4 <mulul64+184>:	slli	a0,a0,0x20
0x00000000000103e8	72	   *wlo = (t << 32) + w0;
=> 0x103e8 <mulul64+188>:	ld	a1,-104(s0)
0x00000000000103ec	72	   *wlo = (t << 32) + w0;
=> 0x103ec <mulul64+192>:	add	a0,a0,a1
0x00000000000103f0	72	   *wlo = (t << 32) + w0;
=> 0x103f0 <mulul64+196>:	ld	a1,-48(s0)
0x00000000000103f4	72	   *wlo = (t << 32) + w0;
=> 0x103f4 <mulul64+200>:	sd	a0,0(a1)
73	   *whi = u1*v1 + w2 + k;
=> 0x103f8 <mulul64+204>:	ld	a0,-64(s0)
0x00000000000103fc	73	   *whi = u1*v1 + w2 + k;
=> 0x103fc <mulul64+208>:	ld	a1,-80(s0)
0x0000000000010400	73	   *whi = u1*v1 + w2 + k;
=> 0x10400 <mulul64+212>:	mul	a0,a0,a1
0x0000000000010404	73	   *whi = u1*v1 + w2 + k;
=> 0x10404 <mulul64+216>:	ld	a1,-120(s0)
0x0000000000010408	73	   *whi = u1*v1 + w2 + k;
=> 0x10408 <mulul64+220>:	add	a0,a0,a1
0x000000000001040c	73	   *whi = u1*v1 + w2 + k;
=> 0x1040c <mulul64+224>:	ld	a1,-88(s0)
0x0000000000010410	73	   *whi = u1*v1 + w2 + k;
=> 0x10410 <mulul64+228>:	add	a0,a0,a1
0x0000000000010414	73	   *whi = u1*v1 + w2 + k;
=> 0x10414 <mulul64+232>:	ld	a1,-40(s0)
0x0000000000010418	73	   *whi = u1*v1 + w2 + k;
=> 0x10418 <mulul64+236>:	sd	a0,0(a1)
75	   return;
=> 0x1041c <mulul64+240>:	ld	s0,112(sp)
0x0000000000010420 in mulul64 (u=2516087340705735576, v=2516087340705735576, whi=0xfae849273928f89f, wlo=0x98202bea188ddca1) at mont64.c:75
75	   return;
=> 0x10420 <mulul64+244>:	ld	ra,120(sp)
0x0000000000010424	75	   return;
=> 0x10424 <mulul64+248>:	addi	sp,sp,128
0x0000000000010428	75	   return;
=> 0x10428 <mulul64+252>:	ld	ra,0(t6)
0x000000000001042c	75	   return;
=> 0x1042c <mulul64+256>:	addi	t6,t6,16
0x0000000000010430	75	   return;
=> 0x10430 <mulul64+260>:	ret
montmul (abar=2516087340705735576, bbar=2516087340705735576, m=18079781136890394783, mprime=10961809777454079137) at mont64.c:121
121	   ulo = tlo + tmmlo;                // Add t to tmm
=> 0x10574 <montmul+100>:	ld	a0,-64(s0)
0x0000000000010578	121	   ulo = tlo + tmmlo;                // Add t to tmm
=> 0x10578 <montmul+104>:	ld	a1,-88(s0)
0x000000000001057c	121	   ulo = tlo + tmmlo;                // Add t to tmm
=> 0x1057c <montmul+108>:	add	a0,a0,a1
0x0000000000010580	121	   ulo = tlo + tmmlo;                // Add t to tmm
=> 0x10580 <montmul+112>:	sd	a0,-104(s0)
122	   uhi = thi + tmmhi;                // (128-bit add).
=> 0x10584 <montmul+116>:	ld	a0,-56(s0)
0x0000000000010588	122	   uhi = thi + tmmhi;                // (128-bit add).
=> 0x10588 <montmul+120>:	ld	a1,-80(s0)
0x000000000001058c	122	   uhi = thi + tmmhi;                // (128-bit add).
=> 0x1058c <montmul+124>:	add	a0,a0,a1
0x0000000000010590	122	   uhi = thi + tmmhi;                // (128-bit add).
=> 0x10590 <montmul+128>:	sd	a0,-96(s0)
123	   if (ulo < tlo) uhi = uhi + 1;     // Allow for a carry.
=> 0x10594 <montmul+132>:	ld	a0,-104(s0)
0x0000000000010598	123	   if (ulo < tlo) uhi = uhi + 1;     // Allow for a carry.
=> 0x10598 <montmul+136>:	ld	a1,-64(s0)
0x000000000001059c	123	   if (ulo < tlo) uhi = uhi + 1;     // Allow for a carry.
=> 0x1059c <montmul+140>:	bgeu	a0,a1,0x105b4 <montmul+164>
0x00000000000105a0	123	   if (ulo < tlo) uhi = uhi + 1;     // Allow for a carry.
=> 0x105a0 <montmul+144>:	j	0x105a4 <montmul+148>
0x00000000000105a4	123	   if (ulo < tlo) uhi = uhi + 1;     // Allow for a carry.
=> 0x105a4 <montmul+148>:	ld	a0,-96(s0)
0x00000000000105a8	123	   if (ulo < tlo) uhi = uhi + 1;     // Allow for a carry.
=> 0x105a8 <montmul+152>:	addi	a0,a0,1
0x00000000000105ac	123	   if (ulo < tlo) uhi = uhi + 1;     // Allow for a carry.
=> 0x105ac <montmul+156>:	sd	a0,-96(s0)
0x00000000000105b0	123	   if (ulo < tlo) uhi = uhi + 1;     // Allow for a carry.
=> 0x105b0 <montmul+160>:	j	0x105b4 <montmul+164>
127	   ov = (uhi < thi) | ((uhi == thi) & (ulo < tlo));
=> 0x105b4 <montmul+164>:	ld	a0,-96(s0)
0x00000000000105b8	127	   ov = (uhi < thi) | ((uhi == thi) & (ulo < tlo));
=> 0x105b8 <montmul+168>:	ld	a1,-56(s0)
0x00000000000105bc	127	   ov = (uhi < thi) | ((uhi == thi) & (ulo < tlo));
=> 0x105bc <montmul+172>:	sltu	a2,a0,a1
0x00000000000105c0	127	   ov = (uhi < thi) | ((uhi == thi) & (ulo < tlo));
=> 0x105c0 <montmul+176>:	xor	a0,a0,a1
0x00000000000105c4	127	   ov = (uhi < thi) | ((uhi == thi) & (ulo < tlo));
=> 0x105c4 <montmul+180>:	seqz	a0,a0
0x00000000000105c8	127	   ov = (uhi < thi) | ((uhi == thi) & (ulo < tlo));
=> 0x105c8 <montmul+184>:	ld	a1,-104(s0)
0x00000000000105cc	127	   ov = (uhi < thi) | ((uhi == thi) & (ulo < tlo));
=> 0x105cc <montmul+188>:	ld	a3,-64(s0)
0x00000000000105d0	127	   ov = (uhi < thi) | ((uhi == thi) & (ulo < tlo));
=> 0x105d0 <montmul+192>:	sltu	a1,a1,a3
0x00000000000105d4	127	   ov = (uhi < thi) | ((uhi == thi) & (ulo < tlo));
=> 0x105d4 <montmul+196>:	and	a0,a0,a1
0x00000000000105d8	127	   ov = (uhi < thi) | ((uhi == thi) & (ulo < tlo));
=> 0x105d8 <montmul+200>:	or	a0,a2,a0
0x00000000000105dc	127	   ov = (uhi < thi) | ((uhi == thi) & (ulo < tlo));
=> 0x105dc <montmul+204>:	sd	a0,-112(s0)
129	   ulo = uhi;                   // Shift u right
=> 0x105e0 <montmul+208>:	ld	a0,-96(s0)
0x00000000000105e4	129	   ulo = uhi;                   // Shift u right
=> 0x105e4 <montmul+212>:	sd	a0,-104(s0)
0x00000000000105e8	129	   ulo = uhi;                   // Shift u right
=> 0x105e8 <montmul+216>:	li	a0,0
130	   uhi = 0;                     // 64 bit positions.
=> 0x105ec <montmul+220>:	sd	a0,-96(s0)
134	   ulo = ulo - (m & -(ov | (ulo >= m))); // Alternative
=> 0x105f0 <montmul+224>:	ld	a1,-104(s0)
0x00000000000105f4	134	   ulo = ulo - (m & -(ov | (ulo >= m))); // Alternative
=> 0x105f4 <montmul+228>:	ld	a2,-40(s0)
0x00000000000105f8	134	   ulo = ulo - (m & -(ov | (ulo >= m))); // Alternative
=> 0x105f8 <montmul+232>:	ld	a3,-112(s0)
0x00000000000105fc	134	   ulo = ulo - (m & -(ov | (ulo >= m))); // Alternative
=> 0x105fc <montmul+236>:	sltu	a4,a1,a2
0x0000000000010600	134	   ulo = ulo - (m & -(ov | (ulo >= m))); // Alternative
=> 0x10600 <montmul+240>:	xori	a4,a4,1
0x0000000000010604	134	   ulo = ulo - (m & -(ov | (ulo >= m))); // Alternative
=> 0x10604 <montmul+244>:	or	a3,a3,a4
0x0000000000010608	134	   ulo = ulo - (m & -(ov | (ulo >= m))); // Alternative
=> 0x10608 <montmul+248>:	sub	a0,a0,a3
0x000000000001060c	134	   ulo = ulo - (m & -(ov | (ulo >= m))); // Alternative
=> 0x1060c <montmul+252>:	and	a0,a2,a0
0x0000000000010610	134	   ulo = ulo - (m & -(ov | (ulo >= m))); // Alternative
=> 0x10610 <montmul+256>:	sub	a0,a1,a0
0x0000000000010614	134	   ulo = ulo - (m & -(ov | (ulo >= m))); // Alternative
=> 0x10614 <montmul+260>:	sd	a0,-104(s0)
137	   return ulo;
=> 0x10618 <montmul+264>:	ld	a0,-104(s0)
0x000000000001061c	137	   return ulo;
=> 0x1061c <montmul+268>:	ld	s0,96(sp)
0x0000000000010620 in montmul (abar=380896260630216687, bbar=1473642379452024179, m=18079781136890394783, mprime=9223372036854775808) at mont64.c:137
137	   return ulo;
=> 0x10620 <montmul+272>:	ld	ra,104(sp)
0x0000000000010624	137	   return ulo;
=> 0x10624 <montmul+276>:	addi	sp,sp,112
0x0000000000010628	137	   return ulo;
=> 0x10628 <montmul+280>:	ld	ra,0(t6)
0x000000000001062c	137	   return ulo;
=> 0x1062c <montmul+284>:	addi	t6,t6,16
0x0000000000010630	137	   return ulo;
=> 0x10630 <montmul+288>:	ret
0x00000000000108ac in benchmark () at mont64.c:260
260	   p = montmul(p, p, m, mprime);       /* Compute (a*b)**2 (mod m). */
=> 0x108ac <benchmark+376>:	sd	a0,-80(s0)
261	   p = montmul(p, p, m, mprime);       /* Compute (a*b)**4 (mod m). */
=> 0x108b0 <benchmark+380>:	ld	a0,-80(s0)
0x00000000000108b4	261	   p = montmul(p, p, m, mprime);       /* Compute (a*b)**4 (mod m). */
=> 0x108b4 <benchmark+384>:	ld	a2,-40(s0)
0x00000000000108b8	261	   p = montmul(p, p, m, mprime);       /* Compute (a*b)**4 (mod m). */
=> 0x108b8 <benchmark+388>:	ld	a3,-128(s0)
0x00000000000108bc	261	   p = montmul(p, p, m, mprime);       /* Compute (a*b)**4 (mod m). */
=> 0x108bc <benchmark+392>:	sd	a0,-192(s0)
0x00000000000108c0	261	   p = montmul(p, p, m, mprime);       /* Compute (a*b)**4 (mod m). */
=> 0x108c0 <benchmark+396>:	ld	a1,-192(s0)
0x00000000000108c4	261	   p = montmul(p, p, m, mprime);       /* Compute (a*b)**4 (mod m). */
=> 0x108c4 <benchmark+400>:	jal	ra,0x10510 <montmul>
montmul (abar=380896260630216687, bbar=1473642379452024179, m=18079781136890394783, mprime=9223372036854775808) at mont64.c:104
104	               uint64 mprime) {
=> 0x10510 <montmul>:	addi	t6,t6,-16
0x0000000000010514	104	               uint64 mprime) {
=> 0x10514 <montmul+4>:	sd	ra,0(t6)
0x0000000000010518	104	               uint64 mprime) {
=> 0x10518 <montmul+8>:	st	zero,0(t6)
0x000000000001051c	104	               uint64 mprime) {
=> 0x1051c <montmul+12>:	addi	sp,sp,-112
0x0000000000010520	104	               uint64 mprime) {
=> 0x10520 <montmul+16>:	sd	ra,104(sp)
0x0000000000010524	104	               uint64 mprime) {
=> 0x10524 <montmul+20>:	sd	s0,96(sp)
0x0000000000010528	104	               uint64 mprime) {
=> 0x10528 <montmul+24>:	addi	s0,sp,112
0x000000000001052c	104	               uint64 mprime) {
=> 0x1052c <montmul+28>:	sd	a0,-24(s0)
0x0000000000010530	104	               uint64 mprime) {
=> 0x10530 <montmul+32>:	sd	a1,-32(s0)
0x0000000000010534	104	               uint64 mprime) {
=> 0x10534 <montmul+36>:	sd	a2,-40(s0)
0x0000000000010538	104	               uint64 mprime) {
=> 0x10538 <montmul+40>:	sd	a3,-48(s0)
110	   mulul64(abar, bbar, &thi, &tlo);  // t = abar*bbar.
=> 0x1053c <montmul+44>:	ld	a0,-24(s0)
0x0000000000010540	110	   mulul64(abar, bbar, &thi, &tlo);  // t = abar*bbar.
=> 0x10540 <montmul+48>:	ld	a1,-32(s0)
0x0000000000010544	110	   mulul64(abar, bbar, &thi, &tlo);  // t = abar*bbar.
=> 0x10544 <montmul+52>:	addi	a2,s0,-56
0x0000000000010548	110	   mulul64(abar, bbar, &thi, &tlo);  // t = abar*bbar.
=> 0x10548 <montmul+56>:	addi	a3,s0,-64
0x000000000001054c	110	   mulul64(abar, bbar, &thi, &tlo);  // t = abar*bbar.
=> 0x1054c <montmul+60>:	jal	ra,0x1032c <mulul64>
mulul64 (u=725726924961571353, v=725726924961571353, whi=0xfae849273928f89f, wlo=0x98202bea188ddca1) at mont64.c:54
54	   {
=> 0x1032c <mulul64>:	addi	t6,t6,-16
0x0000000000010330	54	   {
=> 0x10330 <mulul64+4>:	sd	ra,0(t6)
0x0000000000010334	54	   {
=> 0x10334 <mulul64+8>:	st	zero,0(t6)
0x0000000000010338	54	   {
=> 0x10338 <mulul64+12>:	addi	sp,sp,-128
0x000000000001033c	54	   {
=> 0x1033c <mulul64+16>:	sd	ra,120(sp)
0x0000000000010340	54	   {
=> 0x10340 <mulul64+20>:	sd	s0,112(sp)
0x0000000000010344	54	   {
=> 0x10344 <mulul64+24>:	addi	s0,sp,128
0x0000000000010348	54	   {
=> 0x10348 <mulul64+28>:	sd	a0,-24(s0)
0x000000000001034c	54	   {
=> 0x1034c <mulul64+32>:	sd	a1,-32(s0)
0x0000000000010350	54	   {
=> 0x10350 <mulul64+36>:	sd	a2,-40(s0)
0x0000000000010354	54	   {
=> 0x10354 <mulul64+40>:	sd	a3,-48(s0)
58	   u1 = u >> 32; u0 = u & 0xFFFFFFFF;
=> 0x10358 <mulul64+44>:	lwu	a0,-20(s0)
0x000000000001035c	58	   u1 = u >> 32; u0 = u & 0xFFFFFFFF;
=> 0x1035c <mulul64+48>:	sd	a0,-64(s0)
0x0000000000010360	58	   u1 = u >> 32; u0 = u & 0xFFFFFFFF;
=> 0x10360 <mulul64+52>:	lwu	a0,-24(s0)
0x0000000000010364	58	   u1 = u >> 32; u0 = u & 0xFFFFFFFF;
=> 0x10364 <mulul64+56>:	sd	a0,-56(s0)
59	   v1 = v >> 32; v0 = v & 0xFFFFFFFF;
=> 0x10368 <mulul64+60>:	lwu	a0,-28(s0)
0x000000000001036c	59	   v1 = v >> 32; v0 = v & 0xFFFFFFFF;
=> 0x1036c <mulul64+64>:	sd	a0,-80(s0)
0x0000000000010370	59	   v1 = v >> 32; v0 = v & 0xFFFFFFFF;
=> 0x10370 <mulul64+68>:	lwu	a0,-32(s0)
0x0000000000010374	59	   v1 = v >> 32; v0 = v & 0xFFFFFFFF;
=> 0x10374 <mulul64+72>:	sd	a0,-72(s0)
61	   t = u0*v0;
=> 0x10378 <mulul64+76>:	ld	a0,-56(s0)
0x000000000001037c	61	   t = u0*v0;
=> 0x1037c <mulul64+80>:	ld	a1,-72(s0)
0x0000000000010380	61	   t = u0*v0;
=> 0x10380 <mulul64+84>:	mul	a0,a0,a1
0x0000000000010384	61	   t = u0*v0;
=> 0x10384 <mulul64+88>:	sd	a0,-96(s0)
62	   w0 = t & 0xFFFFFFFF;
=> 0x10388 <mulul64+92>:	lwu	a0,-96(s0)
0x000000000001038c	62	   w0 = t & 0xFFFFFFFF;
=> 0x1038c <mulul64+96>:	sd	a0,-104(s0)
63	   k = t >> 32;
=> 0x10390 <mulul64+100>:	lwu	a0,-92(s0)
0x0000000000010394	63	   k = t >> 32;
=> 0x10394 <mulul64+104>:	sd	a0,-88(s0)
65	   t = u1*v0 + k;
=> 0x10398 <mulul64+108>:	ld	a0,-64(s0)
0x000000000001039c	65	   t = u1*v0 + k;
=> 0x1039c <mulul64+112>:	ld	a1,-72(s0)
0x00000000000103a0	65	   t = u1*v0 + k;
=> 0x103a0 <mulul64+116>:	mul	a0,a0,a1
0x00000000000103a4	65	   t = u1*v0 + k;
=> 0x103a4 <mulul64+120>:	ld	a1,-88(s0)
0x00000000000103a8	65	   t = u1*v0 + k;
=> 0x103a8 <mulul64+124>:	add	a0,a0,a1
0x00000000000103ac	65	   t = u1*v0 + k;
=> 0x103ac <mulul64+128>:	sd	a0,-96(s0)
66	   w1 = t & 0xFFFFFFFF;
=> 0x103b0 <mulul64+132>:	lwu	a0,-96(s0)
0x00000000000103b4	66	   w1 = t & 0xFFFFFFFF;
=> 0x103b4 <mulul64+136>:	sd	a0,-112(s0)
67	   w2 = t >> 32;
=> 0x103b8 <mulul64+140>:	lwu	a0,-92(s0)
0x00000000000103bc	67	   w2 = t >> 32;
=> 0x103bc <mulul64+144>:	sd	a0,-120(s0)
69	   t = u0*v1 + w1;
=> 0x103c0 <mulul64+148>:	ld	a0,-56(s0)
0x00000000000103c4	69	   t = u0*v1 + w1;
=> 0x103c4 <mulul64+152>:	ld	a1,-80(s0)
0x00000000000103c8	69	   t = u0*v1 + w1;
=> 0x103c8 <mulul64+156>:	mul	a0,a0,a1
0x00000000000103cc	69	   t = u0*v1 + w1;
=> 0x103cc <mulul64+160>:	ld	a1,-112(s0)
0x00000000000103d0	69	   t = u0*v1 + w1;
=> 0x103d0 <mulul64+164>:	add	a0,a0,a1
0x00000000000103d4	69	   t = u0*v1 + w1;
=> 0x103d4 <mulul64+168>:	sd	a0,-96(s0)
70	   k = t >> 32;
=> 0x103d8 <mulul64+172>:	lwu	a0,-92(s0)
0x00000000000103dc	70	   k = t >> 32;
=> 0x103dc <mulul64+176>:	sd	a0,-88(s0)
72	   *wlo = (t << 32) + w0;
=> 0x103e0 <mulul64+180>:	ld	a0,-96(s0)
0x00000000000103e4	72	   *wlo = (t << 32) + w0;
=> 0x103e4 <mulul64+184>:	slli	a0,a0,0x20
0x00000000000103e8	72	   *wlo = (t << 32) + w0;
=> 0x103e8 <mulul64+188>:	ld	a1,-104(s0)
0x00000000000103ec	72	   *wlo = (t << 32) + w0;
=> 0x103ec <mulul64+192>:	add	a0,a0,a1
0x00000000000103f0	72	   *wlo = (t << 32) + w0;
=> 0x103f0 <mulul64+196>:	ld	a1,-48(s0)
0x00000000000103f4	72	   *wlo = (t << 32) + w0;
=> 0x103f4 <mulul64+200>:	sd	a0,0(a1)
73	   *whi = u1*v1 + w2 + k;
=> 0x103f8 <mulul64+204>:	ld	a0,-64(s0)
0x00000000000103fc	73	   *whi = u1*v1 + w2 + k;
=> 0x103fc <mulul64+208>:	ld	a1,-80(s0)
0x0000000000010400	73	   *whi = u1*v1 + w2 + k;
=> 0x10400 <mulul64+212>:	mul	a0,a0,a1
0x0000000000010404	73	   *whi = u1*v1 + w2 + k;
=> 0x10404 <mulul64+216>:	ld	a1,-120(s0)
0x0000000000010408	73	   *whi = u1*v1 + w2 + k;
=> 0x10408 <mulul64+220>:	add	a0,a0,a1
0x000000000001040c	73	   *whi = u1*v1 + w2 + k;
=> 0x1040c <mulul64+224>:	ld	a1,-88(s0)
0x0000000000010410	73	   *whi = u1*v1 + w2 + k;
=> 0x10410 <mulul64+228>:	add	a0,a0,a1
0x0000000000010414	73	   *whi = u1*v1 + w2 + k;
=> 0x10414 <mulul64+232>:	ld	a1,-40(s0)
0x0000000000010418	73	   *whi = u1*v1 + w2 + k;
=> 0x10418 <mulul64+236>:	sd	a0,0(a1)
75	   return;
=> 0x1041c <mulul64+240>:	ld	s0,112(sp)
0x0000000000010420 in mulul64 (u=725726924961571353, v=725726924961571353, whi=0xfae849273928f89f, wlo=0x98202bea188ddca1) at mont64.c:75
75	   return;
=> 0x10420 <mulul64+244>:	ld	ra,120(sp)
0x0000000000010424	75	   return;
=> 0x10424 <mulul64+248>:	addi	sp,sp,128
0x0000000000010428	75	   return;
=> 0x10428 <mulul64+252>:	ld	ra,0(t6)
0x000000000001042c	75	   return;
=> 0x1042c <mulul64+256>:	addi	t6,t6,16
0x0000000000010430	75	   return;
=> 0x10430 <mulul64+260>:	ret
montmul (abar=725726924961571353, bbar=725726924961571353, m=18079781136890394783, mprime=10961809777454079137) at mont64.c:117
117	   tm = tlo*mprime;
=> 0x10550 <montmul+64>:	ld	a0,-64(s0)
0x0000000000010554	117	   tm = tlo*mprime;
=> 0x10554 <montmul+68>:	ld	a1,-48(s0)
0x0000000000010558	117	   tm = tlo*mprime;
=> 0x10558 <montmul+72>:	mul	a0,a0,a1
0x000000000001055c	117	   tm = tlo*mprime;
=> 0x1055c <montmul+76>:	sd	a0,-72(s0)
119	   mulul64(tm, m, &tmmhi, &tmmlo);   // tmm = tm*m.
=> 0x10560 <montmul+80>:	ld	a0,-72(s0)
0x0000000000010564	119	   mulul64(tm, m, &tmmhi, &tmmlo);   // tmm = tm*m.
=> 0x10564 <montmul+84>:	ld	a1,-40(s0)
0x0000000000010568	119	   mulul64(tm, m, &tmmhi, &tmmlo);   // tmm = tm*m.
=> 0x10568 <montmul+88>:	addi	a2,s0,-80
0x000000000001056c	119	   mulul64(tm, m, &tmmhi, &tmmlo);   // tmm = tm*m.
=> 0x1056c <montmul+92>:	addi	a3,s0,-88
0x0000000000010570	119	   mulul64(tm, m, &tmmhi, &tmmlo);   // tmm = tm*m.
=> 0x10570 <montmul+96>:	jal	ra,0x1032c <mulul64>
mulul64 (u=725726924961571353, v=725726924961571353, whi=0xfae849273928f89f, wlo=0x98202bea188ddca1) at mont64.c:54
54	   {
=> 0x1032c <mulul64>:	addi	t6,t6,-16
0x0000000000010330	54	   {
=> 0x10330 <mulul64+4>:	sd	ra,0(t6)
0x0000000000010334	54	   {
=> 0x10334 <mulul64+8>:	st	zero,0(t6)
0x0000000000010338	54	   {
=> 0x10338 <mulul64+12>:	addi	sp,sp,-128
0x000000000001033c	54	   {
=> 0x1033c <mulul64+16>:	sd	ra,120(sp)
0x0000000000010340	54	   {
=> 0x10340 <mulul64+20>:	sd	s0,112(sp)
0x0000000000010344	54	   {
=> 0x10344 <mulul64+24>:	addi	s0,sp,128
0x0000000000010348	54	   {
=> 0x10348 <mulul64+28>:	sd	a0,-24(s0)
0x000000000001034c	54	   {
=> 0x1034c <mulul64+32>:	sd	a1,-32(s0)
0x0000000000010350	54	   {
=> 0x10350 <mulul64+36>:	sd	a2,-40(s0)
0x0000000000010354	54	   {
=> 0x10354 <mulul64+40>:	sd	a3,-48(s0)
58	   u1 = u >> 32; u0 = u & 0xFFFFFFFF;
=> 0x10358 <mulul64+44>:	lwu	a0,-20(s0)
0x000000000001035c	58	   u1 = u >> 32; u0 = u & 0xFFFFFFFF;
=> 0x1035c <mulul64+48>:	sd	a0,-64(s0)
0x0000000000010360	58	   u1 = u >> 32; u0 = u & 0xFFFFFFFF;
=> 0x10360 <mulul64+52>:	lwu	a0,-24(s0)
0x0000000000010364	58	   u1 = u >> 32; u0 = u & 0xFFFFFFFF;
=> 0x10364 <mulul64+56>:	sd	a0,-56(s0)
59	   v1 = v >> 32; v0 = v & 0xFFFFFFFF;
=> 0x10368 <mulul64+60>:	lwu	a0,-28(s0)
0x000000000001036c	59	   v1 = v >> 32; v0 = v & 0xFFFFFFFF;
=> 0x1036c <mulul64+64>:	sd	a0,-80(s0)
0x0000000000010370	59	   v1 = v >> 32; v0 = v & 0xFFFFFFFF;
=> 0x10370 <mulul64+68>:	lwu	a0,-32(s0)
0x0000000000010374	59	   v1 = v >> 32; v0 = v & 0xFFFFFFFF;
=> 0x10374 <mulul64+72>:	sd	a0,-72(s0)
61	   t = u0*v0;
=> 0x10378 <mulul64+76>:	ld	a0,-56(s0)
0x000000000001037c	61	   t = u0*v0;
=> 0x1037c <mulul64+80>:	ld	a1,-72(s0)
0x0000000000010380	61	   t = u0*v0;
=> 0x10380 <mulul64+84>:	mul	a0,a0,a1
0x0000000000010384	61	   t = u0*v0;
=> 0x10384 <mulul64+88>:	sd	a0,-96(s0)
62	   w0 = t & 0xFFFFFFFF;
=> 0x10388 <mulul64+92>:	lwu	a0,-96(s0)
0x000000000001038c	62	   w0 = t & 0xFFFFFFFF;
=> 0x1038c <mulul64+96>:	sd	a0,-104(s0)
63	   k = t >> 32;
=> 0x10390 <mulul64+100>:	lwu	a0,-92(s0)
0x0000000000010394	63	   k = t >> 32;
=> 0x10394 <mulul64+104>:	sd	a0,-88(s0)
65	   t = u1*v0 + k;
=> 0x10398 <mulul64+108>:	ld	a0,-64(s0)
0x000000000001039c	65	   t = u1*v0 + k;
=> 0x1039c <mulul64+112>:	ld	a1,-72(s0)
0x00000000000103a0	65	   t = u1*v0 + k;
=> 0x103a0 <mulul64+116>:	mul	a0,a0,a1
0x00000000000103a4	65	   t = u1*v0 + k;
=> 0x103a4 <mulul64+120>:	ld	a1,-88(s0)
0x00000000000103a8	65	   t = u1*v0 + k;
=> 0x103a8 <mulul64+124>:	add	a0,a0,a1
0x00000000000103ac	65	   t = u1*v0 + k;
=> 0x103ac <mulul64+128>:	sd	a0,-96(s0)
66	   w1 = t & 0xFFFFFFFF;
=> 0x103b0 <mulul64+132>:	lwu	a0,-96(s0)
0x00000000000103b4	66	   w1 = t & 0xFFFFFFFF;
=> 0x103b4 <mulul64+136>:	sd	a0,-112(s0)
67	   w2 = t >> 32;
=> 0x103b8 <mulul64+140>:	lwu	a0,-92(s0)
0x00000000000103bc	67	   w2 = t >> 32;
=> 0x103bc <mulul64+144>:	sd	a0,-120(s0)
69	   t = u0*v1 + w1;
=> 0x103c0 <mulul64+148>:	ld	a0,-56(s0)
0x00000000000103c4	69	   t = u0*v1 + w1;
=> 0x103c4 <mulul64+152>:	ld	a1,-80(s0)
0x00000000000103c8	69	   t = u0*v1 + w1;
=> 0x103c8 <mulul64+156>:	mul	a0,a0,a1
0x00000000000103cc	69	   t = u0*v1 + w1;
=> 0x103cc <mulul64+160>:	ld	a1,-112(s0)
0x00000000000103d0	69	   t = u0*v1 + w1;
=> 0x103d0 <mulul64+164>:	add	a0,a0,a1
0x00000000000103d4	69	   t = u0*v1 + w1;
=> 0x103d4 <mulul64+168>:	sd	a0,-96(s0)
70	   k = t >> 32;
=> 0x103d8 <mulul64+172>:	lwu	a0,-92(s0)
0x00000000000103dc	70	   k = t >> 32;
=> 0x103dc <mulul64+176>:	sd	a0,-88(s0)
72	   *wlo = (t << 32) + w0;
=> 0x103e0 <mulul64+180>:	ld	a0,-96(s0)
0x00000000000103e4	72	   *wlo = (t << 32) + w0;
=> 0x103e4 <mulul64+184>:	slli	a0,a0,0x20
0x00000000000103e8	72	   *wlo = (t << 32) + w0;
=> 0x103e8 <mulul64+188>:	ld	a1,-104(s0)
0x00000000000103ec	72	   *wlo = (t << 32) + w0;
=> 0x103ec <mulul64+192>:	add	a0,a0,a1
0x00000000000103f0	72	   *wlo = (t << 32) + w0;
=> 0x103f0 <mulul64+196>:	ld	a1,-48(s0)
0x00000000000103f4	72	   *wlo = (t << 32) + w0;
=> 0x103f4 <mulul64+200>:	sd	a0,0(a1)
73	   *whi = u1*v1 + w2 + k;
=> 0x103f8 <mulul64+204>:	ld	a0,-64(s0)
0x00000000000103fc	73	   *whi = u1*v1 + w2 + k;
=> 0x103fc <mulul64+208>:	ld	a1,-80(s0)
0x0000000000010400	73	   *whi = u1*v1 + w2 + k;
=> 0x10400 <mulul64+212>:	mul	a0,a0,a1
0x0000000000010404	73	   *whi = u1*v1 + w2 + k;
=> 0x10404 <mulul64+216>:	ld	a1,-120(s0)
0x0000000000010408	73	   *whi = u1*v1 + w2 + k;
=> 0x10408 <mulul64+220>:	add	a0,a0,a1
0x000000000001040c	73	   *whi = u1*v1 + w2 + k;
=> 0x1040c <mulul64+224>:	ld	a1,-88(s0)
0x0000000000010410	73	   *whi = u1*v1 + w2 + k;
=> 0x10410 <mulul64+228>:	add	a0,a0,a1
0x0000000000010414	73	   *whi = u1*v1 + w2 + k;
=> 0x10414 <mulul64+232>:	ld	a1,-40(s0)
0x0000000000010418	73	   *whi = u1*v1 + w2 + k;
=> 0x10418 <mulul64+236>:	sd	a0,0(a1)
75	   return;
=> 0x1041c <mulul64+240>:	ld	s0,112(sp)
0x0000000000010420 in mulul64 (u=725726924961571353, v=725726924961571353, whi=0xfae849273928f89f, wlo=0x98202bea188ddca1) at mont64.c:75
75	   return;
=> 0x10420 <mulul64+244>:	ld	ra,120(sp)
0x0000000000010424	75	   return;
=> 0x10424 <mulul64+248>:	addi	sp,sp,128
0x0000000000010428	75	   return;
=> 0x10428 <mulul64+252>:	ld	ra,0(t6)
0x000000000001042c	75	   return;
=> 0x1042c <mulul64+256>:	addi	t6,t6,16
0x0000000000010430	75	   return;
=> 0x10430 <mulul64+260>:	ret
montmul (abar=725726924961571353, bbar=725726924961571353, m=18079781136890394783, mprime=10961809777454079137) at mont64.c:121
121	   ulo = tlo + tmmlo;                // Add t to tmm
=> 0x10574 <montmul+100>:	ld	a0,-64(s0)
0x0000000000010578	121	   ulo = tlo + tmmlo;                // Add t to tmm
=> 0x10578 <montmul+104>:	ld	a1,-88(s0)
0x000000000001057c	121	   ulo = tlo + tmmlo;                // Add t to tmm
=> 0x1057c <montmul+108>:	add	a0,a0,a1
0x0000000000010580	121	   ulo = tlo + tmmlo;                // Add t to tmm
=> 0x10580 <montmul+112>:	sd	a0,-104(s0)
122	   uhi = thi + tmmhi;                // (128-bit add).
=> 0x10584 <montmul+116>:	ld	a0,-56(s0)
0x0000000000010588	122	   uhi = thi + tmmhi;                // (128-bit add).
=> 0x10588 <montmul+120>:	ld	a1,-80(s0)
0x000000000001058c	122	   uhi = thi + tmmhi;                // (128-bit add).
=> 0x1058c <montmul+124>:	add	a0,a0,a1
0x0000000000010590	122	   uhi = thi + tmmhi;                // (128-bit add).
=> 0x10590 <montmul+128>:	sd	a0,-96(s0)
123	   if (ulo < tlo) uhi = uhi + 1;     // Allow for a carry.
=> 0x10594 <montmul+132>:	ld	a0,-104(s0)
0x0000000000010598	123	   if (ulo < tlo) uhi = uhi + 1;     // Allow for a carry.
=> 0x10598 <montmul+136>:	ld	a1,-64(s0)
0x000000000001059c	123	   if (ulo < tlo) uhi = uhi + 1;     // Allow for a carry.
=> 0x1059c <montmul+140>:	bgeu	a0,a1,0x105b4 <montmul+164>
0x00000000000105a0	123	   if (ulo < tlo) uhi = uhi + 1;     // Allow for a carry.
=> 0x105a0 <montmul+144>:	j	0x105a4 <montmul+148>
0x00000000000105a4	123	   if (ulo < tlo) uhi = uhi + 1;     // Allow for a carry.
=> 0x105a4 <montmul+148>:	ld	a0,-96(s0)
0x00000000000105a8	123	   if (ulo < tlo) uhi = uhi + 1;     // Allow for a carry.
=> 0x105a8 <montmul+152>:	addi	a0,a0,1
0x00000000000105ac	123	   if (ulo < tlo) uhi = uhi + 1;     // Allow for a carry.
=> 0x105ac <montmul+156>:	sd	a0,-96(s0)
0x00000000000105b0	123	   if (ulo < tlo) uhi = uhi + 1;     // Allow for a carry.
=> 0x105b0 <montmul+160>:	j	0x105b4 <montmul+164>
127	   ov = (uhi < thi) | ((uhi == thi) & (ulo < tlo));
=> 0x105b4 <montmul+164>:	ld	a0,-96(s0)
0x00000000000105b8	127	   ov = (uhi < thi) | ((uhi == thi) & (ulo < tlo));
=> 0x105b8 <montmul+168>:	ld	a1,-56(s0)
0x00000000000105bc	127	   ov = (uhi < thi) | ((uhi == thi) & (ulo < tlo));
=> 0x105bc <montmul+172>:	sltu	a2,a0,a1
0x00000000000105c0	127	   ov = (uhi < thi) | ((uhi == thi) & (ulo < tlo));
=> 0x105c0 <montmul+176>:	xor	a0,a0,a1
0x00000000000105c4	127	   ov = (uhi < thi) | ((uhi == thi) & (ulo < tlo));
=> 0x105c4 <montmul+180>:	seqz	a0,a0
0x00000000000105c8	127	   ov = (uhi < thi) | ((uhi == thi) & (ulo < tlo));
=> 0x105c8 <montmul+184>:	ld	a1,-104(s0)
0x00000000000105cc	127	   ov = (uhi < thi) | ((uhi == thi) & (ulo < tlo));
=> 0x105cc <montmul+188>:	ld	a3,-64(s0)
0x00000000000105d0	127	   ov = (uhi < thi) | ((uhi == thi) & (ulo < tlo));
=> 0x105d0 <montmul+192>:	sltu	a1,a1,a3
0x00000000000105d4	127	   ov = (uhi < thi) | ((uhi == thi) & (ulo < tlo));
=> 0x105d4 <montmul+196>:	and	a0,a0,a1
0x00000000000105d8	127	   ov = (uhi < thi) | ((uhi == thi) & (ulo < tlo));
=> 0x105d8 <montmul+200>:	or	a0,a2,a0
0x00000000000105dc	127	   ov = (uhi < thi) | ((uhi == thi) & (ulo < tlo));
=> 0x105dc <montmul+204>:	sd	a0,-112(s0)
129	   ulo = uhi;                   // Shift u right
=> 0x105e0 <montmul+208>:	ld	a0,-96(s0)
0x00000000000105e4	129	   ulo = uhi;                   // Shift u right
=> 0x105e4 <montmul+212>:	sd	a0,-104(s0)
0x00000000000105e8	129	   ulo = uhi;                   // Shift u right
=> 0x105e8 <montmul+216>:	li	a0,0
130	   uhi = 0;                     // 64 bit positions.
=> 0x105ec <montmul+220>:	sd	a0,-96(s0)
134	   ulo = ulo - (m & -(ov | (ulo >= m))); // Alternative
=> 0x105f0 <montmul+224>:	ld	a1,-104(s0)
0x00000000000105f4	134	   ulo = ulo - (m & -(ov | (ulo >= m))); // Alternative
=> 0x105f4 <montmul+228>:	ld	a2,-40(s0)
0x00000000000105f8	134	   ulo = ulo - (m & -(ov | (ulo >= m))); // Alternative
=> 0x105f8 <montmul+232>:	ld	a3,-112(s0)
0x00000000000105fc	134	   ulo = ulo - (m & -(ov | (ulo >= m))); // Alternative
=> 0x105fc <montmul+236>:	sltu	a4,a1,a2
0x0000000000010600	134	   ulo = ulo - (m & -(ov | (ulo >= m))); // Alternative
=> 0x10600 <montmul+240>:	xori	a4,a4,1
0x0000000000010604	134	   ulo = ulo - (m & -(ov | (ulo >= m))); // Alternative
=> 0x10604 <montmul+244>:	or	a3,a3,a4
0x0000000000010608	134	   ulo = ulo - (m & -(ov | (ulo >= m))); // Alternative
=> 0x10608 <montmul+248>:	sub	a0,a0,a3
0x000000000001060c	134	   ulo = ulo - (m & -(ov | (ulo >= m))); // Alternative
=> 0x1060c <montmul+252>:	and	a0,a2,a0
0x0000000000010610	134	   ulo = ulo - (m & -(ov | (ulo >= m))); // Alternative
=> 0x10610 <montmul+256>:	sub	a0,a1,a0
0x0000000000010614	134	   ulo = ulo - (m & -(ov | (ulo >= m))); // Alternative
=> 0x10614 <montmul+260>:	sd	a0,-104(s0)
137	   return ulo;
=> 0x10618 <montmul+264>:	ld	a0,-104(s0)
0x000000000001061c	137	   return ulo;
=> 0x1061c <montmul+268>:	ld	s0,96(sp)
0x0000000000010620 in montmul (abar=380896260630216687, bbar=1473642379452024179, m=18079781136890394783, mprime=9223372036854775808) at mont64.c:137
137	   return ulo;
=> 0x10620 <montmul+272>:	ld	ra,104(sp)
0x0000000000010624	137	   return ulo;
=> 0x10624 <montmul+276>:	addi	sp,sp,112
0x0000000000010628	137	   return ulo;
=> 0x10628 <montmul+280>:	ld	ra,0(t6)
0x000000000001062c	137	   return ulo;
=> 0x1062c <montmul+284>:	addi	t6,t6,16
0x0000000000010630	137	   return ulo;
=> 0x10630 <montmul+288>:	ret
0x00000000000108c8 in benchmark () at mont64.c:261
261	   p = montmul(p, p, m, mprime);       /* Compute (a*b)**4 (mod m). */
=> 0x108c8 <benchmark+404>:	sd	a0,-80(s0)
265	   mulul64(p, rinv, &phi, &plo);
=> 0x108cc <benchmark+408>:	ld	a0,-80(s0)
0x00000000000108d0	265	   mulul64(p, rinv, &phi, &plo);
=> 0x108d0 <benchmark+412>:	ld	a1,-120(s0)
0x00000000000108d4	265	   mulul64(p, rinv, &phi, &plo);
=> 0x108d4 <benchmark+416>:	addi	a2,s0,-104
0x00000000000108d8	265	   mulul64(p, rinv, &phi, &plo);
=> 0x108d8 <benchmark+420>:	addi	a3,s0,-112
0x00000000000108dc	265	   mulul64(p, rinv, &phi, &plo);
=> 0x108dc <benchmark+424>:	jal	ra,0x1032c <mulul64>
mulul64 (u=380896260630216687, v=1473642379452024179, whi=0xfae849273928f89f, wlo=0x8000000000000000) at mont64.c:54
54	   {
=> 0x1032c <mulul64>:	addi	t6,t6,-16
0x0000000000010330	54	   {
=> 0x10330 <mulul64+4>:	sd	ra,0(t6)
0x0000000000010334	54	   {
=> 0x10334 <mulul64+8>:	st	zero,0(t6)
0x0000000000010338	54	   {
=> 0x10338 <mulul64+12>:	addi	sp,sp,-128
0x000000000001033c	54	   {
=> 0x1033c <mulul64+16>:	sd	ra,120(sp)
0x0000000000010340	54	   {
=> 0x10340 <mulul64+20>:	sd	s0,112(sp)
0x0000000000010344	54	   {
=> 0x10344 <mulul64+24>:	addi	s0,sp,128
0x0000000000010348	54	   {
=> 0x10348 <mulul64+28>:	sd	a0,-24(s0)
0x000000000001034c	54	   {
=> 0x1034c <mulul64+32>:	sd	a1,-32(s0)
0x0000000000010350	54	   {
=> 0x10350 <mulul64+36>:	sd	a2,-40(s0)
0x0000000000010354	54	   {
=> 0x10354 <mulul64+40>:	sd	a3,-48(s0)
58	   u1 = u >> 32; u0 = u & 0xFFFFFFFF;
=> 0x10358 <mulul64+44>:	lwu	a0,-20(s0)
0x000000000001035c	58	   u1 = u >> 32; u0 = u & 0xFFFFFFFF;
=> 0x1035c <mulul64+48>:	sd	a0,-64(s0)
0x0000000000010360	58	   u1 = u >> 32; u0 = u & 0xFFFFFFFF;
=> 0x10360 <mulul64+52>:	lwu	a0,-24(s0)
0x0000000000010364	58	   u1 = u >> 32; u0 = u & 0xFFFFFFFF;
=> 0x10364 <mulul64+56>:	sd	a0,-56(s0)
59	   v1 = v >> 32; v0 = v & 0xFFFFFFFF;
=> 0x10368 <mulul64+60>:	lwu	a0,-28(s0)
0x000000000001036c	59	   v1 = v >> 32; v0 = v & 0xFFFFFFFF;
=> 0x1036c <mulul64+64>:	sd	a0,-80(s0)
0x0000000000010370	59	   v1 = v >> 32; v0 = v & 0xFFFFFFFF;
=> 0x10370 <mulul64+68>:	lwu	a0,-32(s0)
0x0000000000010374	59	   v1 = v >> 32; v0 = v & 0xFFFFFFFF;
=> 0x10374 <mulul64+72>:	sd	a0,-72(s0)
61	   t = u0*v0;
=> 0x10378 <mulul64+76>:	ld	a0,-56(s0)
0x000000000001037c	61	   t = u0*v0;
=> 0x1037c <mulul64+80>:	ld	a1,-72(s0)
0x0000000000010380	61	   t = u0*v0;
=> 0x10380 <mulul64+84>:	mul	a0,a0,a1
0x0000000000010384	61	   t = u0*v0;
=> 0x10384 <mulul64+88>:	sd	a0,-96(s0)
62	   w0 = t & 0xFFFFFFFF;
=> 0x10388 <mulul64+92>:	lwu	a0,-96(s0)
0x000000000001038c	62	   w0 = t & 0xFFFFFFFF;
=> 0x1038c <mulul64+96>:	sd	a0,-104(s0)
63	   k = t >> 32;
=> 0x10390 <mulul64+100>:	lwu	a0,-92(s0)
0x0000000000010394	63	   k = t >> 32;
=> 0x10394 <mulul64+104>:	sd	a0,-88(s0)
65	   t = u1*v0 + k;
=> 0x10398 <mulul64+108>:	ld	a0,-64(s0)
0x000000000001039c	65	   t = u1*v0 + k;
=> 0x1039c <mulul64+112>:	ld	a1,-72(s0)
0x00000000000103a0	65	   t = u1*v0 + k;
=> 0x103a0 <mulul64+116>:	mul	a0,a0,a1
0x00000000000103a4	65	   t = u1*v0 + k;
=> 0x103a4 <mulul64+120>:	ld	a1,-88(s0)
0x00000000000103a8	65	   t = u1*v0 + k;
=> 0x103a8 <mulul64+124>:	add	a0,a0,a1
0x00000000000103ac	65	   t = u1*v0 + k;
=> 0x103ac <mulul64+128>:	sd	a0,-96(s0)
66	   w1 = t & 0xFFFFFFFF;
=> 0x103b0 <mulul64+132>:	lwu	a0,-96(s0)
0x00000000000103b4	66	   w1 = t & 0xFFFFFFFF;
=> 0x103b4 <mulul64+136>:	sd	a0,-112(s0)
67	   w2 = t >> 32;
=> 0x103b8 <mulul64+140>:	lwu	a0,-92(s0)
0x00000000000103bc	67	   w2 = t >> 32;
=> 0x103bc <mulul64+144>:	sd	a0,-120(s0)
69	   t = u0*v1 + w1;
=> 0x103c0 <mulul64+148>:	ld	a0,-56(s0)
0x00000000000103c4	69	   t = u0*v1 + w1;
=> 0x103c4 <mulul64+152>:	ld	a1,-80(s0)
0x00000000000103c8	69	   t = u0*v1 + w1;
=> 0x103c8 <mulul64+156>:	mul	a0,a0,a1
0x00000000000103cc	69	   t = u0*v1 + w1;
=> 0x103cc <mulul64+160>:	ld	a1,-112(s0)
0x00000000000103d0	69	   t = u0*v1 + w1;
=> 0x103d0 <mulul64+164>:	add	a0,a0,a1
0x00000000000103d4	69	   t = u0*v1 + w1;
=> 0x103d4 <mulul64+168>:	sd	a0,-96(s0)
70	   k = t >> 32;
=> 0x103d8 <mulul64+172>:	lwu	a0,-92(s0)
0x00000000000103dc	70	   k = t >> 32;
=> 0x103dc <mulul64+176>:	sd	a0,-88(s0)
72	   *wlo = (t << 32) + w0;
=> 0x103e0 <mulul64+180>:	ld	a0,-96(s0)
0x00000000000103e4	72	   *wlo = (t << 32) + w0;
=> 0x103e4 <mulul64+184>:	slli	a0,a0,0x20
0x00000000000103e8	72	   *wlo = (t << 32) + w0;
=> 0x103e8 <mulul64+188>:	ld	a1,-104(s0)
0x00000000000103ec	72	   *wlo = (t << 32) + w0;
=> 0x103ec <mulul64+192>:	add	a0,a0,a1
0x00000000000103f0	72	   *wlo = (t << 32) + w0;
=> 0x103f0 <mulul64+196>:	ld	a1,-48(s0)
0x00000000000103f4	72	   *wlo = (t << 32) + w0;
=> 0x103f4 <mulul64+200>:	sd	a0,0(a1)
73	   *whi = u1*v1 + w2 + k;
=> 0x103f8 <mulul64+204>:	ld	a0,-64(s0)
0x00000000000103fc	73	   *whi = u1*v1 + w2 + k;
=> 0x103fc <mulul64+208>:	ld	a1,-80(s0)
0x0000000000010400	73	   *whi = u1*v1 + w2 + k;
=> 0x10400 <mulul64+212>:	mul	a0,a0,a1
0x0000000000010404	73	   *whi = u1*v1 + w2 + k;
=> 0x10404 <mulul64+216>:	ld	a1,-120(s0)
0x0000000000010408	73	   *whi = u1*v1 + w2 + k;
=> 0x10408 <mulul64+220>:	add	a0,a0,a1
0x000000000001040c	73	   *whi = u1*v1 + w2 + k;
=> 0x1040c <mulul64+224>:	ld	a1,-88(s0)
0x0000000000010410	73	   *whi = u1*v1 + w2 + k;
=> 0x10410 <mulul64+228>:	add	a0,a0,a1
0x0000000000010414	73	   *whi = u1*v1 + w2 + k;
=> 0x10414 <mulul64+232>:	ld	a1,-40(s0)
0x0000000000010418	73	   *whi = u1*v1 + w2 + k;
=> 0x10418 <mulul64+236>:	sd	a0,0(a1)
75	   return;
=> 0x1041c <mulul64+240>:	ld	s0,112(sp)
0x0000000000010420 in mulul64 (u=380896260630216687, v=1473642379452024179, whi=0xfae849273928f89f, wlo=0x8000000000000000) at mont64.c:75
75	   return;
=> 0x10420 <mulul64+244>:	ld	ra,120(sp)
0x0000000000010424	75	   return;
=> 0x10424 <mulul64+248>:	addi	sp,sp,128
0x0000000000010428	75	   return;
=> 0x10428 <mulul64+252>:	ld	ra,0(t6)
0x000000000001042c	75	   return;
=> 0x1042c <mulul64+256>:	addi	t6,t6,16
0x0000000000010430	75	   return;
=> 0x10430 <mulul64+260>:	ret
benchmark () at mont64.c:266
266	   p = modul64(phi, plo, m);
=> 0x108e0 <benchmark+428>:	ld	a0,-104(s0)
0x00000000000108e4	266	   p = modul64(phi, plo, m);
=> 0x108e4 <benchmark+432>:	ld	a1,-112(s0)
0x00000000000108e8	266	   p = modul64(phi, plo, m);
=> 0x108e8 <benchmark+436>:	ld	a2,-40(s0)
0x00000000000108ec	266	   p = modul64(phi, plo, m);
=> 0x108ec <benchmark+440>:	jal	ra,0x10434 <modul64>
modul64 (x=380896260630216687, y=1473642379452024179, z=18079781136890394783) at mont64.c:80
80	uint64 modul64(uint64 x, uint64 y, uint64 z) {
=> 0x10434 <modul64>:	addi	t6,t6,-16
0x0000000000010438	80	uint64 modul64(uint64 x, uint64 y, uint64 z) {
=> 0x10438 <modul64+4>:	sd	ra,0(t6)
0x000000000001043c	80	uint64 modul64(uint64 x, uint64 y, uint64 z) {
=> 0x1043c <modul64+8>:	st	zero,0(t6)
0x0000000000010440	80	uint64 modul64(uint64 x, uint64 y, uint64 z) {
=> 0x10440 <modul64+12>:	addi	sp,sp,-64
0x0000000000010444	80	uint64 modul64(uint64 x, uint64 y, uint64 z) {
=> 0x10444 <modul64+16>:	sd	ra,56(sp)
0x0000000000010448	80	uint64 modul64(uint64 x, uint64 y, uint64 z) {
=> 0x10448 <modul64+20>:	sd	s0,48(sp)
0x000000000001044c	80	uint64 modul64(uint64 x, uint64 y, uint64 z) {
=> 0x1044c <modul64+24>:	addi	s0,sp,64
0x0000000000010450	80	uint64 modul64(uint64 x, uint64 y, uint64 z) {
=> 0x10450 <modul64+28>:	sd	a0,-24(s0)
0x0000000000010454	80	uint64 modul64(uint64 x, uint64 y, uint64 z) {
=> 0x10454 <modul64+32>:	sd	a1,-32(s0)
0x0000000000010458	80	uint64 modul64(uint64 x, uint64 y, uint64 z) {
=> 0x10458 <modul64+36>:	sd	a2,-40(s0)
0x000000000001045c	80	uint64 modul64(uint64 x, uint64 y, uint64 z) {
=> 0x1045c <modul64+40>:	li	a0,1
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10460 <modul64+44>:	sd	a0,-48(s0)
0x0000000000010464	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10464 <modul64+48>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
0x00000000000104bc	93	      if ((x | t) >= z) {
=> 0x104bc <modul64+136>:	j	0x104c0 <modul64+140>
94	         x = x - z;
=> 0x104c0 <modul64+140>:	ld	a0,-24(s0)
0x00000000000104c4	94	         x = x - z;
=> 0x104c4 <modul64+144>:	ld	a1,-40(s0)
0x00000000000104c8	94	         x = x - z;
=> 0x104c8 <modul64+148>:	sub	a0,a0,a1
0x00000000000104cc	94	         x = x - z;
=> 0x104cc <modul64+152>:	sd	a0,-24(s0)
95	         y = y + 1;
=> 0x104d0 <modul64+156>:	ld	a0,-32(s0)
0x00000000000104d4	95	         y = y + 1;
=> 0x104d4 <modul64+160>:	addi	a0,a0,1
0x00000000000104d8	95	         y = y + 1;
=> 0x104d8 <modul64+164>:	sd	a0,-32(s0)
96	      }
=> 0x104dc <modul64+168>:	j	0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
0x0000000000010474	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10474 <modul64+64>:	j	0x10478 <modul64+68>
90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10478 <modul64+68>:	ld	a0,-24(s0)
0x000000000001047c	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x1047c <modul64+72>:	srai	a0,a0,0x3f
0x0000000000010480	90	      t = (int64)x >> 63;       // All 1's if x(63) = 1.
=> 0x10480 <modul64+76>:	sd	a0,-56(s0)
91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10484 <modul64+80>:	ld	a0,-24(s0)
0x0000000000010488	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10488 <modul64+84>:	slli	a0,a0,0x1
0x000000000001048c	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x1048c <modul64+88>:	ld	a1,-32(s0)
0x0000000000010490	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10490 <modul64+92>:	srli	a1,a1,0x3f
0x0000000000010494	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10494 <modul64+96>:	or	a0,a0,a1
0x0000000000010498	91	      x = (x << 1) | (y >> 63); // Shift x || y left
=> 0x10498 <modul64+100>:	sd	a0,-24(s0)
92	      y = y << 1;               // one bit.
=> 0x1049c <modul64+104>:	ld	a0,-32(s0)
0x00000000000104a0	92	      y = y << 1;               // one bit.
=> 0x104a0 <modul64+108>:	slli	a0,a0,0x1
0x00000000000104a4	92	      y = y << 1;               // one bit.
=> 0x104a4 <modul64+112>:	sd	a0,-32(s0)
93	      if ((x | t) >= z) {
=> 0x104a8 <modul64+116>:	ld	a0,-24(s0)
0x00000000000104ac	93	      if ((x | t) >= z) {
=> 0x104ac <modul64+120>:	ld	a1,-56(s0)
0x00000000000104b0	93	      if ((x | t) >= z) {
=> 0x104b0 <modul64+124>:	or	a0,a0,a1
0x00000000000104b4	93	      if ((x | t) >= z) {
=> 0x104b4 <modul64+128>:	ld	a1,-40(s0)
0x00000000000104b8	93	      if ((x | t) >= z) {
=> 0x104b8 <modul64+132>:	bltu	a0,a1,0x104e0 <modul64+172>
97	   }
=> 0x104e0 <modul64+172>:	j	0x104e4 <modul64+176>
89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e4 <modul64+176>:	ld	a0,-48(s0)
0x00000000000104e8	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104e8 <modul64+180>:	addi	a0,a0,1
0x00000000000104ec	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104ec <modul64+184>:	sd	a0,-48(s0)
0x00000000000104f0	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x104f0 <modul64+188>:	j	0x10468 <modul64+52>
0x0000000000010468	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10468 <modul64+52>:	ld	a0,-48(s0)
0x000000000001046c	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x1046c <modul64+56>:	li	a1,64
0x0000000000010470	89	   for (i = 1; i <= 64; i++) {  // Do 64 times.
=> 0x10470 <modul64+60>:	blt	a1,a0,0x104f4 <modul64+192>
98	   return x;                    // Quotient is y.
=> 0x104f4 <modul64+192>:	ld	a0,-24(s0)
0x00000000000104f8	98	   return x;                    // Quotient is y.
=> 0x104f8 <modul64+196>:	ld	s0,48(sp)
0x00000000000104fc in modul64 (x=380896260630216687, y=1473642379452024179, z=18079781136890394783) at mont64.c:98
98	   return x;                    // Quotient is y.
=> 0x104fc <modul64+200>:	ld	ra,56(sp)
0x0000000000010500	98	   return x;                    // Quotient is y.
=> 0x10500 <modul64+204>:	addi	sp,sp,64
0x0000000000010504	98	   return x;                    // Quotient is y.
=> 0x10504 <modul64+208>:	ld	ra,0(t6)
0x0000000000010508	98	   return x;                    // Quotient is y.
=> 0x10508 <modul64+212>:	addi	t6,t6,16
0x000000000001050c	98	   return x;                    // Quotient is y.
=> 0x1050c <modul64+216>:	ret
0x00000000000108f0 in benchmark () at mont64.c:266
266	   p = modul64(phi, plo, m);
=> 0x108f0 <benchmark+444>:	sd	a0,-80(s0)
267	   if (p != p1)
=> 0x108f4 <benchmark+448>:	ld	a0,-80(s0)
0x00000000000108f8	267	   if (p != p1)
=> 0x108f8 <benchmark+452>:	ld	a1,-72(s0)
0x00000000000108fc	267	   if (p != p1)
=> 0x108fc <benchmark+456>:	beq	a0,a1,0x10910 <benchmark+476>
270	   return errors;
=> 0x10910 <benchmark+476>:	lw	a0,-132(s0)
0x0000000000010914	270	   return errors;
=> 0x10914 <benchmark+480>:	ld	s0,176(sp)
0x0000000000010918 in benchmark () at mont64.c:270
270	   return errors;
=> 0x10918 <benchmark+484>:	ld	ra,184(sp)
0x000000000001091c	270	   return errors;
=> 0x1091c <benchmark+488>:	addi	sp,sp,192
0x0000000000010920	270	   return errors;
=> 0x10920 <benchmark+492>:	ld	ra,0(t6)
0x0000000000010924	270	   return errors;
=> 0x10924 <benchmark+496>:	addi	t6,t6,16
0x0000000000010928	270	   return errors;
=> 0x10928 <benchmark+500>:	ret
0x0000000000010248 in main (argc=1, argv=0x3ffffffb68) at main.c:57
57	      result = benchmark ();
=> 0x10248 <main+184>:	sw	a0,-40(s0)
58	    }
=> 0x1024c <main+188>:	j	0x10250 <main+192>
54	  for (i = 0; i < REPEAT_FACTOR; i++)
=> 0x10250 <main+192>:	lw	a0,-36(s0)
0x0000000000010254	54	  for (i = 0; i < REPEAT_FACTOR; i++)
=> 0x10254 <main+196>:	addi	a0,a0,1
0x0000000000010258	54	  for (i = 0; i < REPEAT_FACTOR; i++)
=> 0x10258 <main+200>:	sw	a0,-36(s0)
0x000000000001025c	54	  for (i = 0; i < REPEAT_FACTOR; i++)
=> 0x1025c <main+204>:	j	0x1022c <main+156>
0x000000000001022c	54	  for (i = 0; i < REPEAT_FACTOR; i++)
=> 0x1022c <main+156>:	lw	a0,-36(s0)
0x0000000000010230	54	  for (i = 0; i < REPEAT_FACTOR; i++)
=> 0x10230 <main+160>:	li	a1,0
0x0000000000010234	54	  for (i = 0; i < REPEAT_FACTOR; i++)
=> 0x10234 <main+164>:	blt	a1,a0,0x10260 <main+208>
60	  stop_trigger ();
=> 0x10260 <main+208>:	jal	ra,0x102f8 <stop_trigger>
stop_trigger () at ../config/riscv64/boards/generic/boardsupport.c:40
40	{
=> 0x102f8 <stop_trigger>:	addi	t6,t6,-16
0x00000000000102fc	40	{
=> 0x102fc <stop_trigger+4>:	sd	ra,0(t6)
0x0000000000010300	40	{
=> 0x10300 <stop_trigger+8>:	st	zero,0(t6)
0x0000000000010304	40	{
=> 0x10304 <stop_trigger+12>:	addi	sp,sp,-16
47	}
=> 0x10308 <stop_trigger+16>:	sd	ra,8(sp)
0x000000000001030c	47	}
=> 0x1030c <stop_trigger+20>:	sd	s0,0(sp)
0x0000000000010310	47	}
=> 0x10310 <stop_trigger+24>:	addi	s0,sp,16
0x0000000000010314	47	}
=> 0x10314 <stop_trigger+28>:	ld	s0,0(sp)
0x0000000000010318 in stop_trigger () at ../config/riscv64/boards/generic/boardsupport.c:47
47	}
=> 0x10318 <stop_trigger+32>:	ld	ra,8(sp)
0x000000000001031c	47	}
=> 0x1031c <stop_trigger+36>:	addi	sp,sp,16
0x0000000000010320	47	}
=> 0x10320 <stop_trigger+40>:	ld	ra,0(t6)
0x0000000000010324	47	}
=> 0x10324 <stop_trigger+44>:	addi	t6,t6,16
0x0000000000010328	47	}
=> 0x10328 <stop_trigger+48>:	ret
main (argc=1, argv=0x3ffffffb68) at main.c:64
64	  correct = verify_benchmark (result);
=> 0x10264 <main+212>:	lw	a0,-40(s0)
0x0000000000010268	64	  correct = verify_benchmark (result);
=> 0x10268 <main+216>:	jal	ra,0x109bc <verify_benchmark>
verify_benchmark (r=1) at mont64.c:282
282	{
=> 0x109bc <verify_benchmark>:	addi	t6,t6,-16
0x00000000000109c0	282	{
=> 0x109c0 <verify_benchmark+4>:	sd	ra,0(t6)
0x00000000000109c4	282	{
=> 0x109c4 <verify_benchmark+8>:	st	zero,0(t6)
0x00000000000109c8	282	{
=> 0x109c8 <verify_benchmark+12>:	addi	sp,sp,-32
0x00000000000109cc	282	{
=> 0x109cc <verify_benchmark+16>:	sd	ra,24(sp)
0x00000000000109d0	282	{
=> 0x109d0 <verify_benchmark+20>:	sd	s0,16(sp)
0x00000000000109d4	282	{
=> 0x109d4 <verify_benchmark+24>:	addi	s0,sp,32
0x00000000000109d8	282	{
=> 0x109d8 <verify_benchmark+28>:	mv	a1,a0
0x00000000000109dc	282	{
=> 0x109dc <verify_benchmark+32>:	sw	a0,-24(s0)
283	   if (r != 0)
=> 0x109e0 <verify_benchmark+36>:	lw	a0,-24(s0)
0x00000000000109e4	283	   if (r != 0)
=> 0x109e4 <verify_benchmark+40>:	li	a2,0
0x00000000000109e8	283	   if (r != 0)
=> 0x109e8 <verify_benchmark+44>:	beq	a0,a2,0x109fc <verify_benchmark+64>
0x00000000000109fc	284	      return 0;
=> 0x109fc <verify_benchmark+64>:	li	a0,1
285	   return 1;
=> 0x10a00 <verify_benchmark+68>:	sw	a0,-20(s0)
0x0000000000010a04	285	   return 1;
=> 0x10a04 <verify_benchmark+72>:	j	0x10a08 <verify_benchmark+76>
286	}
=> 0x10a08 <verify_benchmark+76>:	lw	a0,-20(s0)
0x0000000000010a0c	286	}
=> 0x10a0c <verify_benchmark+80>:	ld	s0,16(sp)
0x0000000000010a10 in verify_benchmark (r=1) at mont64.c:286
286	}
=> 0x10a10 <verify_benchmark+84>:	ld	ra,24(sp)
0x0000000000010a14	286	}
=> 0x10a14 <verify_benchmark+88>:	addi	sp,sp,32
0x0000000000010a18	286	}
=> 0x10a18 <verify_benchmark+92>:	ld	ra,0(t6)
0x0000000000010a1c	286	}
=> 0x10a1c <verify_benchmark+96>:	addi	t6,t6,16
0x0000000000010a20	286	}
=> 0x10a20 <verify_benchmark+100>:	ret
0x000000000001026c in main (argc=1, argv=0x3ffffffb68) at main.c:64
64	  correct = verify_benchmark (result);
=> 0x1026c <main+220>:	sw	a0,-44(s0)
66	  free(a);
=> 0x10270 <main+224>:	ld	a0,-56(s0)
0x0000000000010274	66	  free(a);
=> 0x10274 <main+228>:	jal	ra,0x10abc <free>
0x0000000000010abc in free ()
=> 0x10abc <free>:	mv	a1,a0
0x0000000000010abe in free ()
=> 0x10abe <free+2>:	ld	a0,1848(gp)
0x0000000000010ac2 in free ()
=> 0x10ac2 <free+6>:	j	0x13598 <_free_r>
0x0000000000013598 in _free_r ()
=> 0x13598 <_free_r>:	beqz	a1,0x13688 <_free_r+240>
0x000000000001359a in _free_r ()
=> 0x1359a <_free_r+2>:	addi	sp,sp,-32
0x000000000001359c in _free_r ()
=> 0x1359c <_free_r+4>:	sd	s0,16(sp)
0x000000000001359e in _free_r ()
=> 0x1359e <_free_r+6>:	sd	s1,8(sp)
0x00000000000135a0 in _free_r ()
=> 0x135a0 <_free_r+8>:	mv	s0,a1
0x00000000000135a2 in _free_r ()
=> 0x135a2 <_free_r+10>:	mv	s1,a0
0x00000000000135a4 in _free_r ()
=> 0x135a4 <_free_r+12>:	sd	ra,24(sp)
0x00000000000135a6 in _free_r ()
=> 0x135a6 <_free_r+14>:	jal	ra,0x11192 <__malloc_lock>
0x0000000000011192 in __malloc_lock ()
=> 0x11192 <__malloc_lock>:	ret
0x00000000000135aa in _free_r ()
=> 0x135aa <_free_r+18>:	ld	a0,-8(s0)
0x00000000000135ae in _free_r ()
=> 0x135ae <_free_r+22>:	addi	a4,s0,-16
0x00000000000135b2 in _free_r ()
=> 0x135b2 <_free_r+26>:	lui	a1,0x1f
0x00000000000135b6 in _free_r ()
=> 0x135b6 <_free_r+30>:	andi	a5,a0,-2
0x00000000000135ba in _free_r ()
=> 0x135ba <_free_r+34>:	add	a2,a4,a5
0x00000000000135be in _free_r ()
=> 0x135be <_free_r+38>:	addi	a1,a1,744
0x00000000000135c2 in _free_r ()
=> 0x135c2 <_free_r+42>:	ld	a3,8(a2)
0x00000000000135c4 in _free_r ()
=> 0x135c4 <_free_r+44>:	ld	a6,16(a1)
0x00000000000135c8 in _free_r ()
=> 0x135c8 <_free_r+48>:	andi	a3,a3,-4
0x00000000000135ca in _free_r ()
=> 0x135ca <_free_r+50>:	beq	a6,a2,0x1370e <_free_r+374>
0x00000000000135ce in _free_r ()
=> 0x135ce <_free_r+54>:	sd	a3,8(a2)
0x00000000000135d0 in _free_r ()
=> 0x135d0 <_free_r+56>:	andi	a0,a0,1
0x00000000000135d2 in _free_r ()
=> 0x135d2 <_free_r+58>:	add	a6,a2,a3
0x00000000000135d6 in _free_r ()
=> 0x135d6 <_free_r+62>:	bnez	a0,0x13658 <_free_r+192>
0x0000000000013658 in _free_r ()
=> 0x13658 <_free_r+192>:	ld	a0,8(a6)
0x000000000001365c in _free_r ()
=> 0x1365c <_free_r+196>:	andi	a0,a0,1
0x000000000001365e in _free_r ()
=> 0x1365e <_free_r+198>:	bnez	a0,0x1368a <_free_r+242>
0x000000000001368a in _free_r ()
=> 0x1368a <_free_r+242>:	ori	a3,a5,1
0x000000000001368e in _free_r ()
=> 0x1368e <_free_r+246>:	sd	a3,-8(s0)
0x0000000000013692 in _free_r ()
=> 0x13692 <_free_r+250>:	sd	a5,0(a2)
0x0000000000013694 in _free_r ()
=> 0x13694 <_free_r+252>:	li	a3,511
0x0000000000013698 in _free_r ()
=> 0x13698 <_free_r+256>:	bgeu	a3,a5,0x1361a <_free_r+130>
0x000000000001369c in _free_r ()
=> 0x1369c <_free_r+260>:	srli	a3,a5,0x9
0x00000000000136a0 in _free_r ()
=> 0x136a0 <_free_r+264>:	li	a2,4
0x00000000000136a2 in _free_r ()
=> 0x136a2 <_free_r+266>:	bltu	a2,a3,0x13740 <_free_r+424>
0x0000000000013740 in _free_r ()
=> 0x13740 <_free_r+424>:	li	a2,20
0x0000000000013742 in _free_r ()
=> 0x13742 <_free_r+426>:	bgeu	a2,a3,0x13766 <_free_r+462>
0x0000000000013746 in _free_r ()
=> 0x13746 <_free_r+430>:	li	a2,84
0x000000000001374a in _free_r ()
=> 0x1374a <_free_r+434>:	bltu	a2,a3,0x1379e <_free_r+518>
0x000000000001379e in _free_r ()
=> 0x1379e <_free_r+518>:	li	a2,340
0x00000000000137a2 in _free_r ()
=> 0x137a2 <_free_r+522>:	bltu	a2,a3,0x137ba <_free_r+546>
0x00000000000137ba in _free_r ()
=> 0x137ba <_free_r+546>:	li	a2,1364
0x00000000000137be in _free_r ()
=> 0x137be <_free_r+550>:	bltu	a2,a3,0x137d6 <_free_r+574>
0x00000000000137d6 in _free_r ()
=> 0x137d6 <_free_r+574>:	li	a0,2032
0x00000000000137da in _free_r ()
=> 0x137da <_free_r+578>:	li	a2,126
0x00000000000137de in _free_r ()
=> 0x137de <_free_r+582>:	j	0x136b8 <_free_r+288>
0x00000000000136b8 in _free_r ()
=> 0x136b8 <_free_r+288>:	add	a0,a0,a1
0x00000000000136ba in _free_r ()
=> 0x136ba <_free_r+290>:	ld	a3,0(a0)
0x00000000000136bc in _free_r ()
=> 0x136bc <_free_r+292>:	addi	a0,a0,-16
0x00000000000136be in _free_r ()
=> 0x136be <_free_r+294>:	beq	a0,a3,0x13788 <_free_r+496>
0x0000000000013788 in _free_r ()
=> 0x13788 <_free_r+496>:	ld	a6,8(a1)
0x000000000001378c in _free_r ()
=> 0x1378c <_free_r+500>:	sraiw	a2,a2,0x2
0x0000000000013790 in _free_r ()
=> 0x13790 <_free_r+504>:	li	a5,1
0x0000000000013792 in _free_r ()
=> 0x13792 <_free_r+506>:	sll	a2,a5,a2
0x0000000000013796 in _free_r ()
=> 0x13796 <_free_r+510>:	or	a2,a2,a6
0x000000000001379a in _free_r ()
=> 0x1379a <_free_r+514>:	sd	a2,8(a1)
0x000000000001379c in _free_r ()
=> 0x1379c <_free_r+516>:	j	0x136d2 <_free_r+314>
0x00000000000136d2 in _free_r ()
=> 0x136d2 <_free_r+314>:	sd	a0,24(a4)
0x00000000000136d4 in _free_r ()
=> 0x136d4 <_free_r+316>:	sd	a3,16(a4)
0x00000000000136d6 in _free_r ()
=> 0x136d6 <_free_r+318>:	ld	s0,16(sp)
0x00000000000136d8 in _free_r ()
=> 0x136d8 <_free_r+320>:	sd	a4,16(a0)
0x00000000000136da in _free_r ()
=> 0x136da <_free_r+322>:	ld	ra,24(sp)
0x00000000000136dc in _free_r ()
=> 0x136dc <_free_r+324>:	mv	a0,s1
0x00000000000136de in _free_r ()
=> 0x136de <_free_r+326>:	ld	s1,8(sp)
0x00000000000136e0 in _free_r ()
=> 0x136e0 <_free_r+328>:	sd	a4,24(a3)
0x00000000000136e2 in _free_r ()
=> 0x136e2 <_free_r+330>:	addi	sp,sp,32
0x00000000000136e4 in _free_r ()
=> 0x136e4 <_free_r+332>:	j	0x11194 <__malloc_unlock>
0x0000000000011194 in __malloc_unlock ()
=> 0x11194 <__malloc_unlock>:	ret
main (argc=1, argv=0x3ffffffb68) at main.c:68
68	  return (!correct);
=> 0x10278 <main+232>:	lw	a0,-44(s0)
0x000000000001027c	68	  return (!correct);
=> 0x1027c <main+236>:	seqz	a0,a0
0x0000000000010280	68	  return (!correct);
=> 0x10280 <main+240>:	ld	s0,112(sp)
0x0000000000010284 in main (argc=<error reading variable: Cannot access memory at address 0x2aaabbdd08>, argv=<error reading variable: Cannot access memory at address 0x2aaabbdd00>) at main.c:68
68	  return (!correct);
=> 0x10284 <main+244>:	ld	ra,120(sp)
0x0000000000010288	68	  return (!correct);
=> 0x10288 <main+248>:	addi	sp,sp,128
0x000000000001028c	68	  return (!correct);
=> 0x1028c <main+252>:	ret
0x000000000001013a in _start ()
=> 0x1013a <_start+64>:	j	0x10a24 <exit>
0x0000000000010a24 in exit ()
=> 0x10a24 <exit>:	addi	sp,sp,-16
0x0000000000010a26 in exit ()
=> 0x10a26 <exit+2>:	li	a1,0
0x0000000000010a28 in exit ()
=> 0x10a28 <exit+4>:	sd	s0,0(sp)
0x0000000000010a2a in exit ()
=> 0x10a2a <exit+6>:	sd	ra,8(sp)
0x0000000000010a2c in exit ()
=> 0x10a2c <exit+8>:	mv	s0,a0
0x0000000000010a2e in exit ()
=> 0x10a2e <exit+10>:	jal	ra,0x12f32 <__call_exitprocs>
0x0000000000012f32 in __call_exitprocs ()
=> 0x12f32 <__call_exitprocs>:	addi	sp,sp,-80
0x0000000000012f34 in __call_exitprocs ()
=> 0x12f34 <__call_exitprocs+2>:	sd	s4,32(sp)
0x0000000000012f36 in __call_exitprocs ()
=> 0x12f36 <__call_exitprocs+4>:	ld	s4,1832(gp)
0x0000000000012f3a in __call_exitprocs ()
=> 0x12f3a <__call_exitprocs+8>:	sd	s2,48(sp)
0x0000000000012f3c in __call_exitprocs ()
=> 0x12f3c <__call_exitprocs+10>:	sd	ra,72(sp)
0x0000000000012f3e in __call_exitprocs ()
=> 0x12f3e <__call_exitprocs+12>:	ld	s2,504(s4)
0x0000000000012f42 in __call_exitprocs ()
=> 0x12f42 <__call_exitprocs+16>:	sd	s0,64(sp)
0x0000000000012f44 in __call_exitprocs ()
=> 0x12f44 <__call_exitprocs+18>:	sd	s1,56(sp)
0x0000000000012f46 in __call_exitprocs ()
=> 0x12f46 <__call_exitprocs+20>:	sd	s3,40(sp)
0x0000000000012f48 in __call_exitprocs ()
=> 0x12f48 <__call_exitprocs+22>:	sd	s5,24(sp)
0x0000000000012f4a in __call_exitprocs ()
=> 0x12f4a <__call_exitprocs+24>:	sd	s6,16(sp)
0x0000000000012f4c in __call_exitprocs ()
=> 0x12f4c <__call_exitprocs+26>:	sd	s7,8(sp)
0x0000000000012f4e in __call_exitprocs ()
=> 0x12f4e <__call_exitprocs+28>:	sd	s8,0(sp)
0x0000000000012f50 in __call_exitprocs ()
=> 0x12f50 <__call_exitprocs+30>:	beqz	s2,0x12f80 <__call_exitprocs+78>
0x0000000000012f54 in __call_exitprocs ()
=> 0x12f54 <__call_exitprocs+34>:	mv	s6,a0
0x0000000000012f56 in __call_exitprocs ()
=> 0x12f56 <__call_exitprocs+36>:	mv	s7,a1
0x0000000000012f58 in __call_exitprocs ()
=> 0x12f58 <__call_exitprocs+38>:	li	s5,1
0x0000000000012f5a in __call_exitprocs ()
=> 0x12f5a <__call_exitprocs+40>:	li	s3,-1
0x0000000000012f5c in __call_exitprocs ()
=> 0x12f5c <__call_exitprocs+42>:	lw	s1,8(s2)
0x0000000000012f60 in __call_exitprocs ()
=> 0x12f60 <__call_exitprocs+46>:	addiw	s0,s1,-1
0x0000000000012f64 in __call_exitprocs ()
=> 0x12f64 <__call_exitprocs+50>:	bltz	s0,0x12f80 <__call_exitprocs+78>
0x0000000000012f68 in __call_exitprocs ()
=> 0x12f68 <__call_exitprocs+54>:	slli	s1,s1,0x3
0x0000000000012f6a in __call_exitprocs ()
=> 0x12f6a <__call_exitprocs+56>:	add	s1,s1,s2
0x0000000000012f6c in __call_exitprocs ()
=> 0x12f6c <__call_exitprocs+58>:	beqz	s7,0x12f98 <__call_exitprocs+102>
0x0000000000012f98 in __call_exitprocs ()
=> 0x12f98 <__call_exitprocs+102>:	lw	a5,8(s2)
0x0000000000012f9c in __call_exitprocs ()
=> 0x12f9c <__call_exitprocs+106>:	ld	a4,8(s1)
0x0000000000012f9e in __call_exitprocs ()
=> 0x12f9e <__call_exitprocs+108>:	addiw	a5,a5,-1
0x0000000000012fa0 in __call_exitprocs ()
=> 0x12fa0 <__call_exitprocs+110>:	beq	a5,s0,0x12fe8 <__call_exitprocs+182>
0x0000000000012fe8 in __call_exitprocs ()
=> 0x12fe8 <__call_exitprocs+182>:	sw	s0,8(s2)
0x0000000000012fec in __call_exitprocs ()
=> 0x12fec <__call_exitprocs+186>:	j	0x12fa8 <__call_exitprocs+118>
0x0000000000012fa8 in __call_exitprocs ()
=> 0x12fa8 <__call_exitprocs+118>:	beqz	a4,0x12f78 <__call_exitprocs+70>
0x0000000000012faa in __call_exitprocs ()
=> 0x12faa <__call_exitprocs+120>:	lw	a5,784(s2)
0x0000000000012fae in __call_exitprocs ()
=> 0x12fae <__call_exitprocs+124>:	sllw	a3,s5,s0
0x0000000000012fb2 in __call_exitprocs ()
=> 0x12fb2 <__call_exitprocs+128>:	lw	s8,8(s2)
0x0000000000012fb6 in __call_exitprocs ()
=> 0x12fb6 <__call_exitprocs+132>:	and	a5,a5,a3
0x0000000000012fb8 in __call_exitprocs ()
=> 0x12fb8 <__call_exitprocs+134>:	sext.w	a5,a5
0x0000000000012fba in __call_exitprocs ()
=> 0x12fba <__call_exitprocs+136>:	bnez	a5,0x12fd4 <__call_exitprocs+162>
0x0000000000012fbc in __call_exitprocs ()
=> 0x12fbc <__call_exitprocs+138>:	jalr	a4
0x000000000001348a in __libc_fini_array ()
=> 0x1348a <__libc_fini_array>:	addi	sp,sp,-32
0x000000000001348c in __libc_fini_array ()
=> 0x1348c <__libc_fini_array+2>:	sd	s0,16(sp)
0x000000000001348e in __libc_fini_array ()
=> 0x1348e <__libc_fini_array+4>:	lui	a5,0x1f
0x0000000000013492 in __libc_fini_array ()
=> 0x13492 <__libc_fini_array+8>:	lui	s0,0x1f
0x0000000000013496 in __libc_fini_array ()
=> 0x13496 <__libc_fini_array+12>:	addi	s0,s0,-1128
0x000000000001349a in __libc_fini_array ()
=> 0x1349a <__libc_fini_array+16>:	addi	a5,a5,-1120
0x000000000001349e in __libc_fini_array ()
=> 0x1349e <__libc_fini_array+20>:	sub	a5,a5,s0
0x00000000000134a0 in __libc_fini_array ()
=> 0x134a0 <__libc_fini_array+22>:	sd	s1,8(sp)
0x00000000000134a2 in __libc_fini_array ()
=> 0x134a2 <__libc_fini_array+24>:	sd	ra,24(sp)
0x00000000000134a4 in __libc_fini_array ()
=> 0x134a4 <__libc_fini_array+26>:	srai	s1,a5,0x3
0x00000000000134a8 in __libc_fini_array ()
=> 0x134a8 <__libc_fini_array+30>:	beqz	s1,0x134b8 <__libc_fini_array+46>
0x00000000000134aa in __libc_fini_array ()
=> 0x134aa <__libc_fini_array+32>:	addi	a5,a5,-8
0x00000000000134ac in __libc_fini_array ()
=> 0x134ac <__libc_fini_array+34>:	add	s0,s0,a5
0x00000000000134ae in __libc_fini_array ()
=> 0x134ae <__libc_fini_array+36>:	ld	a5,0(s0)
0x00000000000134b0 in __libc_fini_array ()
=> 0x134b0 <__libc_fini_array+38>:	addi	s1,s1,-1
0x00000000000134b2 in __libc_fini_array ()
=> 0x134b2 <__libc_fini_array+40>:	addi	s0,s0,-8
0x00000000000134b4 in __libc_fini_array ()
=> 0x134b4 <__libc_fini_array+42>:	jalr	a5
0x000000000001013e in __do_global_dtors_aux ()
=> 0x1013e <__do_global_dtors_aux>:	lbu	a4,1952(gp)
0x0000000000010142 in __do_global_dtors_aux ()
=> 0x10142 <__do_global_dtors_aux+4>:	bnez	a4,0x10170 <__do_global_dtors_aux+50>
0x0000000000010144 in __do_global_dtors_aux ()
=> 0x10144 <__do_global_dtors_aux+6>:	addi	sp,sp,-16
0x0000000000010146 in __do_global_dtors_aux ()
=> 0x10146 <__do_global_dtors_aux+8>:	sd	s0,0(sp)
0x0000000000010148 in __do_global_dtors_aux ()
=> 0x10148 <__do_global_dtors_aux+10>:	mv	s0,a5
0x000000000001014a in __do_global_dtors_aux ()
=> 0x1014a <__do_global_dtors_aux+12>:	sd	ra,8(sp)
0x000000000001014c in __do_global_dtors_aux ()
=> 0x1014c <__do_global_dtors_aux+14>:	li	a5,0
0x0000000000010150 in __do_global_dtors_aux ()
=> 0x10150 <__do_global_dtors_aux+18>:	beqz	a5,0x10162 <__do_global_dtors_aux+36>
0x0000000000010162 in __do_global_dtors_aux ()
=> 0x10162 <__do_global_dtors_aux+36>:	li	a5,1
0x0000000000010164 in __do_global_dtors_aux ()
=> 0x10164 <__do_global_dtors_aux+38>:	ld	ra,8(sp)
0x0000000000010166 in __do_global_dtors_aux ()
=> 0x10166 <__do_global_dtors_aux+40>:	sb	a5,1952(gp)
0x000000000001016a in __do_global_dtors_aux ()
=> 0x1016a <__do_global_dtors_aux+44>:	ld	s0,0(sp)
0x000000000001016c in __do_global_dtors_aux ()
=> 0x1016c <__do_global_dtors_aux+46>:	addi	sp,sp,16
0x000000000001016e in __do_global_dtors_aux ()
=> 0x1016e <__do_global_dtors_aux+48>:	ret
0x00000000000134b6 in __libc_fini_array ()
=> 0x134b6 <__libc_fini_array+44>:	bnez	s1,0x134ae <__libc_fini_array+36>
0x00000000000134b8 in __libc_fini_array ()
=> 0x134b8 <__libc_fini_array+46>:	ld	ra,24(sp)
0x00000000000134ba in __libc_fini_array ()
=> 0x134ba <__libc_fini_array+48>:	ld	s0,16(sp)
0x00000000000134bc in __libc_fini_array ()
=> 0x134bc <__libc_fini_array+50>:	ld	s1,8(sp)
0x00000000000134be in __libc_fini_array ()
=> 0x134be <__libc_fini_array+52>:	addi	sp,sp,32
0x00000000000134c0 in __libc_fini_array ()
=> 0x134c0 <__libc_fini_array+54>:	ret
0x0000000000012fbe in __call_exitprocs ()
=> 0x12fbe <__call_exitprocs+140>:	lw	a4,8(s2)
0x0000000000012fc2 in __call_exitprocs ()
=> 0x12fc2 <__call_exitprocs+144>:	ld	a5,504(s4)
0x0000000000012fc6 in __call_exitprocs ()
=> 0x12fc6 <__call_exitprocs+148>:	bne	a4,s8,0x12fce <__call_exitprocs+156>
0x0000000000012fca in __call_exitprocs ()
=> 0x12fca <__call_exitprocs+152>:	beq	a5,s2,0x12f78 <__call_exitprocs+70>
0x0000000000012f78 in __call_exitprocs ()
=> 0x12f78 <__call_exitprocs+70>:	addiw	s0,s0,-1
0x0000000000012f7a in __call_exitprocs ()
=> 0x12f7a <__call_exitprocs+72>:	addi	s1,s1,-8
0x0000000000012f7c in __call_exitprocs ()
=> 0x12f7c <__call_exitprocs+74>:	bne	s0,s3,0x12f6c <__call_exitprocs+58>
0x0000000000012f80 in __call_exitprocs ()
=> 0x12f80 <__call_exitprocs+78>:	ld	ra,72(sp)
0x0000000000012f82 in __call_exitprocs ()
=> 0x12f82 <__call_exitprocs+80>:	ld	s0,64(sp)
0x0000000000012f84 in __call_exitprocs ()
=> 0x12f84 <__call_exitprocs+82>:	ld	s1,56(sp)
0x0000000000012f86 in __call_exitprocs ()
=> 0x12f86 <__call_exitprocs+84>:	ld	s2,48(sp)
0x0000000000012f88 in __call_exitprocs ()
=> 0x12f88 <__call_exitprocs+86>:	ld	s3,40(sp)
0x0000000000012f8a in __call_exitprocs ()
=> 0x12f8a <__call_exitprocs+88>:	ld	s4,32(sp)
0x0000000000012f8c in __call_exitprocs ()
=> 0x12f8c <__call_exitprocs+90>:	ld	s5,24(sp)
0x0000000000012f8e in __call_exitprocs ()
=> 0x12f8e <__call_exitprocs+92>:	ld	s6,16(sp)
0x0000000000012f90 in __call_exitprocs ()
=> 0x12f90 <__call_exitprocs+94>:	ld	s7,8(sp)
0x0000000000012f92 in __call_exitprocs ()
=> 0x12f92 <__call_exitprocs+96>:	ld	s8,0(sp)
0x0000000000012f94 in __call_exitprocs ()
=> 0x12f94 <__call_exitprocs+98>:	addi	sp,sp,80
0x0000000000012f96 in __call_exitprocs ()
=> 0x12f96 <__call_exitprocs+100>:	ret
0x0000000000010a32 in exit ()
=> 0x10a32 <exit+14>:	ld	a0,1832(gp)
0x0000000000010a36 in exit ()
=> 0x10a36 <exit+18>:	ld	a5,88(a0)
0x0000000000010a38 in exit ()
=> 0x10a38 <exit+20>:	beqz	a5,0x10a3c <exit+24>
0x0000000000010a3a in exit ()
=> 0x10a3a <exit+22>:	jalr	a5
0x000000000001320a in _cleanup_r ()
=> 0x1320a <_cleanup_r>:	lui	a1,0x1a
0x000000000001320c in _cleanup_r ()
=> 0x1320c <_cleanup_r+2>:	addi	a1,a1,-1678
0x0000000000013210 in _cleanup_r ()
=> 0x13210 <_cleanup_r+6>:	j	0x1386c <_fwalk_reent>
0x000000000001386c in _fwalk_reent ()
=> 0x1386c <_fwalk_reent>:	addi	sp,sp,-80
0x000000000001386e in _fwalk_reent ()
=> 0x1386e <_fwalk_reent+2>:	sd	s2,48(sp)
0x0000000000013870 in _fwalk_reent ()
=> 0x13870 <_fwalk_reent+4>:	sd	s3,40(sp)
0x0000000000013872 in _fwalk_reent ()
=> 0x13872 <_fwalk_reent+6>:	sd	s4,32(sp)
0x0000000000013874 in _fwalk_reent ()
=> 0x13874 <_fwalk_reent+8>:	sd	s5,24(sp)
0x0000000000013876 in _fwalk_reent ()
=> 0x13876 <_fwalk_reent+10>:	sd	s6,16(sp)
0x0000000000013878 in _fwalk_reent ()
=> 0x13878 <_fwalk_reent+12>:	sd	s7,8(sp)
0x000000000001387a in _fwalk_reent ()
=> 0x1387a <_fwalk_reent+14>:	sd	s8,0(sp)
0x000000000001387c in _fwalk_reent ()
=> 0x1387c <_fwalk_reent+16>:	sd	ra,72(sp)
0x000000000001387e in _fwalk_reent ()
=> 0x1387e <_fwalk_reent+18>:	sd	s0,64(sp)
0x0000000000013880 in _fwalk_reent ()
=> 0x13880 <_fwalk_reent+20>:	sd	s1,56(sp)
0x0000000000013882 in _fwalk_reent ()
=> 0x13882 <_fwalk_reent+22>:	mv	s8,a0
0x0000000000013884 in _fwalk_reent ()
=> 0x13884 <_fwalk_reent+24>:	mv	s4,a1
0x0000000000013886 in _fwalk_reent ()
=> 0x13886 <_fwalk_reent+26>:	addi	s2,a0,1312
0x000000000001388a in _fwalk_reent ()
=> 0x1388a <_fwalk_reent+30>:	li	s6,0
0x000000000001388c in _fwalk_reent ()
=> 0x1388c <_fwalk_reent+32>:	li	s5,176
0x0000000000013890 in _fwalk_reent ()
=> 0x13890 <_fwalk_reent+36>:	li	s7,1
0x0000000000013892 in _fwalk_reent ()
=> 0x13892 <_fwalk_reent+38>:	li	s3,-1
0x0000000000013894 in _fwalk_reent ()
=> 0x13894 <_fwalk_reent+40>:	lw	a5,8(s2)
0x0000000000013898 in _fwalk_reent ()
=> 0x13898 <_fwalk_reent+44>:	ld	s0,16(s2)
0x000000000001389c in _fwalk_reent ()
=> 0x1389c <_fwalk_reent+48>:	blez	a5,0x138d4 <_fwalk_reent+104>
0x00000000000138a0 in _fwalk_reent ()
=> 0x138a0 <_fwalk_reent+52>:	addiw	s1,a5,-1
0x00000000000138a4 in _fwalk_reent ()
=> 0x138a4 <_fwalk_reent+56>:	slli	s1,s1,0x20
0x00000000000138a6 in _fwalk_reent ()
=> 0x138a6 <_fwalk_reent+58>:	srli	s1,s1,0x20
0x00000000000138a8 in _fwalk_reent ()
=> 0x138a8 <_fwalk_reent+60>:	addi	s1,s1,1
0x00000000000138aa in _fwalk_reent ()
=> 0x138aa <_fwalk_reent+62>:	mul	s1,s1,s5
0x00000000000138ae in _fwalk_reent ()
=> 0x138ae <_fwalk_reent+66>:	add	s1,s1,s0
0x00000000000138b0 in _fwalk_reent ()
=> 0x138b0 <_fwalk_reent+68>:	lhu	a5,16(s0)
0x00000000000138b4 in _fwalk_reent ()
=> 0x138b4 <_fwalk_reent+72>:	bgeu	s7,a5,0x138cc <_fwalk_reent+96>
0x00000000000138b8 in _fwalk_reent ()
=> 0x138b8 <_fwalk_reent+76>:	lh	a5,18(s0)
0x00000000000138bc in _fwalk_reent ()
=> 0x138bc <_fwalk_reent+80>:	mv	a1,s0
0x00000000000138be in _fwalk_reent ()
=> 0x138be <_fwalk_reent+82>:	mv	a0,s8
0x00000000000138c0 in _fwalk_reent ()
=> 0x138c0 <_fwalk_reent+84>:	beq	a5,s3,0x138cc <_fwalk_reent+96>
0x00000000000138c4 in _fwalk_reent ()
=> 0x138c4 <_fwalk_reent+88>:	jalr	s4
0x0000000000019972 in _fclose_r ()
=> 0x19972 <_fclose_r>:	beqz	a1,0x199ac <_fclose_r+58>
0x0000000000019974 in _fclose_r ()
=> 0x19974 <_fclose_r+2>:	addi	sp,sp,-32
0x0000000000019976 in _fclose_r ()
=> 0x19976 <_fclose_r+4>:	sd	s0,16(sp)
0x0000000000019978 in _fclose_r ()
=> 0x19978 <_fclose_r+6>:	sd	ra,24(sp)
0x000000000001997a in _fclose_r ()
=> 0x1997a <_fclose_r+8>:	mv	s0,a0
0x000000000001997c in _fclose_r ()
=> 0x1997c <_fclose_r+10>:	beqz	a0,0x19982 <_fclose_r+16>
0x000000000001997e in _fclose_r ()
=> 0x1997e <_fclose_r+12>:	lw	a5,80(a0)
0x0000000000019980 in _fclose_r ()
=> 0x19980 <_fclose_r+14>:	beqz	a5,0x1999c <_fclose_r+42>
0x0000000000019982 in _fclose_r ()
=> 0x19982 <_fclose_r+16>:	lh	a5,16(a1)
0x0000000000019986 in _fclose_r ()
=> 0x19986 <_fclose_r+20>:	bnez	a5,0x19992 <_fclose_r+32>
0x0000000000019992 in _fclose_r ()
=> 0x19992 <_fclose_r+32>:	mv	a0,s0
0x0000000000019994 in _fclose_r ()
=> 0x19994 <_fclose_r+34>:	ld	s0,16(sp)
0x0000000000019996 in _fclose_r ()
=> 0x19996 <_fclose_r+36>:	ld	ra,24(sp)
0x0000000000019998 in _fclose_r ()
=> 0x19998 <_fclose_r+38>:	addi	sp,sp,32
0x000000000001999a in _fclose_r ()
=> 0x1999a <_fclose_r+40>:	j	0x198f2 <_fclose_r.part.0>
0x00000000000198f2 in _fclose_r.part.0 ()
=> 0x198f2 <_fclose_r.part.0>:	addi	sp,sp,-32
0x00000000000198f4 in _fclose_r.part.0 ()
=> 0x198f4 <_fclose_r.part.0+2>:	sd	s0,16(sp)
0x00000000000198f6 in _fclose_r.part.0 ()
=> 0x198f6 <_fclose_r.part.0+4>:	sd	s1,8(sp)
0x00000000000198f8 in _fclose_r.part.0 ()
=> 0x198f8 <_fclose_r.part.0+6>:	sd	s2,0(sp)
0x00000000000198fa in _fclose_r.part.0 ()
=> 0x198fa <_fclose_r.part.0+8>:	mv	s0,a1
0x00000000000198fc in _fclose_r.part.0 ()
=> 0x198fc <_fclose_r.part.0+10>:	sd	ra,24(sp)
0x00000000000198fe in _fclose_r.part.0 ()
=> 0x198fe <_fclose_r.part.0+12>:	mv	s1,a0
0x0000000000019900 in _fclose_r.part.0 ()
=> 0x19900 <_fclose_r.part.0+14>:	jal	ra,0x12ff4 <__sflush_r>
0x0000000000012ff4 in __sflush_r ()
=> 0x12ff4 <__sflush_r>:	lh	a5,16(a1)
0x0000000000012ff8 in __sflush_r ()
=> 0x12ff8 <__sflush_r+4>:	addi	sp,sp,-48
0x0000000000012ffa in __sflush_r ()
=> 0x12ffa <__sflush_r+6>:	sd	s0,32(sp)
0x0000000000012ffc in __sflush_r ()
=> 0x12ffc <__sflush_r+8>:	sd	s3,8(sp)
0x0000000000012ffe in __sflush_r ()
=> 0x12ffe <__sflush_r+10>:	sd	ra,40(sp)
0x0000000000013000 in __sflush_r ()
=> 0x13000 <__sflush_r+12>:	sd	s1,24(sp)
0x0000000000013002 in __sflush_r ()
=> 0x13002 <__sflush_r+14>:	sd	s2,16(sp)
0x0000000000013004 in __sflush_r ()
=> 0x13004 <__sflush_r+16>:	andi	a3,a5,8
0x0000000000013008 in __sflush_r ()
=> 0x13008 <__sflush_r+20>:	mv	s0,a1
0x000000000001300a in __sflush_r ()
=> 0x1300a <__sflush_r+22>:	mv	s3,a0
0x000000000001300c in __sflush_r ()
=> 0x1300c <__sflush_r+24>:	bnez	a3,0x130c0 <__sflush_r+204>
0x000000000001300e in __sflush_r ()
=> 0x1300e <__sflush_r+26>:	lui	a4,0x1
0x0000000000013010 in __sflush_r ()
=> 0x13010 <__sflush_r+28>:	addi	a4,a4,-2048
0x0000000000013014 in __sflush_r ()
=> 0x13014 <__sflush_r+32>:	lw	a3,8(a1)
0x0000000000013016 in __sflush_r ()
=> 0x13016 <__sflush_r+34>:	or	a5,a5,a4
0x0000000000013018 in __sflush_r ()
=> 0x13018 <__sflush_r+36>:	sh	a5,16(a1)
0x000000000001301c in __sflush_r ()
=> 0x1301c <__sflush_r+40>:	blez	a3,0x1311c <__sflush_r+296>
0x000000000001311c in __sflush_r ()
=> 0x1311c <__sflush_r+296>:	lw	a4,112(a1)
0x000000000001311e in __sflush_r ()
=> 0x1311e <__sflush_r+298>:	bgtz	a4,0x13020 <__sflush_r+44>
0x0000000000013122 in __sflush_r ()
=> 0x13122 <__sflush_r+302>:	j	0x130b0 <__sflush_r+188>
0x00000000000130b0 in __sflush_r ()
=> 0x130b0 <__sflush_r+188>:	li	a0,0
0x00000000000130b2 in __sflush_r ()
=> 0x130b2 <__sflush_r+190>:	ld	ra,40(sp)
0x00000000000130b4 in __sflush_r ()
=> 0x130b4 <__sflush_r+192>:	ld	s0,32(sp)
0x00000000000130b6 in __sflush_r ()
=> 0x130b6 <__sflush_r+194>:	ld	s1,24(sp)
0x00000000000130b8 in __sflush_r ()
=> 0x130b8 <__sflush_r+196>:	ld	s2,16(sp)
0x00000000000130ba in __sflush_r ()
=> 0x130ba <__sflush_r+198>:	ld	s3,8(sp)
0x00000000000130bc in __sflush_r ()
=> 0x130bc <__sflush_r+200>:	addi	sp,sp,48
0x00000000000130be in __sflush_r ()
=> 0x130be <__sflush_r+202>:	ret
0x0000000000019904 in _fclose_r.part.0 ()
=> 0x19904 <_fclose_r.part.0+18>:	ld	a5,80(s0)
0x0000000000019906 in _fclose_r.part.0 ()
=> 0x19906 <_fclose_r.part.0+20>:	mv	s2,a0
0x0000000000019908 in _fclose_r.part.0 ()
=> 0x19908 <_fclose_r.part.0+22>:	beqz	a5,0x19914 <_fclose_r.part.0+34>
0x000000000001990a in _fclose_r.part.0 ()
=> 0x1990a <_fclose_r.part.0+24>:	ld	a1,48(s0)
0x000000000001990c in _fclose_r.part.0 ()
=> 0x1990c <_fclose_r.part.0+26>:	mv	a0,s1
0x000000000001990e in _fclose_r.part.0 ()
=> 0x1990e <_fclose_r.part.0+28>:	jalr	a5
0x0000000000016c08 in __sclose ()
=> 0x16c08 <__sclose>:	lh	a1,18(a1)
0x0000000000016c0c in __sclose ()
=> 0x16c0c <__sclose+4>:	j	0x198b6 <_close_r>
0x00000000000198b6 in _close_r ()
=> 0x198b6 <_close_r>:	addi	sp,sp,-32
0x00000000000198b8 in _close_r ()
=> 0x198b8 <_close_r+2>:	sd	s0,16(sp)
0x00000000000198ba in _close_r ()
=> 0x198ba <_close_r+4>:	sd	s1,8(sp)
0x00000000000198bc in _close_r ()
=> 0x198bc <_close_r+6>:	mv	s0,a0
0x00000000000198be in _close_r ()
=> 0x198be <_close_r+8>:	mv	a0,a1
0x00000000000198c0 in _close_r ()
=> 0x198c0 <_close_r+10>:	sd	ra,24(sp)
0x00000000000198c2 in _close_r ()
=> 0x198c2 <_close_r+12>:	sw	zero,1936(gp)
0x00000000000198c6 in _close_r ()
=> 0x198c6 <_close_r+16>:	jal	ra,0x1b716 <_close>
0x000000000001b716 in _close ()
=> 0x1b716 <_close>:	addi	sp,sp,-16
0x000000000001b718 in _close ()
=> 0x1b718 <_close+2>:	sd	ra,8(sp)
0x000000000001b71a in _close ()
=> 0x1b71a <_close+4>:	sd	s0,0(sp)
0x000000000001b71c in _close ()
=> 0x1b71c <_close+6>:	li	a7,57
0x000000000001b720 in _close ()
=> 0x1b720 <_close+10>:	ecall
0x000000000001b724 in _close ()
=> 0x1b724 <_close+14>:	mv	s0,a0
0x000000000001b726 in _close ()
=> 0x1b726 <_close+16>:	bltz	a0,0x1b734 <_close+30>
0x000000000001b72a in _close ()
=> 0x1b72a <_close+20>:	sext.w	a0,a0
0x000000000001b72c in _close ()
=> 0x1b72c <_close+22>:	ld	ra,8(sp)
0x000000000001b72e in _close ()
=> 0x1b72e <_close+24>:	ld	s0,0(sp)
0x000000000001b730 in _close ()
=> 0x1b730 <_close+26>:	addi	sp,sp,16
0x000000000001b732 in _close ()
=> 0x1b732 <_close+28>:	ret
0x00000000000198ca in _close_r ()
=> 0x198ca <_close_r+20>:	li	a5,-1
0x00000000000198cc in _close_r ()
=> 0x198cc <_close_r+22>:	beq	a0,a5,0x198da <_close_r+36>
0x00000000000198d0 in _close_r ()
=> 0x198d0 <_close_r+26>:	ld	ra,24(sp)
0x00000000000198d2 in _close_r ()
=> 0x198d2 <_close_r+28>:	ld	s0,16(sp)
0x00000000000198d4 in _close_r ()
=> 0x198d4 <_close_r+30>:	ld	s1,8(sp)
0x00000000000198d6 in _close_r ()
=> 0x198d6 <_close_r+32>:	addi	sp,sp,32
0x00000000000198d8 in _close_r ()
=> 0x198d8 <_close_r+34>:	ret
0x0000000000019910 in _fclose_r.part.0 ()
=> 0x19910 <_fclose_r.part.0+30>:	bltz	a0,0x1995c <_fclose_r.part.0+106>
0x0000000000019914 in _fclose_r.part.0 ()
=> 0x19914 <_fclose_r.part.0+34>:	lhu	a5,16(s0)
0x0000000000019918 in _fclose_r.part.0 ()
=> 0x19918 <_fclose_r.part.0+38>:	andi	a5,a5,128
0x000000000001991c in _fclose_r.part.0 ()
=> 0x1991c <_fclose_r.part.0+42>:	bnez	a5,0x19968 <_fclose_r.part.0+118>
0x000000000001991e in _fclose_r.part.0 ()
=> 0x1991e <_fclose_r.part.0+44>:	ld	a1,88(s0)
0x0000000000019920 in _fclose_r.part.0 ()
=> 0x19920 <_fclose_r.part.0+46>:	beqz	a1,0x19934 <_fclose_r.part.0+66>
0x0000000000019934 in _fclose_r.part.0 ()
=> 0x19934 <_fclose_r.part.0+66>:	ld	a1,120(s0)
0x0000000000019936 in _fclose_r.part.0 ()
=> 0x19936 <_fclose_r.part.0+68>:	beqz	a1,0x19942 <_fclose_r.part.0+80>
0x0000000000019942 in _fclose_r.part.0 ()
=> 0x19942 <_fclose_r.part.0+80>:	jal	ra,0x1346a <__sfp_lock_acquire>
0x000000000001346a in __sfp_lock_acquire ()
=> 0x1346a <__sfp_lock_acquire>:	ret
0x0000000000019946 in _fclose_r.part.0 ()
=> 0x19946 <_fclose_r.part.0+84>:	sh	zero,16(s0)
0x000000000001994a in _fclose_r.part.0 ()
=> 0x1994a <_fclose_r.part.0+88>:	jal	ra,0x1346c <__sfp_lock_release>
0x000000000001346c in __sfp_lock_release ()
=> 0x1346c <__sfp_lock_release>:	ret
0x000000000001994e in _fclose_r.part.0 ()
=> 0x1994e <_fclose_r.part.0+92>:	ld	ra,24(sp)
0x0000000000019950 in _fclose_r.part.0 ()
=> 0x19950 <_fclose_r.part.0+94>:	ld	s0,16(sp)
0x0000000000019952 in _fclose_r.part.0 ()
=> 0x19952 <_fclose_r.part.0+96>:	ld	s1,8(sp)
0x0000000000019954 in _fclose_r.part.0 ()
=> 0x19954 <_fclose_r.part.0+98>:	mv	a0,s2
0x0000000000019956 in _fclose_r.part.0 ()
=> 0x19956 <_fclose_r.part.0+100>:	ld	s2,0(sp)
0x0000000000019958 in _fclose_r.part.0 ()
=> 0x19958 <_fclose_r.part.0+102>:	addi	sp,sp,32
0x000000000001995a in _fclose_r.part.0 ()
=> 0x1995a <_fclose_r.part.0+104>:	ret
0x00000000000138c6 in _fwalk_reent ()
=> 0x138c6 <_fwalk_reent+90>:	or	s6,a0,s6
0x00000000000138ca in _fwalk_reent ()
=> 0x138ca <_fwalk_reent+94>:	sext.w	s6,s6
0x00000000000138cc in _fwalk_reent ()
=> 0x138cc <_fwalk_reent+96>:	addi	s0,s0,176
0x00000000000138d0 in _fwalk_reent ()
=> 0x138d0 <_fwalk_reent+100>:	bne	s1,s0,0x138b0 <_fwalk_reent+68>
0x00000000000138b0 in _fwalk_reent ()
=> 0x138b0 <_fwalk_reent+68>:	lhu	a5,16(s0)
0x00000000000138b4 in _fwalk_reent ()
=> 0x138b4 <_fwalk_reent+72>:	bgeu	s7,a5,0x138cc <_fwalk_reent+96>
0x00000000000138b8 in _fwalk_reent ()
=> 0x138b8 <_fwalk_reent+76>:	lh	a5,18(s0)
0x00000000000138bc in _fwalk_reent ()
=> 0x138bc <_fwalk_reent+80>:	mv	a1,s0
0x00000000000138be in _fwalk_reent ()
=> 0x138be <_fwalk_reent+82>:	mv	a0,s8
0x00000000000138c0 in _fwalk_reent ()
=> 0x138c0 <_fwalk_reent+84>:	beq	a5,s3,0x138cc <_fwalk_reent+96>
0x00000000000138c4 in _fwalk_reent ()
=> 0x138c4 <_fwalk_reent+88>:	jalr	s4
0x0000000000019972 in _fclose_r ()
=> 0x19972 <_fclose_r>:	beqz	a1,0x199ac <_fclose_r+58>
0x0000000000019974 in _fclose_r ()
=> 0x19974 <_fclose_r+2>:	addi	sp,sp,-32
0x0000000000019976 in _fclose_r ()
=> 0x19976 <_fclose_r+4>:	sd	s0,16(sp)
0x0000000000019978 in _fclose_r ()
=> 0x19978 <_fclose_r+6>:	sd	ra,24(sp)
0x000000000001997a in _fclose_r ()
=> 0x1997a <_fclose_r+8>:	mv	s0,a0
0x000000000001997c in _fclose_r ()
=> 0x1997c <_fclose_r+10>:	beqz	a0,0x19982 <_fclose_r+16>
0x000000000001997e in _fclose_r ()
=> 0x1997e <_fclose_r+12>:	lw	a5,80(a0)
0x0000000000019980 in _fclose_r ()
=> 0x19980 <_fclose_r+14>:	beqz	a5,0x1999c <_fclose_r+42>
0x0000000000019982 in _fclose_r ()
=> 0x19982 <_fclose_r+16>:	lh	a5,16(a1)
0x0000000000019986 in _fclose_r ()
=> 0x19986 <_fclose_r+20>:	bnez	a5,0x19992 <_fclose_r+32>
0x0000000000019992 in _fclose_r ()
=> 0x19992 <_fclose_r+32>:	mv	a0,s0
0x0000000000019994 in _fclose_r ()
=> 0x19994 <_fclose_r+34>:	ld	s0,16(sp)
0x0000000000019996 in _fclose_r ()
=> 0x19996 <_fclose_r+36>:	ld	ra,24(sp)
0x0000000000019998 in _fclose_r ()
=> 0x19998 <_fclose_r+38>:	addi	sp,sp,32
0x000000000001999a in _fclose_r ()
=> 0x1999a <_fclose_r+40>:	j	0x198f2 <_fclose_r.part.0>
0x00000000000198f2 in _fclose_r.part.0 ()
=> 0x198f2 <_fclose_r.part.0>:	addi	sp,sp,-32
0x00000000000198f4 in _fclose_r.part.0 ()
=> 0x198f4 <_fclose_r.part.0+2>:	sd	s0,16(sp)
0x00000000000198f6 in _fclose_r.part.0 ()
=> 0x198f6 <_fclose_r.part.0+4>:	sd	s1,8(sp)
0x00000000000198f8 in _fclose_r.part.0 ()
=> 0x198f8 <_fclose_r.part.0+6>:	sd	s2,0(sp)
0x00000000000198fa in _fclose_r.part.0 ()
=> 0x198fa <_fclose_r.part.0+8>:	mv	s0,a1
0x00000000000198fc in _fclose_r.part.0 ()
=> 0x198fc <_fclose_r.part.0+10>:	sd	ra,24(sp)
0x00000000000198fe in _fclose_r.part.0 ()
=> 0x198fe <_fclose_r.part.0+12>:	mv	s1,a0
0x0000000000019900 in _fclose_r.part.0 ()
=> 0x19900 <_fclose_r.part.0+14>:	jal	ra,0x12ff4 <__sflush_r>
0x0000000000012ff4 in __sflush_r ()
=> 0x12ff4 <__sflush_r>:	lh	a5,16(a1)
0x0000000000012ff8 in __sflush_r ()
=> 0x12ff8 <__sflush_r+4>:	addi	sp,sp,-48
0x0000000000012ffa in __sflush_r ()
=> 0x12ffa <__sflush_r+6>:	sd	s0,32(sp)
0x0000000000012ffc in __sflush_r ()
=> 0x12ffc <__sflush_r+8>:	sd	s3,8(sp)
0x0000000000012ffe in __sflush_r ()
=> 0x12ffe <__sflush_r+10>:	sd	ra,40(sp)
0x0000000000013000 in __sflush_r ()
=> 0x13000 <__sflush_r+12>:	sd	s1,24(sp)
0x0000000000013002 in __sflush_r ()
=> 0x13002 <__sflush_r+14>:	sd	s2,16(sp)
0x0000000000013004 in __sflush_r ()
=> 0x13004 <__sflush_r+16>:	andi	a3,a5,8
0x0000000000013008 in __sflush_r ()
=> 0x13008 <__sflush_r+20>:	mv	s0,a1
0x000000000001300a in __sflush_r ()
=> 0x1300a <__sflush_r+22>:	mv	s3,a0
0x000000000001300c in __sflush_r ()
=> 0x1300c <__sflush_r+24>:	bnez	a3,0x130c0 <__sflush_r+204>
0x00000000000130c0 in __sflush_r ()
=> 0x130c0 <__sflush_r+204>:	ld	s2,24(a1)
0x00000000000130c4 in __sflush_r ()
=> 0x130c4 <__sflush_r+208>:	beqz	s2,0x130b0 <__sflush_r+188>
0x00000000000130c8 in __sflush_r ()
=> 0x130c8 <__sflush_r+212>:	ld	s1,0(a1)
0x00000000000130ca in __sflush_r ()
=> 0x130ca <__sflush_r+214>:	slli	a4,a5,0x30
0x00000000000130ce in __sflush_r ()
=> 0x130ce <__sflush_r+218>:	srli	a4,a4,0x30
0x00000000000130d0 in __sflush_r ()
=> 0x130d0 <__sflush_r+220>:	andi	a4,a4,3
0x00000000000130d2 in __sflush_r ()
=> 0x130d2 <__sflush_r+222>:	sd	s2,0(a1)
0x00000000000130d6 in __sflush_r ()
=> 0x130d6 <__sflush_r+226>:	subw	s1,s1,s2
0x00000000000130da in __sflush_r ()
=> 0x130da <__sflush_r+230>:	li	a5,0
0x00000000000130dc in __sflush_r ()
=> 0x130dc <__sflush_r+232>:	bnez	a4,0x130e0 <__sflush_r+236>
0x00000000000130e0 in __sflush_r ()
=> 0x130e0 <__sflush_r+236>:	sw	a5,12(s0)
0x00000000000130e2 in __sflush_r ()
=> 0x130e2 <__sflush_r+238>:	bgtz	s1,0x130ee <__sflush_r+250>
0x00000000000130e6 in __sflush_r ()
=> 0x130e6 <__sflush_r+242>:	j	0x130b0 <__sflush_r+188>
0x00000000000130b0 in __sflush_r ()
=> 0x130b0 <__sflush_r+188>:	li	a0,0
0x00000000000130b2 in __sflush_r ()
=> 0x130b2 <__sflush_r+190>:	ld	ra,40(sp)
0x00000000000130b4 in __sflush_r ()
=> 0x130b4 <__sflush_r+192>:	ld	s0,32(sp)
0x00000000000130b6 in __sflush_r ()
=> 0x130b6 <__sflush_r+194>:	ld	s1,24(sp)
0x00000000000130b8 in __sflush_r ()
=> 0x130b8 <__sflush_r+196>:	ld	s2,16(sp)
0x00000000000130ba in __sflush_r ()
=> 0x130ba <__sflush_r+198>:	ld	s3,8(sp)
0x00000000000130bc in __sflush_r ()
=> 0x130bc <__sflush_r+200>:	addi	sp,sp,48
0x00000000000130be in __sflush_r ()
=> 0x130be <__sflush_r+202>:	ret
0x0000000000019904 in _fclose_r.part.0 ()
=> 0x19904 <_fclose_r.part.0+18>:	ld	a5,80(s0)
0x0000000000019906 in _fclose_r.part.0 ()
=> 0x19906 <_fclose_r.part.0+20>:	mv	s2,a0
0x0000000000019908 in _fclose_r.part.0 ()
=> 0x19908 <_fclose_r.part.0+22>:	beqz	a5,0x19914 <_fclose_r.part.0+34>
0x000000000001990a in _fclose_r.part.0 ()
=> 0x1990a <_fclose_r.part.0+24>:	ld	a1,48(s0)
0x000000000001990c in _fclose_r.part.0 ()
=> 0x1990c <_fclose_r.part.0+26>:	mv	a0,s1
0x000000000001990e in _fclose_r.part.0 ()
=> 0x1990e <_fclose_r.part.0+28>:	jalr	a5
0x0000000000016c08 in __sclose ()
=> 0x16c08 <__sclose>:	lh	a1,18(a1)
0x0000000000016c0c in __sclose ()
=> 0x16c0c <__sclose+4>:	j	0x198b6 <_close_r>
0x00000000000198b6 in _close_r ()
=> 0x198b6 <_close_r>:	addi	sp,sp,-32
0x00000000000198b8 in _close_r ()
=> 0x198b8 <_close_r+2>:	sd	s0,16(sp)
0x00000000000198ba in _close_r ()
=> 0x198ba <_close_r+4>:	sd	s1,8(sp)
0x00000000000198bc in _close_r ()
=> 0x198bc <_close_r+6>:	mv	s0,a0
0x00000000000198be in _close_r ()
=> 0x198be <_close_r+8>:	mv	a0,a1
0x00000000000198c0 in _close_r ()
=> 0x198c0 <_close_r+10>:	sd	ra,24(sp)
0x00000000000198c2 in _close_r ()
=> 0x198c2 <_close_r+12>:	sw	zero,1936(gp)
0x00000000000198c6 in _close_r ()
=> 0x198c6 <_close_r+16>:	jal	ra,0x1b716 <_close>
0x000000000001b716 in _close ()
=> 0x1b716 <_close>:	addi	sp,sp,-16
0x000000000001b718 in _close ()
=> 0x1b718 <_close+2>:	sd	ra,8(sp)
0x000000000001b71a in _close ()
=> 0x1b71a <_close+4>:	sd	s0,0(sp)
0x000000000001b71c in _close ()
=> 0x1b71c <_close+6>:	li	a7,57
0x000000000001b720 in _close ()
=> 0x1b720 <_close+10>:	ecall
0x000000000001b724 in _close ()
=> 0x1b724 <_close+14>:	mv	s0,a0
0x000000000001b726 in _close ()
=> 0x1b726 <_close+16>:	bltz	a0,0x1b734 <_close+30>
0x000000000001b72a in _close ()
=> 0x1b72a <_close+20>:	sext.w	a0,a0
0x000000000001b72c in _close ()
=> 0x1b72c <_close+22>:	ld	ra,8(sp)
0x000000000001b72e in _close ()
=> 0x1b72e <_close+24>:	ld	s0,0(sp)
0x000000000001b730 in _close ()
=> 0x1b730 <_close+26>:	addi	sp,sp,16
0x000000000001b732 in _close ()
=> 0x1b732 <_close+28>:	ret
0x00000000000198ca in _close_r ()
=> 0x198ca <_close_r+20>:	li	a5,-1
0x00000000000198cc in _close_r ()
=> 0x198cc <_close_r+22>:	beq	a0,a5,0x198da <_close_r+36>
0x00000000000198d0 in _close_r ()
=> 0x198d0 <_close_r+26>:	ld	ra,24(sp)
0x00000000000198d2 in _close_r ()
=> 0x198d2 <_close_r+28>:	ld	s0,16(sp)
0x00000000000198d4 in _close_r ()
=> 0x198d4 <_close_r+30>:	ld	s1,8(sp)
0x00000000000198d6 in _close_r ()
=> 0x198d6 <_close_r+32>:	addi	sp,sp,32
0x00000000000198d8 in _close_r ()
=> 0x198d8 <_close_r+34>:	ret
0x0000000000019910 in _fclose_r.part.0 ()
=> 0x19910 <_fclose_r.part.0+30>:	bltz	a0,0x1995c <_fclose_r.part.0+106>
0x0000000000019914 in _fclose_r.part.0 ()
=> 0x19914 <_fclose_r.part.0+34>:	lhu	a5,16(s0)
0x0000000000019918 in _fclose_r.part.0 ()
=> 0x19918 <_fclose_r.part.0+38>:	andi	a5,a5,128
0x000000000001991c in _fclose_r.part.0 ()
=> 0x1991c <_fclose_r.part.0+42>:	bnez	a5,0x19968 <_fclose_r.part.0+118>
0x0000000000019968 in _fclose_r.part.0 ()
=> 0x19968 <_fclose_r.part.0+118>:	ld	a1,24(s0)
0x000000000001996a in _fclose_r.part.0 ()
=> 0x1996a <_fclose_r.part.0+120>:	mv	a0,s1
0x000000000001996c in _fclose_r.part.0 ()
=> 0x1996c <_fclose_r.part.0+122>:	jal	ra,0x13598 <_free_r>
0x0000000000013598 in _free_r ()
=> 0x13598 <_free_r>:	beqz	a1,0x13688 <_free_r+240>
0x000000000001359a in _free_r ()
=> 0x1359a <_free_r+2>:	addi	sp,sp,-32
0x000000000001359c in _free_r ()
=> 0x1359c <_free_r+4>:	sd	s0,16(sp)
0x000000000001359e in _free_r ()
=> 0x1359e <_free_r+6>:	sd	s1,8(sp)
0x00000000000135a0 in _free_r ()
=> 0x135a0 <_free_r+8>:	mv	s0,a1
0x00000000000135a2 in _free_r ()
=> 0x135a2 <_free_r+10>:	mv	s1,a0
0x00000000000135a4 in _free_r ()
=> 0x135a4 <_free_r+12>:	sd	ra,24(sp)
0x00000000000135a6 in _free_r ()
=> 0x135a6 <_free_r+14>:	jal	ra,0x11192 <__malloc_lock>
0x0000000000011192 in __malloc_lock ()
=> 0x11192 <__malloc_lock>:	ret
0x00000000000135aa in _free_r ()
=> 0x135aa <_free_r+18>:	ld	a0,-8(s0)
0x00000000000135ae in _free_r ()
=> 0x135ae <_free_r+22>:	addi	a4,s0,-16
0x00000000000135b2 in _free_r ()
=> 0x135b2 <_free_r+26>:	lui	a1,0x1f
0x00000000000135b6 in _free_r ()
=> 0x135b6 <_free_r+30>:	andi	a5,a0,-2
0x00000000000135ba in _free_r ()
=> 0x135ba <_free_r+34>:	add	a2,a4,a5
0x00000000000135be in _free_r ()
=> 0x135be <_free_r+38>:	addi	a1,a1,744
0x00000000000135c2 in _free_r ()
=> 0x135c2 <_free_r+42>:	ld	a3,8(a2)
0x00000000000135c4 in _free_r ()
=> 0x135c4 <_free_r+44>:	ld	a6,16(a1)
0x00000000000135c8 in _free_r ()
=> 0x135c8 <_free_r+48>:	andi	a3,a3,-4
0x00000000000135ca in _free_r ()
=> 0x135ca <_free_r+50>:	beq	a6,a2,0x1370e <_free_r+374>
0x000000000001370e in _free_r ()
=> 0x1370e <_free_r+374>:	andi	a0,a0,1
0x0000000000013710 in _free_r ()
=> 0x13710 <_free_r+376>:	add	a5,a5,a3
0x0000000000013712 in _free_r ()
=> 0x13712 <_free_r+378>:	bnez	a0,0x13724 <_free_r+396>
0x0000000000013714 in _free_r ()
=> 0x13714 <_free_r+380>:	ld	a0,-16(s0)
0x0000000000013718 in _free_r ()
=> 0x13718 <_free_r+384>:	sub	a4,a4,a0
0x000000000001371a in _free_r ()
=> 0x1371a <_free_r+386>:	ld	a3,24(a4)
0x000000000001371c in _free_r ()
=> 0x1371c <_free_r+388>:	ld	a2,16(a4)
0x000000000001371e in _free_r ()
=> 0x1371e <_free_r+390>:	add	a5,a5,a0
0x0000000000013720 in _free_r ()
=> 0x13720 <_free_r+392>:	sd	a3,24(a2)
0x0000000000013722 in _free_r ()
=> 0x13722 <_free_r+394>:	sd	a2,16(a3)
0x0000000000013724 in _free_r ()
=> 0x13724 <_free_r+396>:	ori	a2,a5,1
0x0000000000013728 in _free_r ()
=> 0x13728 <_free_r+400>:	ld	a3,1864(gp)
0x000000000001372c in _free_r ()
=> 0x1372c <_free_r+404>:	sd	a2,8(a4)
0x000000000001372e in _free_r ()
=> 0x1372e <_free_r+406>:	sd	a4,16(a1)
0x0000000000013730 in _free_r ()
=> 0x13730 <_free_r+408>:	bltu	a5,a3,0x1364a <_free_r+178>
0x0000000000013734 in _free_r ()
=> 0x13734 <_free_r+412>:	ld	a1,1920(gp)
0x0000000000013738 in _free_r ()
=> 0x13738 <_free_r+416>:	mv	a0,s1
0x000000000001373a in _free_r ()
=> 0x1373a <_free_r+418>:	jal	ra,0x134c2 <_malloc_trim_r>
0x00000000000134c2 in _malloc_trim_r ()
=> 0x134c2 <_malloc_trim_r>:	addi	sp,sp,-48
0x00000000000134c4 in _malloc_trim_r ()
=> 0x134c4 <_malloc_trim_r+2>:	sd	s3,8(sp)
0x00000000000134c6 in _malloc_trim_r ()
=> 0x134c6 <_malloc_trim_r+4>:	lui	s3,0x1f
0x00000000000134ca in _malloc_trim_r ()
=> 0x134ca <_malloc_trim_r+8>:	sd	s0,32(sp)
0x00000000000134cc in _malloc_trim_r ()
=> 0x134cc <_malloc_trim_r+10>:	sd	s1,24(sp)
0x00000000000134ce in _malloc_trim_r ()
=> 0x134ce <_malloc_trim_r+12>:	sd	s2,16(sp)
0x00000000000134d0 in _malloc_trim_r ()
=> 0x134d0 <_malloc_trim_r+14>:	sd	s4,0(sp)
0x00000000000134d2 in _malloc_trim_r ()
=> 0x134d2 <_malloc_trim_r+16>:	sd	ra,40(sp)
0x00000000000134d4 in _malloc_trim_r ()
=> 0x134d4 <_malloc_trim_r+18>:	mv	s4,a1
0x00000000000134d6 in _malloc_trim_r ()
=> 0x134d6 <_malloc_trim_r+20>:	mv	s2,a0
0x00000000000134d8 in _malloc_trim_r ()
=> 0x134d8 <_malloc_trim_r+22>:	addi	s3,s3,744
0x00000000000134dc in _malloc_trim_r ()
=> 0x134dc <_malloc_trim_r+26>:	jal	ra,0x11192 <__malloc_lock>
0x0000000000011192 in __malloc_lock ()
=> 0x11192 <__malloc_lock>:	ret
0x00000000000134e0 in _malloc_trim_r ()
=> 0x134e0 <_malloc_trim_r+30>:	ld	a4,16(s3)
0x00000000000134e4 in _malloc_trim_r ()
=> 0x134e4 <_malloc_trim_r+34>:	lui	a5,0x1
0x00000000000134e6 in _malloc_trim_r ()
=> 0x134e6 <_malloc_trim_r+36>:	addi	s0,a5,-33
0x00000000000134ea in _malloc_trim_r ()
=> 0x134ea <_malloc_trim_r+40>:	ld	s1,8(a4)
0x00000000000134ec in _malloc_trim_r ()
=> 0x134ec <_malloc_trim_r+42>:	sub	s0,s0,s4
0x00000000000134f0 in _malloc_trim_r ()
=> 0x134f0 <_malloc_trim_r+46>:	andi	s1,s1,-4
0x00000000000134f2 in _malloc_trim_r ()
=> 0x134f2 <_malloc_trim_r+48>:	add	s0,s0,s1
0x00000000000134f4 in _malloc_trim_r ()
=> 0x134f4 <_malloc_trim_r+50>:	srli	s0,s0,0xc
0x00000000000134f6 in _malloc_trim_r ()
=> 0x134f6 <_malloc_trim_r+52>:	addi	s0,s0,-1
0x00000000000134f8 in _malloc_trim_r ()
=> 0x134f8 <_malloc_trim_r+54>:	slli	s0,s0,0xc
0x00000000000134fa in _malloc_trim_r ()
=> 0x134fa <_malloc_trim_r+56>:	blt	s0,a5,0x13510 <_malloc_trim_r+78>
0x00000000000134fe in _malloc_trim_r ()
=> 0x134fe <_malloc_trim_r+60>:	li	a1,0
0x0000000000013500 in _malloc_trim_r ()
=> 0x13500 <_malloc_trim_r+62>:	mv	a0,s2
0x0000000000013502 in _malloc_trim_r ()
=> 0x13502 <_malloc_trim_r+64>:	jal	ra,0x111e4 <_sbrk_r>
0x00000000000111e4 in _sbrk_r ()
=> 0x111e4 <_sbrk_r>:	addi	sp,sp,-32
0x00000000000111e6 in _sbrk_r ()
=> 0x111e6 <_sbrk_r+2>:	sd	s0,16(sp)
0x00000000000111e8 in _sbrk_r ()
=> 0x111e8 <_sbrk_r+4>:	sd	s1,8(sp)
0x00000000000111ea in _sbrk_r ()
=> 0x111ea <_sbrk_r+6>:	mv	s0,a0
0x00000000000111ec in _sbrk_r ()
=> 0x111ec <_sbrk_r+8>:	mv	a0,a1
0x00000000000111ee in _sbrk_r ()
=> 0x111ee <_sbrk_r+10>:	sd	ra,24(sp)
0x00000000000111f0 in _sbrk_r ()
=> 0x111f0 <_sbrk_r+12>:	sw	zero,1936(gp)
0x00000000000111f4 in _sbrk_r ()
=> 0x111f4 <_sbrk_r+16>:	jal	ra,0x1b83a <_sbrk>
0x000000000001b83a in _sbrk ()
=> 0x1b83a <_sbrk>:	ld	a4,1944(gp)
0x000000000001b83e in _sbrk ()
=> 0x1b83e <_sbrk+4>:	addi	sp,sp,-16
0x000000000001b840 in _sbrk ()
=> 0x1b840 <_sbrk+6>:	sd	ra,8(sp)
0x000000000001b842 in _sbrk ()
=> 0x1b842 <_sbrk+8>:	mv	a5,a0
0x000000000001b844 in _sbrk ()
=> 0x1b844 <_sbrk+10>:	bnez	a4,0x1b85c <_sbrk+34>
0x000000000001b85c in _sbrk ()
=> 0x1b85c <_sbrk+34>:	li	a7,214
0x000000000001b860 in _sbrk ()
=> 0x1b860 <_sbrk+38>:	add	a0,a5,a4
0x000000000001b864 in _sbrk ()
=> 0x1b864 <_sbrk+42>:	ecall
0x000000000001b868 in _sbrk ()
=> 0x1b868 <_sbrk+46>:	ld	a4,1944(gp)
0x000000000001b86c in _sbrk ()
=> 0x1b86c <_sbrk+50>:	add	a5,a5,a4
0x000000000001b86e in _sbrk ()
=> 0x1b86e <_sbrk+52>:	bne	a0,a5,0x1b87e <_sbrk+68>
0x000000000001b872 in _sbrk ()
=> 0x1b872 <_sbrk+56>:	ld	ra,8(sp)
0x000000000001b874 in _sbrk ()
=> 0x1b874 <_sbrk+58>:	sd	a0,1944(gp)
0x000000000001b878 in _sbrk ()
=> 0x1b878 <_sbrk+62>:	mv	a0,a4
0x000000000001b87a in _sbrk ()
=> 0x1b87a <_sbrk+64>:	addi	sp,sp,16
0x000000000001b87c in _sbrk ()
=> 0x1b87c <_sbrk+66>:	ret
0x00000000000111f8 in _sbrk_r ()
=> 0x111f8 <_sbrk_r+20>:	li	a5,-1
0x00000000000111fa in _sbrk_r ()
=> 0x111fa <_sbrk_r+22>:	beq	a0,a5,0x11208 <_sbrk_r+36>
0x00000000000111fe in _sbrk_r ()
=> 0x111fe <_sbrk_r+26>:	ld	ra,24(sp)
0x0000000000011200 in _sbrk_r ()
=> 0x11200 <_sbrk_r+28>:	ld	s0,16(sp)
0x0000000000011202 in _sbrk_r ()
=> 0x11202 <_sbrk_r+30>:	ld	s1,8(sp)
0x0000000000011204 in _sbrk_r ()
=> 0x11204 <_sbrk_r+32>:	addi	sp,sp,32
0x0000000000011206 in _sbrk_r ()
=> 0x11206 <_sbrk_r+34>:	ret
0x0000000000013506 in _malloc_trim_r ()
=> 0x13506 <_malloc_trim_r+68>:	ld	a5,16(s3)
0x000000000001350a in _malloc_trim_r ()
=> 0x1350a <_malloc_trim_r+72>:	add	a5,a5,s1
0x000000000001350c in _malloc_trim_r ()
=> 0x1350c <_malloc_trim_r+74>:	beq	a0,a5,0x13528 <_malloc_trim_r+102>
0x0000000000013528 in _malloc_trim_r ()
=> 0x13528 <_malloc_trim_r+102>:	neg	a1,s0
0x000000000001352c in _malloc_trim_r ()
=> 0x1352c <_malloc_trim_r+106>:	mv	a0,s2
0x000000000001352e in _malloc_trim_r ()
=> 0x1352e <_malloc_trim_r+108>:	jal	ra,0x111e4 <_sbrk_r>
0x00000000000111e4 in _sbrk_r ()
=> 0x111e4 <_sbrk_r>:	addi	sp,sp,-32
0x00000000000111e6 in _sbrk_r ()
=> 0x111e6 <_sbrk_r+2>:	sd	s0,16(sp)
0x00000000000111e8 in _sbrk_r ()
=> 0x111e8 <_sbrk_r+4>:	sd	s1,8(sp)
0x00000000000111ea in _sbrk_r ()
=> 0x111ea <_sbrk_r+6>:	mv	s0,a0
0x00000000000111ec in _sbrk_r ()
=> 0x111ec <_sbrk_r+8>:	mv	a0,a1
0x00000000000111ee in _sbrk_r ()
=> 0x111ee <_sbrk_r+10>:	sd	ra,24(sp)
0x00000000000111f0 in _sbrk_r ()
=> 0x111f0 <_sbrk_r+12>:	sw	zero,1936(gp)
0x00000000000111f4 in _sbrk_r ()
=> 0x111f4 <_sbrk_r+16>:	jal	ra,0x1b83a <_sbrk>
0x000000000001b83a in _sbrk ()
=> 0x1b83a <_sbrk>:	ld	a4,1944(gp)
0x000000000001b83e in _sbrk ()
=> 0x1b83e <_sbrk+4>:	addi	sp,sp,-16
0x000000000001b840 in _sbrk ()
=> 0x1b840 <_sbrk+6>:	sd	ra,8(sp)
0x000000000001b842 in _sbrk ()
=> 0x1b842 <_sbrk+8>:	mv	a5,a0
0x000000000001b844 in _sbrk ()
=> 0x1b844 <_sbrk+10>:	bnez	a4,0x1b85c <_sbrk+34>
0x000000000001b85c in _sbrk ()
=> 0x1b85c <_sbrk+34>:	li	a7,214
0x000000000001b860 in _sbrk ()
=> 0x1b860 <_sbrk+38>:	add	a0,a5,a4
0x000000000001b864 in _sbrk ()
=> 0x1b864 <_sbrk+42>:	ecall
0x000000000001b868 in _sbrk ()
=> 0x1b868 <_sbrk+46>:	ld	a4,1944(gp)
0x000000000001b86c in _sbrk ()
=> 0x1b86c <_sbrk+50>:	add	a5,a5,a4
0x000000000001b86e in _sbrk ()
=> 0x1b86e <_sbrk+52>:	bne	a0,a5,0x1b87e <_sbrk+68>
0x000000000001b872 in _sbrk ()
=> 0x1b872 <_sbrk+56>:	ld	ra,8(sp)
0x000000000001b874 in _sbrk ()
=> 0x1b874 <_sbrk+58>:	sd	a0,1944(gp)
0x000000000001b878 in _sbrk ()
=> 0x1b878 <_sbrk+62>:	mv	a0,a4
0x000000000001b87a in _sbrk ()
=> 0x1b87a <_sbrk+64>:	addi	sp,sp,16
0x000000000001b87c in _sbrk ()
=> 0x1b87c <_sbrk+66>:	ret
0x00000000000111f8 in _sbrk_r ()
=> 0x111f8 <_sbrk_r+20>:	li	a5,-1
0x00000000000111fa in _sbrk_r ()
=> 0x111fa <_sbrk_r+22>:	beq	a0,a5,0x11208 <_sbrk_r+36>
0x00000000000111fe in _sbrk_r ()
=> 0x111fe <_sbrk_r+26>:	ld	ra,24(sp)
0x0000000000011200 in _sbrk_r ()
=> 0x11200 <_sbrk_r+28>:	ld	s0,16(sp)
0x0000000000011202 in _sbrk_r ()
=> 0x11202 <_sbrk_r+30>:	ld	s1,8(sp)
0x0000000000011204 in _sbrk_r ()
=> 0x11204 <_sbrk_r+32>:	addi	sp,sp,32
0x0000000000011206 in _sbrk_r ()
=> 0x11206 <_sbrk_r+34>:	ret
0x0000000000013532 in _malloc_trim_r ()
=> 0x13532 <_malloc_trim_r+112>:	li	a5,-1
0x0000000000013534 in _malloc_trim_r ()
=> 0x13534 <_malloc_trim_r+114>:	beq	a0,a5,0x1356c <_malloc_trim_r+170>
0x0000000000013538 in _malloc_trim_r ()
=> 0x13538 <_malloc_trim_r+118>:	lui	a5,0x20
0x000000000001353c in _malloc_trim_r ()
=> 0x1353c <_malloc_trim_r+122>:	addi	a5,a5,-640
0x0000000000013540 in _malloc_trim_r ()
=> 0x13540 <_malloc_trim_r+126>:	lw	a4,0(a5)
0x0000000000013542 in _malloc_trim_r ()
=> 0x13542 <_malloc_trim_r+128>:	ld	a3,16(s3)
0x0000000000013546 in _malloc_trim_r ()
=> 0x13546 <_malloc_trim_r+132>:	sub	s1,s1,s0
0x0000000000013548 in _malloc_trim_r ()
=> 0x13548 <_malloc_trim_r+134>:	ori	s1,s1,1
0x000000000001354c in _malloc_trim_r ()
=> 0x1354c <_malloc_trim_r+138>:	subw	s0,a4,s0
0x0000000000013550 in _malloc_trim_r ()
=> 0x13550 <_malloc_trim_r+142>:	mv	a0,s2
0x0000000000013552 in _malloc_trim_r ()
=> 0x13552 <_malloc_trim_r+144>:	sd	s1,8(a3)
0x0000000000013554 in _malloc_trim_r ()
=> 0x13554 <_malloc_trim_r+146>:	sw	s0,0(a5)
0x0000000000013556 in _malloc_trim_r ()
=> 0x13556 <_malloc_trim_r+148>:	jal	ra,0x11194 <__malloc_unlock>
0x0000000000011194 in __malloc_unlock ()
=> 0x11194 <__malloc_unlock>:	ret
0x000000000001355a in _malloc_trim_r ()
=> 0x1355a <_malloc_trim_r+152>:	ld	ra,40(sp)
0x000000000001355c in _malloc_trim_r ()
=> 0x1355c <_malloc_trim_r+154>:	ld	s0,32(sp)
0x000000000001355e in _malloc_trim_r ()
=> 0x1355e <_malloc_trim_r+156>:	ld	s1,24(sp)
0x0000000000013560 in _malloc_trim_r ()
=> 0x13560 <_malloc_trim_r+158>:	ld	s2,16(sp)
0x0000000000013562 in _malloc_trim_r ()
=> 0x13562 <_malloc_trim_r+160>:	ld	s3,8(sp)
0x0000000000013564 in _malloc_trim_r ()
=> 0x13564 <_malloc_trim_r+162>:	ld	s4,0(sp)
0x0000000000013566 in _malloc_trim_r ()
=> 0x13566 <_malloc_trim_r+164>:	li	a0,1
0x0000000000013568 in _malloc_trim_r ()
=> 0x13568 <_malloc_trim_r+166>:	addi	sp,sp,48
0x000000000001356a in _malloc_trim_r ()
=> 0x1356a <_malloc_trim_r+168>:	ret
0x000000000001373e in _free_r ()
=> 0x1373e <_free_r+422>:	j	0x1364a <_free_r+178>
0x000000000001364a in _free_r ()
=> 0x1364a <_free_r+178>:	ld	s0,16(sp)
0x000000000001364c in _free_r ()
=> 0x1364c <_free_r+180>:	ld	ra,24(sp)
0x000000000001364e in _free_r ()
=> 0x1364e <_free_r+182>:	mv	a0,s1
0x0000000000013650 in _free_r ()
=> 0x13650 <_free_r+184>:	ld	s1,8(sp)
0x0000000000013652 in _free_r ()
=> 0x13652 <_free_r+186>:	addi	sp,sp,32
0x0000000000013654 in _free_r ()
=> 0x13654 <_free_r+188>:	j	0x11194 <__malloc_unlock>
0x0000000000011194 in __malloc_unlock ()
=> 0x11194 <__malloc_unlock>:	ret
0x0000000000019970 in _fclose_r.part.0 ()
=> 0x19970 <_fclose_r.part.0+126>:	j	0x1991e <_fclose_r.part.0+44>
0x000000000001991e in _fclose_r.part.0 ()
=> 0x1991e <_fclose_r.part.0+44>:	ld	a1,88(s0)
0x0000000000019920 in _fclose_r.part.0 ()
=> 0x19920 <_fclose_r.part.0+46>:	beqz	a1,0x19934 <_fclose_r.part.0+66>
0x0000000000019934 in _fclose_r.part.0 ()
=> 0x19934 <_fclose_r.part.0+66>:	ld	a1,120(s0)
0x0000000000019936 in _fclose_r.part.0 ()
=> 0x19936 <_fclose_r.part.0+68>:	beqz	a1,0x19942 <_fclose_r.part.0+80>
0x0000000000019942 in _fclose_r.part.0 ()
=> 0x19942 <_fclose_r.part.0+80>:	jal	ra,0x1346a <__sfp_lock_acquire>
0x000000000001346a in __sfp_lock_acquire ()
=> 0x1346a <__sfp_lock_acquire>:	ret
0x0000000000019946 in _fclose_r.part.0 ()
=> 0x19946 <_fclose_r.part.0+84>:	sh	zero,16(s0)
0x000000000001994a in _fclose_r.part.0 ()
=> 0x1994a <_fclose_r.part.0+88>:	jal	ra,0x1346c <__sfp_lock_release>
0x000000000001346c in __sfp_lock_release ()
=> 0x1346c <__sfp_lock_release>:	ret
0x000000000001994e in _fclose_r.part.0 ()
=> 0x1994e <_fclose_r.part.0+92>:	ld	ra,24(sp)
0x0000000000019950 in _fclose_r.part.0 ()
=> 0x19950 <_fclose_r.part.0+94>:	ld	s0,16(sp)
0x0000000000019952 in _fclose_r.part.0 ()
=> 0x19952 <_fclose_r.part.0+96>:	ld	s1,8(sp)
0x0000000000019954 in _fclose_r.part.0 ()
=> 0x19954 <_fclose_r.part.0+98>:	mv	a0,s2
0x0000000000019956 in _fclose_r.part.0 ()
=> 0x19956 <_fclose_r.part.0+100>:	ld	s2,0(sp)
0x0000000000019958 in _fclose_r.part.0 ()
=> 0x19958 <_fclose_r.part.0+102>:	addi	sp,sp,32
0x000000000001995a in _fclose_r.part.0 ()
=> 0x1995a <_fclose_r.part.0+104>:	ret
0x00000000000138c6 in _fwalk_reent ()
=> 0x138c6 <_fwalk_reent+90>:	or	s6,a0,s6
0x00000000000138ca in _fwalk_reent ()
=> 0x138ca <_fwalk_reent+94>:	sext.w	s6,s6
0x00000000000138cc in _fwalk_reent ()
=> 0x138cc <_fwalk_reent+96>:	addi	s0,s0,176
0x00000000000138d0 in _fwalk_reent ()
=> 0x138d0 <_fwalk_reent+100>:	bne	s1,s0,0x138b0 <_fwalk_reent+68>
0x00000000000138b0 in _fwalk_reent ()
=> 0x138b0 <_fwalk_reent+68>:	lhu	a5,16(s0)
0x00000000000138b4 in _fwalk_reent ()
=> 0x138b4 <_fwalk_reent+72>:	bgeu	s7,a5,0x138cc <_fwalk_reent+96>
0x00000000000138b8 in _fwalk_reent ()
=> 0x138b8 <_fwalk_reent+76>:	lh	a5,18(s0)
0x00000000000138bc in _fwalk_reent ()
=> 0x138bc <_fwalk_reent+80>:	mv	a1,s0
0x00000000000138be in _fwalk_reent ()
=> 0x138be <_fwalk_reent+82>:	mv	a0,s8
0x00000000000138c0 in _fwalk_reent ()
=> 0x138c0 <_fwalk_reent+84>:	beq	a5,s3,0x138cc <_fwalk_reent+96>
0x00000000000138c4 in _fwalk_reent ()
=> 0x138c4 <_fwalk_reent+88>:	jalr	s4
0x0000000000019972 in _fclose_r ()
=> 0x19972 <_fclose_r>:	beqz	a1,0x199ac <_fclose_r+58>
0x0000000000019974 in _fclose_r ()
=> 0x19974 <_fclose_r+2>:	addi	sp,sp,-32
0x0000000000019976 in _fclose_r ()
=> 0x19976 <_fclose_r+4>:	sd	s0,16(sp)
0x0000000000019978 in _fclose_r ()
=> 0x19978 <_fclose_r+6>:	sd	ra,24(sp)
0x000000000001997a in _fclose_r ()
=> 0x1997a <_fclose_r+8>:	mv	s0,a0
0x000000000001997c in _fclose_r ()
=> 0x1997c <_fclose_r+10>:	beqz	a0,0x19982 <_fclose_r+16>
0x000000000001997e in _fclose_r ()
=> 0x1997e <_fclose_r+12>:	lw	a5,80(a0)
0x0000000000019980 in _fclose_r ()
=> 0x19980 <_fclose_r+14>:	beqz	a5,0x1999c <_fclose_r+42>
0x0000000000019982 in _fclose_r ()
=> 0x19982 <_fclose_r+16>:	lh	a5,16(a1)
0x0000000000019986 in _fclose_r ()
=> 0x19986 <_fclose_r+20>:	bnez	a5,0x19992 <_fclose_r+32>
0x0000000000019992 in _fclose_r ()
=> 0x19992 <_fclose_r+32>:	mv	a0,s0
0x0000000000019994 in _fclose_r ()
=> 0x19994 <_fclose_r+34>:	ld	s0,16(sp)
0x0000000000019996 in _fclose_r ()
=> 0x19996 <_fclose_r+36>:	ld	ra,24(sp)
0x0000000000019998 in _fclose_r ()
=> 0x19998 <_fclose_r+38>:	addi	sp,sp,32
0x000000000001999a in _fclose_r ()
=> 0x1999a <_fclose_r+40>:	j	0x198f2 <_fclose_r.part.0>
0x00000000000198f2 in _fclose_r.part.0 ()
=> 0x198f2 <_fclose_r.part.0>:	addi	sp,sp,-32
0x00000000000198f4 in _fclose_r.part.0 ()
=> 0x198f4 <_fclose_r.part.0+2>:	sd	s0,16(sp)
0x00000000000198f6 in _fclose_r.part.0 ()
=> 0x198f6 <_fclose_r.part.0+4>:	sd	s1,8(sp)
0x00000000000198f8 in _fclose_r.part.0 ()
=> 0x198f8 <_fclose_r.part.0+6>:	sd	s2,0(sp)
0x00000000000198fa in _fclose_r.part.0 ()
=> 0x198fa <_fclose_r.part.0+8>:	mv	s0,a1
0x00000000000198fc in _fclose_r.part.0 ()
=> 0x198fc <_fclose_r.part.0+10>:	sd	ra,24(sp)
0x00000000000198fe in _fclose_r.part.0 ()
=> 0x198fe <_fclose_r.part.0+12>:	mv	s1,a0
0x0000000000019900 in _fclose_r.part.0 ()
=> 0x19900 <_fclose_r.part.0+14>:	jal	ra,0x12ff4 <__sflush_r>
0x0000000000012ff4 in __sflush_r ()
=> 0x12ff4 <__sflush_r>:	lh	a5,16(a1)
0x0000000000012ff8 in __sflush_r ()
=> 0x12ff8 <__sflush_r+4>:	addi	sp,sp,-48
0x0000000000012ffa in __sflush_r ()
=> 0x12ffa <__sflush_r+6>:	sd	s0,32(sp)
0x0000000000012ffc in __sflush_r ()
=> 0x12ffc <__sflush_r+8>:	sd	s3,8(sp)
0x0000000000012ffe in __sflush_r ()
=> 0x12ffe <__sflush_r+10>:	sd	ra,40(sp)
0x0000000000013000 in __sflush_r ()
=> 0x13000 <__sflush_r+12>:	sd	s1,24(sp)
0x0000000000013002 in __sflush_r ()
=> 0x13002 <__sflush_r+14>:	sd	s2,16(sp)
0x0000000000013004 in __sflush_r ()
=> 0x13004 <__sflush_r+16>:	andi	a3,a5,8
0x0000000000013008 in __sflush_r ()
=> 0x13008 <__sflush_r+20>:	mv	s0,a1
0x000000000001300a in __sflush_r ()
=> 0x1300a <__sflush_r+22>:	mv	s3,a0
0x000000000001300c in __sflush_r ()
=> 0x1300c <__sflush_r+24>:	bnez	a3,0x130c0 <__sflush_r+204>
0x000000000001300e in __sflush_r ()
=> 0x1300e <__sflush_r+26>:	lui	a4,0x1
0x0000000000013010 in __sflush_r ()
=> 0x13010 <__sflush_r+28>:	addi	a4,a4,-2048
0x0000000000013014 in __sflush_r ()
=> 0x13014 <__sflush_r+32>:	lw	a3,8(a1)
0x0000000000013016 in __sflush_r ()
=> 0x13016 <__sflush_r+34>:	or	a5,a5,a4
0x0000000000013018 in __sflush_r ()
=> 0x13018 <__sflush_r+36>:	sh	a5,16(a1)
0x000000000001301c in __sflush_r ()
=> 0x1301c <__sflush_r+40>:	blez	a3,0x1311c <__sflush_r+296>
0x000000000001311c in __sflush_r ()
=> 0x1311c <__sflush_r+296>:	lw	a4,112(a1)
0x000000000001311e in __sflush_r ()
=> 0x1311e <__sflush_r+298>:	bgtz	a4,0x13020 <__sflush_r+44>
0x0000000000013122 in __sflush_r ()
=> 0x13122 <__sflush_r+302>:	j	0x130b0 <__sflush_r+188>
0x00000000000130b0 in __sflush_r ()
=> 0x130b0 <__sflush_r+188>:	li	a0,0
0x00000000000130b2 in __sflush_r ()
=> 0x130b2 <__sflush_r+190>:	ld	ra,40(sp)
0x00000000000130b4 in __sflush_r ()
=> 0x130b4 <__sflush_r+192>:	ld	s0,32(sp)
0x00000000000130b6 in __sflush_r ()
=> 0x130b6 <__sflush_r+194>:	ld	s1,24(sp)
0x00000000000130b8 in __sflush_r ()
=> 0x130b8 <__sflush_r+196>:	ld	s2,16(sp)
0x00000000000130ba in __sflush_r ()
=> 0x130ba <__sflush_r+198>:	ld	s3,8(sp)
0x00000000000130bc in __sflush_r ()
=> 0x130bc <__sflush_r+200>:	addi	sp,sp,48
0x00000000000130be in __sflush_r ()
=> 0x130be <__sflush_r+202>:	ret
0x0000000000019904 in _fclose_r.part.0 ()
=> 0x19904 <_fclose_r.part.0+18>:	ld	a5,80(s0)
0x0000000000019906 in _fclose_r.part.0 ()
=> 0x19906 <_fclose_r.part.0+20>:	mv	s2,a0
0x0000000000019908 in _fclose_r.part.0 ()
=> 0x19908 <_fclose_r.part.0+22>:	beqz	a5,0x19914 <_fclose_r.part.0+34>
0x000000000001990a in _fclose_r.part.0 ()
=> 0x1990a <_fclose_r.part.0+24>:	ld	a1,48(s0)
0x000000000001990c in _fclose_r.part.0 ()
=> 0x1990c <_fclose_r.part.0+26>:	mv	a0,s1
0x000000000001990e in _fclose_r.part.0 ()
=> 0x1990e <_fclose_r.part.0+28>:	jalr	a5
0x0000000000016c08 in __sclose ()
=> 0x16c08 <__sclose>:	lh	a1,18(a1)
0x0000000000016c0c in __sclose ()
=> 0x16c0c <__sclose+4>:	j	0x198b6 <_close_r>
0x00000000000198b6 in _close_r ()
=> 0x198b6 <_close_r>:	addi	sp,sp,-32
0x00000000000198b8 in _close_r ()
=> 0x198b8 <_close_r+2>:	sd	s0,16(sp)
0x00000000000198ba in _close_r ()
=> 0x198ba <_close_r+4>:	sd	s1,8(sp)
0x00000000000198bc in _close_r ()
=> 0x198bc <_close_r+6>:	mv	s0,a0
0x00000000000198be in _close_r ()
=> 0x198be <_close_r+8>:	mv	a0,a1
0x00000000000198c0 in _close_r ()
=> 0x198c0 <_close_r+10>:	sd	ra,24(sp)
0x00000000000198c2 in _close_r ()
=> 0x198c2 <_close_r+12>:	sw	zero,1936(gp)
0x00000000000198c6 in _close_r ()
=> 0x198c6 <_close_r+16>:	jal	ra,0x1b716 <_close>
0x000000000001b716 in _close ()
=> 0x1b716 <_close>:	addi	sp,sp,-16
0x000000000001b718 in _close ()
=> 0x1b718 <_close+2>:	sd	ra,8(sp)
0x000000000001b71a in _close ()
=> 0x1b71a <_close+4>:	sd	s0,0(sp)
0x000000000001b71c in _close ()
=> 0x1b71c <_close+6>:	li	a7,57
0x000000000001b720 in _close ()
=> 0x1b720 <_close+10>:	ecall
0x000000000001b724 in _close ()
=> 0x1b724 <_close+14>:	mv	s0,a0
0x000000000001b726 in _close ()
=> 0x1b726 <_close+16>:	bltz	a0,0x1b734 <_close+30>
0x000000000001b72a in _close ()
=> 0x1b72a <_close+20>:	sext.w	a0,a0
0x000000000001b72c in _close ()
=> 0x1b72c <_close+22>:	ld	ra,8(sp)
0x000000000001b72e in _close ()
=> 0x1b72e <_close+24>:	ld	s0,0(sp)
0x000000000001b730 in _close ()
=> 0x1b730 <_close+26>:	addi	sp,sp,16
0x000000000001b732 in _close ()
=> 0x1b732 <_close+28>:	ret
0x00000000000198ca in _close_r ()
=> 0x198ca <_close_r+20>:	li	a5,-1
0x00000000000198cc in _close_r ()
=> 0x198cc <_close_r+22>:	beq	a0,a5,0x198da <_close_r+36>
0x00000000000198d0 in _close_r ()
=> 0x198d0 <_close_r+26>:	ld	ra,24(sp)
0x00000000000198d2 in _close_r ()
=> 0x198d2 <_close_r+28>:	ld	s0,16(sp)
0x00000000000198d4 in _close_r ()
=> 0x198d4 <_close_r+30>:	ld	s1,8(sp)
0x00000000000198d6 in _close_r ()
=> 0x198d6 <_close_r+32>:	addi	sp,sp,32
0x00000000000198d8 in _close_r ()
=> 0x198d8 <_close_r+34>:	ret
0x0000000000019910 in _fclose_r.part.0 ()
=> 0x19910 <_fclose_r.part.0+30>:	bltz	a0,0x1995c <_fclose_r.part.0+106>
0x0000000000019914 in _fclose_r.part.0 ()
=> 0x19914 <_fclose_r.part.0+34>:	lhu	a5,16(s0)
0x0000000000019918 in _fclose_r.part.0 ()
=> 0x19918 <_fclose_r.part.0+38>:	andi	a5,a5,128
0x000000000001991c in _fclose_r.part.0 ()
=> 0x1991c <_fclose_r.part.0+42>:	bnez	a5,0x19968 <_fclose_r.part.0+118>
0x000000000001991e in _fclose_r.part.0 ()
=> 0x1991e <_fclose_r.part.0+44>:	ld	a1,88(s0)
0x0000000000019920 in _fclose_r.part.0 ()
=> 0x19920 <_fclose_r.part.0+46>:	beqz	a1,0x19934 <_fclose_r.part.0+66>
0x0000000000019934 in _fclose_r.part.0 ()
=> 0x19934 <_fclose_r.part.0+66>:	ld	a1,120(s0)
0x0000000000019936 in _fclose_r.part.0 ()
=> 0x19936 <_fclose_r.part.0+68>:	beqz	a1,0x19942 <_fclose_r.part.0+80>
0x0000000000019942 in _fclose_r.part.0 ()
=> 0x19942 <_fclose_r.part.0+80>:	jal	ra,0x1346a <__sfp_lock_acquire>
0x000000000001346a in __sfp_lock_acquire ()
=> 0x1346a <__sfp_lock_acquire>:	ret
0x0000000000019946 in _fclose_r.part.0 ()
=> 0x19946 <_fclose_r.part.0+84>:	sh	zero,16(s0)
0x000000000001994a in _fclose_r.part.0 ()
=> 0x1994a <_fclose_r.part.0+88>:	jal	ra,0x1346c <__sfp_lock_release>
0x000000000001346c in __sfp_lock_release ()
=> 0x1346c <__sfp_lock_release>:	ret
0x000000000001994e in _fclose_r.part.0 ()
=> 0x1994e <_fclose_r.part.0+92>:	ld	ra,24(sp)
0x0000000000019950 in _fclose_r.part.0 ()
=> 0x19950 <_fclose_r.part.0+94>:	ld	s0,16(sp)
0x0000000000019952 in _fclose_r.part.0 ()
=> 0x19952 <_fclose_r.part.0+96>:	ld	s1,8(sp)
0x0000000000019954 in _fclose_r.part.0 ()
=> 0x19954 <_fclose_r.part.0+98>:	mv	a0,s2
0x0000000000019956 in _fclose_r.part.0 ()
=> 0x19956 <_fclose_r.part.0+100>:	ld	s2,0(sp)
0x0000000000019958 in _fclose_r.part.0 ()
=> 0x19958 <_fclose_r.part.0+102>:	addi	sp,sp,32
0x000000000001995a in _fclose_r.part.0 ()
=> 0x1995a <_fclose_r.part.0+104>:	ret
0x00000000000138c6 in _fwalk_reent ()
=> 0x138c6 <_fwalk_reent+90>:	or	s6,a0,s6
0x00000000000138ca in _fwalk_reent ()
=> 0x138ca <_fwalk_reent+94>:	sext.w	s6,s6
0x00000000000138cc in _fwalk_reent ()
=> 0x138cc <_fwalk_reent+96>:	addi	s0,s0,176
0x00000000000138d0 in _fwalk_reent ()
=> 0x138d0 <_fwalk_reent+100>:	bne	s1,s0,0x138b0 <_fwalk_reent+68>
0x00000000000138d4 in _fwalk_reent ()
=> 0x138d4 <_fwalk_reent+104>:	ld	s2,0(s2)
0x00000000000138d8 in _fwalk_reent ()
=> 0x138d8 <_fwalk_reent+108>:	bnez	s2,0x13894 <_fwalk_reent+40>
0x00000000000138dc in _fwalk_reent ()
=> 0x138dc <_fwalk_reent+112>:	ld	ra,72(sp)
0x00000000000138de in _fwalk_reent ()
=> 0x138de <_fwalk_reent+114>:	ld	s0,64(sp)
0x00000000000138e0 in _fwalk_reent ()
=> 0x138e0 <_fwalk_reent+116>:	ld	s1,56(sp)
0x00000000000138e2 in _fwalk_reent ()
=> 0x138e2 <_fwalk_reent+118>:	ld	s2,48(sp)
0x00000000000138e4 in _fwalk_reent ()
=> 0x138e4 <_fwalk_reent+120>:	ld	s3,40(sp)
0x00000000000138e6 in _fwalk_reent ()
=> 0x138e6 <_fwalk_reent+122>:	ld	s4,32(sp)
0x00000000000138e8 in _fwalk_reent ()
=> 0x138e8 <_fwalk_reent+124>:	ld	s5,24(sp)
0x00000000000138ea in _fwalk_reent ()
=> 0x138ea <_fwalk_reent+126>:	ld	s7,8(sp)
0x00000000000138ec in _fwalk_reent ()
=> 0x138ec <_fwalk_reent+128>:	ld	s8,0(sp)
0x00000000000138ee in _fwalk_reent ()
=> 0x138ee <_fwalk_reent+130>:	mv	a0,s6
0x00000000000138f0 in _fwalk_reent ()
=> 0x138f0 <_fwalk_reent+132>:	ld	s6,16(sp)
0x00000000000138f2 in _fwalk_reent ()
=> 0x138f2 <_fwalk_reent+134>:	addi	sp,sp,80
0x00000000000138f4 in _fwalk_reent ()
=> 0x138f4 <_fwalk_reent+136>:	ret
0x0000000000010a3c in exit ()
=> 0x10a3c <exit+24>:	mv	a0,s0
0x0000000000010a3e in exit ()
=> 0x10a3e <exit+26>:	jal	ra,0x1b742 <_exit>
0x000000000001b742 in _exit ()
=> 0x1b742 <_exit>:	li	a7,93
0x000000000001b746 in _exit ()
=> 0x1b746 <_exit+4>:	ecall
[Inferior 1 (process 742) exited normally]
script_remote.gdb:25: Error in sourced command file:
No registers.
